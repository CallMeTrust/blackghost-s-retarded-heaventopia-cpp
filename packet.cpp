
#include "stdafx.h"
#include <iostream>
#include <stdlib.h>
#include <type_traits>
#include <filesystem>
#include <experimental/filesystem>
#include "enet/enet.h"
#include <string>
#include <condition_variable>
#include <atomic>
#include <stdint.h>
#include <queue>
#include <memory>
#ifdef _WIN32
#include <windows.h>
#include <conio.h>
#include <regex>
#endif
#ifdef __linux__
#include <stdio.h>
char _getch() {
	return getchar();
}
#endif
#include <vector>
#include <sstream>
#include <chrono>
#include <fstream>
#include "json.hpp"
#ifdef _WIN32
#include "bcrypt.h"
#include "crypt_blowfish/crypt_gensalt.cpp"
#include "crypt_blowfish/crypt_blowfish.h"
#include "crypt_blowfish/crypt_blowfish.cpp"
#include "crypt_blowfish/ow-crypt.cpp"
#include "bcrypt.cpp"
#else
#include "bcrypt.h"
#include "bcrypt.cpp"
#include "crypt_blowfish/crypt_gensalt.h"
#include "crypt_blowfish/crypt_gensalt.cpp"
#include "crypt_blowfish/crypt_blowfish.h"
#include "crypt_blowfish/crypt_blowfish.cpp"
#include "crypt_blowfish/ow-crypt.h"
#include "crypt_blowfish/ow-crypt.cpp"
#include "bcrypt.h"
#endif
#include <thread> // TODO
#include <mutex> // TODO
#include <regex>
#pragma warning(disable : 4996)
int totaluserids = 0;
int online = 0;
int gem_event = 0;
using namespace std;
using json = nlohmann::json;
vector<string> bannedlist;
bool serverIsFrozen = false;
//#define TOTAL_LOG
#define REGISTRATION
#include <signal.h>
#ifdef __linux__
#include <cstdint>
typedef unsigned char BYTE;
typedef unsigned char __int8;
typedef unsigned short __int16;
typedef unsigned int DWORD;
#endif
ENetHost* server;
int cId = 1;
BYTE* itemsDat = 0;
int itemsDatSize = 0;
BYTE* itemsDatNormal = 0;
int itemsDatSizeNormal = 0;
int itemdathashNormal;
int lastIPLogon = 0;
int configPort = 802;
string music = "";
long long int lastIPWait = 0;
int resultnbr1 = 0;
int resultnbr2 = 0;
int hasil = 0;
int prize = 0;
bool restartForUpdate = false;
long long int quest = 0;
class A {};

enum E : int {};

template <class T>
T f(T i)
{
	static_assert(std::is_integral<T>::value, "Integral required.");
	return i;
}
unsigned int sleep(unsigned int seconds);
//Linux equivalent of GetLastError
#ifdef __linux__
string GetLastError() {
	return strerror(errno);
}
//Linux has no byteswap functions.
ulong _byteswap_ulong(ulong x)
{
	// swap adjacent 32-bit blocks
	//x = (x >> 32) | (x << 32);
	// swap adjacent 16-bit blocks
	x = ((x & 0xFFFF0000FFFF0000) >> 16) | ((x & 0x0000FFFF0000FFFF) << 16);
	// swap adjacent 8-bit blocks
	return ((x & 0xFF00FF00FF00FF00) >> 8) | ((x & 0x00FF00FF00FF00FF) << 8);
}
#endif

/***bcrypt***/
bool worldproperlock;
std::vector<std::string> split(std::string strToSplit, char delimeter)
{
	std::stringstream ss(strToSplit);
	std::string item;
	std::vector<std::string> splittedStrings;
	while (std::getline(ss, item, delimeter))
	{
		splittedStrings.push_back(item);
	}
	return splittedStrings;
}

std::vector<std::string> split(std::string stringToBeSplitted, std::string delimeter)
{
	std::vector<std::string> splittedString;
	int startIndex = 0;
	int  endIndex = 0;
	while ((endIndex = stringToBeSplitted.find(delimeter, startIndex)) < stringToBeSplitted.size())
	{

		std::string val = stringToBeSplitted.substr(startIndex, endIndex - startIndex);
		splittedString.push_back(val);
		startIndex = endIndex + delimeter.size();

	}
	if (startIndex < stringToBeSplitted.size())
	{
		std::string val = stringToBeSplitted.substr(startIndex);
		splittedString.push_back(val);
	}
	return splittedString;

}
bool verifyPassword(string password, string hash) {
	int ret;

	ret = bcrypt_checkpw(password.c_str(), hash.c_str());
	assert(ret != -1);

	return !ret;
}
string OutputBanTime(int n)
{
	string x;
	int day = n / (24 * 3600);
	if (day != 0) x.append(to_string(day) + " days, ");
	n = n % (24 * 3600);
	int hour = n / 3600;
	if (hour != 0) x.append(to_string(hour) + " hours ");
	n %= 3600;
	int minutes = n / 60;
	if (minutes != 0) x.append(to_string(minutes) + " minutes, & ");
	n %= 60;
	int seconds = n;
	if (seconds != 0) x.append(to_string(seconds) + " seconds");
	return x;
}
string OutputBanTime1(int n)
{
	string x;
	int day = n / (24 * 3600);
	if (day != 0) x.append(to_string(day) + " days, ");
	n = n % (24 * 3600);
	int hour = n / 3600;
	if (hour != 0) x.append(to_string(hour) + " hours ");
	n %= 3600;
	int minutes = n / 60;
	if (minutes != 0) x.append(to_string(minutes) + " minutes, ");
	n %= 60;
	int seconds = n;
	if (seconds != 0) x.append(to_string(seconds) + " seconds");
	return x;
}
string hashPassword(string password) {
	char salt[BCRYPT_HASHSIZE];
	char hash[BCRYPT_HASHSIZE];
	int ret;

	ret = bcrypt_gensalt(12, salt);
	assert(ret == 0);
	ret = bcrypt_hashpw(password.c_str(), salt, hash);
	assert(ret == 0);
	return hash;
}

const std::string currentDateTime() {
	time_t     now = time(0);
	struct tm  tstruct;
	char       buf[80];
	tstruct = *localtime(&now);
	// Visit http://en.cppreference.com/w/cpp/chrono/c/strftime
	// for more information about date/time format
	strftime(buf, sizeof(buf), "%Y/%m/%d %X", &tstruct);

	return buf;
}
/***bcrypt**/
bool ValueInRange(const std::string& input, int& min, int& max);

void sendData(ENetPeer* peer, int num, char* data, int len)
{
	/* Create a reliable packet of size 7 containing "packet\0" */
	ENetPacket* packet = enet_packet_create(0,
		len + 5,
		ENET_PACKET_FLAG_RELIABLE);
	/* Extend the packet so and append the string "foo", so it now */
	/* contains "packetfoo\0"                                      */
	/* Send the packet to the peer over channel id 0. */
	/* One could also broadcast the packet by         */
	/* enet_host_broadcast (host, 0, packet);         */
	memcpy(packet->data, &num, 4);
	if (data != NULL)
	{
		memcpy(packet->data + 4, data, len);
	}
	char zero = 0;
	memcpy(packet->data + 4 + len, &zero, 1);
	enet_peer_send(peer, 0, packet);
	enet_host_flush(server);
}

int getPacketId(char* data)
{
	return *data;
}

char* getPacketData(char* data)
{
	return data + 4;
}

string text_encode(char* text)
{
	string ret = "";
	while (text[0] != 0)
	{
		switch (text[0])
		{
		case '\n':
			ret += "\\n";
			break;
		case '\t':
			ret += "\\t";
			break;
		case '\b':
			ret += "\\b";
			break;
		case '\\':
			ret += "\\\\";
			break;
		case '\r':
			ret += "\\r";
			break;
		default:
			ret += text[0];
			break;
		}
		text++;
	}
	return ret;
}

int ch2n(char x)
{
	switch (x)
	{
	case '0':
		return 0;
	case '1':
		return 1;
	case '2':
		return 2;
	case '3':
		return 3;
	case '4':
		return 4;
	case '5':
		return 5;
	case '6':
		return 6;
	case '7':
		return 7;
	case '8':
		return 8;
	case '9':
		return 9;
	case 'A':
		return 10;
	case 'B':
		return 11;
	case 'C':
		return 12;
	case 'D':
		return 13;
	case 'E':
		return 14;
	case 'F':
		return 15;
	default:
		break;
	}
}


char* GetTextPointerFromPacket(ENetPacket* packet)
{
	char zero = 0;
	memcpy(packet->data + packet->dataLength - 1, &zero, 1);
	return (char*)(packet->data + 4);
}

BYTE* GetStructPointerFromTankPacket(ENetPacket* packet)
{
	unsigned int packetLenght = packet->dataLength;
	BYTE* result = NULL;
	if (packetLenght >= 0x3C)
	{
		BYTE* packetData = packet->data;
		result = packetData + 4;
		if (*(BYTE*)(packetData + 16) & 8)
		{
			if (packetLenght < *(int*)(packetData + 56) + 60)
			{
				cout << "[!] Packet too small for extended packet to be valid" << endl;
				cout << "[!] Sizeof float is 4.  TankUpdatePacket size: 56" << endl;
				result = 0;
			}
		}
		else
		{
			int zero = 0;
			memcpy(packetData + 56, &zero, 4);
		}
	}
	return result;
}

int GetMessageTypeFromPacket(ENetPacket* packet)
{
	int result;

	if (packet->dataLength > 3u)
	{
		result = *(packet->data);
	}
	else
	{
		cout << "[!] Bad packet length, ignoring message" << endl;
		result = 0;
	}
	return result;
}


vector<string> explode(const string& delimiter, const string& str)
{
	vector<string> arr;

	int strleng = str.length();
	int delleng = delimiter.length();
	if (delleng == 0)
		return arr;//no change

	int i = 0;
	int k = 0;
	while (i < strleng)
	{
		int j = 0;
		while (i + j < strleng && j < delleng && str[i + j] == delimiter[j])
			j++;
		if (j == delleng)//found delimiter
		{
			arr.push_back(str.substr(k, i - k));
			i += delleng;
			k = i;
		}
		else
		{
			i++;
		}
	}
	arr.push_back(str.substr(k, i - k));
	return arr;
}

struct GamePacket
{
	BYTE* data;
	int len;
	int indexes;
};

struct gamepacket_t
{
private:
	int index = 0;
	int len = 0;
	byte* packet_data = new byte[61];

public:
	gamepacket_t(int delay = 0, int NetID = -1) {

		len = 61;
		int MessageType = 0x4;
		int PacketType = 0x1;
		int CharState = 0x8;

		memset(packet_data, 0, 61);
		memcpy(packet_data, &MessageType, 4);
		memcpy(packet_data + 4, &PacketType, 4);
		memcpy(packet_data + 8, &NetID, 4);
		memcpy(packet_data + 16, &CharState, 4);
		memcpy(packet_data + 24, &delay, 4);
	};
	~gamepacket_t() {
		delete[] packet_data;
	}

	void Insert(string a) {
		byte* data = new byte[len + 2 + a.length() + 4];
		memcpy(data, packet_data, len);
		delete[] packet_data;
		packet_data = data;
		data[len] = index;
		data[len + 1] = 0x2;
		int str_len = a.length();
		memcpy(data + len + 2, &str_len, 4);
		memcpy(data + len + 6, a.data(), str_len);
		len = len + 2 + a.length() + 4;
		index++;
		packet_data[60] = (byte)index;
	}
	void Insert(int a) {
		byte* data = new byte[len + 2 + 4];
		memcpy(data, packet_data, len);
		delete[] packet_data;
		packet_data = data;
		data[len] = index;
		data[len + 1] = 0x9;
		memcpy(data + len + 2, &a, 4);
		len = len + 2 + 4;
		index++;
		packet_data[60] = (byte)index;
	}
	void Insert(unsigned int a) {
		byte* data = new byte[len + 2 + 4];
		memcpy(data, packet_data, len);
		delete[] packet_data;
		packet_data = data;
		data[len] = index;
		data[len + 1] = 0x5;
		memcpy(data + len + 2, &a, 4);
		len = len + 2 + 4;
		index++;
		packet_data[60] = (byte)index;
	}
	void Insert(float a) {
		byte* data = new byte[len + 2 + 4];
		memcpy(data, packet_data, len);
		delete[] packet_data;
		packet_data = data;
		data[len] = index;
		data[len + 1] = 0x1;
		memcpy(data + len + 2, &a, 4);
		len = len + 2 + 4;
		index++;
		packet_data[60] = (byte)index;
	}
	void Insert(float a, float b) {
		byte* data = new byte[len + 2 + 8];
		memcpy(data, packet_data, len);
		delete[] packet_data;
		packet_data = data;
		data[len] = index;
		data[len + 1] = 0x3;
		memcpy(data + len + 2, &a, 4);
		memcpy(data + len + 6, &b, 4);
		len = len + 2 + 8;
		index++;
		packet_data[60] = (byte)index;
	}
	void Insert(float a, float b, float c) {
		byte* data = new byte[len + 2 + 12];
		memcpy(data, packet_data, len);
		delete[] packet_data;
		packet_data = data;
		data[len] = index;
		data[len + 1] = 0x4;
		memcpy(data + len + 2, &a, 4);
		memcpy(data + len + 6, &b, 4);
		memcpy(data + len + 10, &c, 4);
		len = len + 2 + 12;
		index++;
		packet_data[60] = (byte)index;
	}
	void CreatePacket(ENetPeer* peer) {
		ENetPacket* packet = enet_packet_create(packet_data, len, 1);
		enet_peer_send(peer, 0, packet);
	}
};

GamePacket appendFloat(GamePacket p, float val)
{
	//p.data[56] += 1;
	BYTE* n = new BYTE[p.len + 2 + 4];
	memcpy(n, p.data, p.len);
	delete p.data;
	p.data = n;
	n[p.len] = p.indexes;
	n[p.len + 1] = 1;
	memcpy(n + p.len + 2, &val, 4);
	p.len = p.len + 2 + 4;
	p.indexes++;
	return p;
}

GamePacket appendFloat(GamePacket p, float val, float val2)
{
	//p.data[56] += 1;
	BYTE* n = new BYTE[p.len + 2 + 8];
	memcpy(n, p.data, p.len);
	delete p.data;
	p.data = n;
	n[p.len] = p.indexes;
	n[p.len + 1] = 3;
	memcpy(n + p.len + 2, &val, 4);
	memcpy(n + p.len + 6, &val2, 4);
	p.len = p.len + 2 + 8;
	p.indexes++;
	return p;
}

GamePacket appendFloat(GamePacket p, float val, float val2, float val3)
{
	//p.data[56] += 1;
	BYTE* n = new BYTE[p.len + 2 + 12];
	memcpy(n, p.data, p.len);
	delete p.data;
	p.data = n;
	n[p.len] = p.indexes;
	n[p.len + 1] = 4;
	memcpy(n + p.len + 2, &val, 4);
	memcpy(n + p.len + 6, &val2, 4);
	memcpy(n + p.len + 10, &val3, 4);
	p.len = p.len + 2 + 12;
	p.indexes++;
	return p;
}

GamePacket appendInt(GamePacket p, int val)
{
	//p.data[56] += 1;
	BYTE* n = new BYTE[p.len + 2 + 4];
	memcpy(n, p.data, p.len);
	delete p.data;
	p.data = n;
	n[p.len] = p.indexes;
	n[p.len + 1] = 9;
	memcpy(n + p.len + 2, &val, 4);
	p.len = p.len + 2 + 4;
	p.indexes++;
	return p;
}

GamePacket appendIntx(GamePacket p, int val)
{
	//p.data[56] += 1;
	BYTE* n = new BYTE[p.len + 2 + 4];
	memcpy(n, p.data, p.len);
	delete p.data;
	p.data = n;
	n[p.len] = p.indexes;
	n[p.len + 1] = 5;
	memcpy(n + p.len + 2, &val, 4);
	p.len = p.len + 2 + 4;
	p.indexes++;
	return p;
}

GamePacket appendString(GamePacket p, string str)
{
	//p.data[56] += 1;
	BYTE* n = new BYTE[p.len + 2 + str.length() + 4];
	memcpy(n, p.data, p.len);
	delete p.data;
	p.data = n;
	n[p.len] = p.indexes;
	n[p.len + 1] = 2;
	int sLen = str.length();
	memcpy(n + p.len + 2, &sLen, 4);
	memcpy(n + p.len + 6, str.c_str(), sLen);
	p.len = p.len + 2 + str.length() + 4;
	p.indexes++;
	return p;
}

GamePacket createPacket()
{
	BYTE* data = new BYTE[61];
	string asdf = "0400000001000000FFFFFFFF00000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
	for (int i = 0; i < asdf.length(); i += 2)
	{
		char x = ch2n(asdf[i]);
		x = x << 4;
		x += ch2n(asdf[i + 1]);
		memcpy(data + (i / 2), &x, 1);
		if (asdf.length() > 61 * 2) throw 0;
	}
	GamePacket packet;
	packet.data = data;
	packet.len = 61;
	packet.indexes = 0;
	return packet;
}

GamePacket packetEnd(GamePacket p)
{
	BYTE* n = new BYTE[p.len + 1];
	memcpy(n, p.data, p.len);
	delete p.data;
	p.data = n;
	char zero = 0;
	memcpy(p.data + p.len, &zero, 1);
	p.len += 1;
	//*(int*)(p.data + 52) = p.len;
	*(int*)(p.data + 56) = p.indexes;//p.len-60;//p.indexes;
	*(BYTE*)(p.data + 60) = p.indexes;
	//*(p.data + 57) = p.indexes;
	return p;
}

struct oof {
	bool magplant = true; //mag code!1!!!1!!11
	bool gazette = false;
};
struct InventoryItem {
	__int16 itemID;
	__int16 itemCount;
};


struct PlayerInventory {
	vector<InventoryItem> items;
	//int inventorySize = 200;
};


#define cloth0 cloth_hair
#define cloth1 cloth_shirt
#define cloth2 cloth_pants
#define cloth3 cloth_feet
#define cloth4 cloth_face
#define cloth5 cloth_hand
#define cloth6 cloth_back
#define cloth7 cloth_mask
#define cloth8 cloth_necklace
#define cloth9 cloth_ances
#define STR16(x, y) (*(uint16_t*)(&(x)[(y)]))
#define STRINT(x, y) (*(int*)(&(x)[(y)]))
#define Property_Zero 0
#define Property_NoSeed 1
#define Property_Dropless 2
#define Property_Beta 4
#define Property_Mod 8
#define Property_Untradable 16
#define Property_Wrenchable 32
#define Property_MultiFacing 64
#define Property_Permanent 128
#define Property_AutoPickup 256
#define Property_WorldLock 512
#define Property_NoSelf 1024
#define Property_RandomGrow 2048
#define Property_Public 4096

vector<string>guildmem;
vector<string>guildelder;
vector<string>guildco;
struct TradeItem
{
	int id;
	int count;
};

struct PlayerInfo {
	// items
	vector<string> paid;
	int lastTradeItem = 0;
	string notebook = "";
	int wrenchx;
	bool chatnotifications = false;
	int wrenchy;
	bool acceptedFinalDialog = false;
	string doorID = "";
	int lastTD1 = 0;
	int lastdonateitem = 0;
	bool isInFinalTradeDialog = false;
	int lastTD2 = 0;
	bool dotrade = false;
	bool istrading = false;
	bool isWaitingForTrade = false;
	int isWaitingForTradeWithUserID = 0;
	vector<TradeItem> tradeItems;
	bool isAcceptingTrade = false;
	int isTradingWithUserID = 0;
	int lastTradeNetID = 0;
	string lastTradeName = "";
	string currentTradeItems = "";
	int lastTD3 = 0;
	int lastTD4 = 0;
	int lastCT1 = 0;
	int lastCT2 = 0;
	int lastCT3 = 0;
	int lastCT4 = 0;
	int updateReq = 0;
	unsigned long long int lastMuted = 0;
	unsigned long long int lastCursed = 0;
	string lastInfoAboutPlayer = "none";
	int lastvenditem = 0;
	int lastvendprice;
	int wrenchedBlockLocation = -1;
	int wrenchedMagLocation = -1;
	int lastdropitemcount = 0;
	int lastdropitem = 0;
	int lasttrashitem = 0;
	int lasttrashitemcount = 0;
	bool isInWorld = false;

	int blockvisual = 0;
	int droppeditemcount = 0;

	bool hasSecurity = false;
	bool online = false;
	int c0de = 0;

	int respawnX = 0;
	int respawnY = 0;

	bool ischeck = false;
	int checkx = 0;
	int checky = 0;

	int lastprice = 0;
	string seller = "";

	int userID;

	bool isNicked = false;

	vector<string>worldsowned;
	vector<string>createworldsowned;
	int wrenchsession = 0;

	int lavaLevel = 0;

	string wrenchedplayer = "";
	string wrenchdisplay = "";

	int atmgems = 0;
	int gttrwls = 0;

	int guildranklevel = 0;

	int posX;
	int posY;

	int lastPunchY;
	int lastPunchX;

	int SignPosX;
	int SignPosY;

	string macaddress = "";
	string lastInfo = "";
	string lastInfoWorld = "";
	string lastfriend = "";

	int bandate = 0;
	int bantime = 0;

	bool hasLogon = false;

	bool premiumpass = false;

	bool sellingItem = false;
	string sitem = "";
	int marketid = 0;
	int marketcount = 0;
	int lastMarketItem = 0;
	int marketprice = 0;

	string muser = "";

	bool legend = false;
	bool milk = false;

	bool isIn = false;
	int netID;
	bool tradeSomeone = false;
	string trdStarter = "";
	bool haveGrowId = false;
	int characterState = 0;
	vector<string>friendinfo;
	vector<string>createfriendtable;
	string tankIDName = "";
	string tankIDNamebackup = "";
	string tankIDNamebackupp = "";
	int xp = 0;
	int level = 1;
	bool isAccess = false;
	string tankIDPass = "";
	string requestedName = "";
	string rawName = "";
	string displayName = "";
	string country = "";
	int adminLevel = 0;
	string currentWorld = "EXIT";
	string lastInfoname = "";
	string lastgm = "";
	string lastgmname = "";
	string lastgmworld = "";
	string guildlast = "";
	bool isinvited = false;
	int guildBg = 0;
	int guildFg = 0;
	int petlevel = 0;
	//GUILD SYSTEM
	string guildStatement = "";
	string guildLeader = "";
	vector <string> guildmatelist;
	vector<string>guildMembers;
	int guildlevel = 0;
	int guildexp = 0;
	string vid = "";
	string wkid = "";
	string aid = "";
	string createGuildName = "";
	string createGuildStatement = "";
	string createGuildFlagBg = "";
	string createGuildFlagFg = "";

	string guild = "";

	bool joinguild = false;

	//GUILD SYSTEM 
	bool radio = true;
	int peffect = 8421376;
	int blockx = 0;
	int blocky = 0;
	int x;
	int y;
	int xy;
	int x1;
	int y1;
	bool isRotatedLeft = false;
	bool RotatedLeft = false;
	string charIP = "";
	bool isUpdating = false;
	bool joinClothesUpdated = false;

	string RequestedName = "";
	string f = "";
	string protocol = "";
	string gameVersion = "";
	string cbits = "";
	string fz = "";
	string lmode = "";
	string playerage = "";
	string GDPR = "";
	string hash2 = "";
	string meta = "";
	string fhash = "";
	string rid = "";
	string platformid = "";
	string deviceversion = "";
	string hash = "";
	string metaip = "";
	string mac = "";
	string reconnect = "";
	string wk = "";
	string zf = "";

	// rubble
	int rubble = 0;

	// bet system
	string bettername = "";
	bool isInBet = false;
	bool isspun = false;

	// msg
	string msgName = "";
	string lastMsger = "";
	string lastMsgerTrue = "";
	string lastMsgWorld = "";

	bool taped = false;

	// trade
	bool isTrading = false;
	string tradername = "";
	int acceptedTrade = 0;
	int tradeitem1 = 0;
	int tradeitem2 = 0;
	int tradeitem3 = 0;
	int tradeitem4 = 0;

	int cloth_hair = 0; // 0
	int cloth_shirt = 0; // 1
	int cloth_pants = 0; // 2
	int cloth_feet = 0; // 3
	int cloth_face = 0; // 4
	int cloth_hand = 0; // 5
	int cloth_back = 0; // 6
	int cloth_mask = 0; // 7
	int cloth_necklace = 0; // 8
	int cloth_ances = 0; // 9

	// achievements

	int ThisLandIsMyLand = 0;
	int ban = 0;

	bool canWalkInBlocks = false; // 1
	bool canDoubleJump = false; // 2
	bool isInvisible = false; // 4
	bool noHands = false; // 8
	bool noEyes = false; // 16
	bool noBody = false; // 32
	bool devilHorns = false; // 64
	bool goldenHalo = false; // 128
	bool isFrozen = false; // 2048
	bool isCursed = false; // 4096
	bool isDuctaped = false; // 8192
	bool haveCigar = false; // 16384
	bool isShining = false; // 32768
	bool isZombie = false; // 65536
	bool isHitByLava = false; // 131072
	bool haveHauntedShadows = false; // 262144
	bool haveGeigerRadiation = false; // 524288
	bool haveReflector = false; // 1048576
	bool isEgged = false; // 2097152
	bool havePineappleFloag = false; // 4194304
	bool haveFlyingPineapple = false; // 8388608
	bool haveSuperSupporterName = false; // 16777216
	bool haveSupperPineapple = false; // 33554432
	long long int gem = 0;
	long long int wls = 0;
	bool isGhost = false;
	bool isinv = false;
	//bool 
	int skinColor = 0xC8E5FFFF; //normal SKin color like gt!

	bool isRespawning = false;
	long long int lastRESPAWN = 0;

	PlayerInventory inventory;
	short currentInventorySize = 0;
	bool loadedInventory = false;

	long long int lastSPIN = 0;
	long long int lastSB = 0;
	long long int lastBC = 0;
	long long int lastMUTED = 0;
	long long int lastBREAK = 0;
	int mutetime = 0;
	bool legendorbg = false;
};
int getState(PlayerInfo* info) {
	int val = 0;
	val |= info->canWalkInBlocks << 0;
	val |= info->canDoubleJump << 1;
	val |= info->noHands << 3;
	val |= info->noEyes << 4;
	val |= info->noBody << 5;
	val |= info->goldenHalo << 7;
	val |= info->isFrozen << 11;
	val |= info->isCursed << 12;
	val |= info->isDuctaped << 13;
	val |= info->haveCigar << 14;
	val |= info->isShining << 15;
	val |= info->isZombie << 16;
	val |= info->isHitByLava << 17;
	val |= info->haveHauntedShadows << 18;
	val |= info->haveGeigerRadiation << 19;
	val |= info->haveReflector << 20;
	val |= info->isEgged << 21;
	val |= info->havePineappleFloag << 22;
	val |= info->haveFlyingPineapple << 23;
	val |= info->haveSuperSupporterName << 24;
	val |= info->haveSupperPineapple << 25;
	return val;
}

int getCharstat(PlayerInfo* info) {
	int val = 0;
	if (info->haveGrowId == false) {
		val = 50000;
	}
	else {
		val = 0;
	}
	if (info->cloth_hand == 6028) val = 1024;
	if (info->cloth_hand == 6262) val = 8192;

	return val;
}
struct DroppedItem { // TODO
	int id = 0;
	int uid = -1;
	int count = 0;
	int x = -1, y = -1;
};
/*struct seeds {
	int one = 0;
	int two = 0;
	int will = 0;
};

vector<seeds> supply;


void supplice() {
	std::ifstream in("seeds.txt");
	std::string str;
	while (std::getline(in, str))
	{
		if (str.length() > 3 && str[0] != '/' && str[1] != '/') {
			vector<string> ex = explode("|", str);
			int will = stoi(ex[0]);
			int one = stoi(ex[1]);
			int two = stoi(ex[2]);
			seeds se;
			se.one = one;
			se.two = two;
			se.will = will;
			supply.push_back(se);
		}
	}
}*/
struct WorldItem {
	__int16 foreground = 0;
	int magitem = 0;
	int magX = 0;
	int magY = 0;
	int dshelf1 = 0;
	int yellowGems = 0;
	int blueGems = 0;
	int redGems = 0;
	int greenGems = 0;
	int purpleGems = 0;
	bool sold = false;
	bool isopen = false;
	int price = 0;
	bool peritem = false;
	int counts1 = 0;
	int dshelf2 = 0;
	int dshelf3 = 0;
	int donate1 = 0;
	int donate2 = 0;
	int donate3 = 0;
	int donate4 = 0;
	int donate5 = 0;
	int donate6 = 0;
	int donate7 = 0;
	int donate8 = 0;
	int donate9 = 0;
	int donate10 = 0;
	int cdonate1 = 0;
	int cdonate2 = 0;
	int cdonate3 = 0;
	int cdonate4 = 0;
	int cdonate5 = 0;
	int cdonate6 = 0;
	int cdonate7 = 0;
	int cdonate8 = 0;
	int cdonate9 = 0;
	int cdonate10 = 0;
	string mdonate1 = "";
	string mdonate2 = "";
	string mdonate3 = "";
	string mdonate4 = "";
	string mdonate5 = "";
	string mdonate6 = "";
	string mdonate7 = "";
	string mdonate8 = "";
	string mdonate9 = "";
	string mdonate10 = "";
	int dshelf4 = 0;
	int magcount = 0;
	string sign = "";
	bool magcollect = false;
	__int16 background = 0;
	int breakLevel = 0;
	int display = 0;
	long long int breakTime = 0;
	bool isLocked = false;
	int displayblock;
	bool rotatedLeft = false;
	bool water = false;
	bool fire = false;
	bool glue = false;
	bool red = false;
	bool green = false;
	bool blue = false;

	int clothHair = 0;
	int clothHead = 0;
	int clothMask = 0;
	int clothHand = 0;
	int clothNeck = 0;
	int clothShirt = 0;
	int clothPants = 0;
	int clothFeet = 0;
	int clothBack = 0;

	int dropItem = 0;
	int amount = 0; // like this

	string text = "";
	string signn = "";

	vector<string> mailbox;

	int gravity = 0;
	bool flipped = false;
	bool active = false;
	bool silenced = false;
	int16_t lockId = 0;
	string label = "";
	string destWorld = "";
	string destId = "";
	string currId = "";
	string password = "";
	int intdata = 0;
	bool activated = false;
	int displayBlock = 0;
	bool isOpened = false;
};
struct WorldInfo {
	int width = 100;
	int height = 60;
	string name = "TEST";
	WorldItem* items;
	string owner = "";
	int weather = 0;
	int bgID = 0;
	int rainitem = 0;
	int maggem = 0;
	bool maggemc = false;
	int stuffgrav = 0;
	bool isPublic = false;
	string passwrd = "";
	bool gscanpublic = false;
	bool isNuked = false;
	vector<string> acclist;
	vector<string> safevault;
	bool noclip = false;
	int ownerID = 0;
	int stuffID = 0;
	int gravity = 0;
	vector<DroppedItem> droppedItems;
	int droppedItemUid = 0;
	bool isCasino = false;
	int droppedCount = 0;
	bool magplant = false;
	int maggems = 0;
	bool online = false;
};
WorldInfo generateWorld(string name, int width, int height)
{
	try {
		WorldInfo world;
		world.name = name;
		world.width = width;
		world.height = height;
		world.items = new WorldItem[world.width * world.height];
		int randMB = (rand() % 100);
		for (int i = 0; i < world.width * world.height; i++)
		{
			if (i >= 3700)
				world.items[i].background = 14;
			if (i >= 3700)
				world.items[i].foreground = 2;
			if (i == 3600 + randMB)
				world.items[i].foreground = 6;
			else if (i >= 3600 && i < 3700)
				world.items[i].foreground = 0;
			if (i == 3700 + randMB)
				world.items[i].foreground = 8;
			if (i >= 3800 && i < 5400 && !(rand() % 48)) { world.items[i].foreground = 10; }
			if (i >= 5000 && i < 5400 && !(rand() % 6)) { world.items[i].foreground = 4; }
			else if (i >= 5400) { world.items[i].foreground = 8; }
		}
		return world;
	}
	catch (...) {
		cout << "Crash detected on WorldInfo (generateworld)" << endl;
	}
}
WorldInfo generateWorlds(string name, int width, int height)
{
	WorldInfo world;
	world.name = name;
	world.width = width;
	world.height = height;
	world.items = new WorldItem[world.width * world.height];
	int randMB = (rand() % 100);
	for (int i = 0; i < world.width * world.height; i++)
	{
		if (i >= 3700)
			world.items[i].background = 14;
		if (i >= 3700)
			world.items[i].foreground = 1132;
		if (i == 3600 + randMB)
			world.items[i].foreground = 6;
		else if (i >= 3600 && i < 3700)
			world.items[i].foreground = 0;
		if (i == 3700 + randMB)
			world.items[i].foreground = 8;
		if (i >= 3800 && i < 5400 && !(rand() % 48)) { world.items[i].foreground = 10; }
		if (i >= 5000 && i < 5400 && !(rand() % 6)) { world.items[i].foreground = 4; }
		else if (i >= 5400) { world.items[i].foreground = 8; }
	}
	return world;
}
class PlayerDB {
public:
	static string getProperName(string name);
	static string fixColors(string text);
	static int playerLogin(ENetPeer* peer, string username, string password);
	static int playerRegister(ENetPeer* peer, string username, string password, string passwordverify, string email, string discord);

	static int guildRegister(ENetPeer* peer, string guildName, string guildStatement, string guildFlagfg, string guildFlagbg);
};

enum LabelStyles {
	LABEL_BIG,
	LABEL_SMALL
};

enum SpacerTypes
{
	SPACER_BIG,
	SPACER_SMALL
};

enum CheckboxTypes
{
	CHECKBOX_SELECTED,
	CHECKBOX_NOT_SELECTED
};
#pragma region Dialog stuff
/*
	Dialog api starts.
*/

class GTDialog
{
public:
	string dialogstr = "";
	void addSpacer(SpacerTypes type);
	void addLabelWithIcon(string text, int tileid, LabelStyles type);
	void addLabel(string text, int tileid, LabelStyles type);
	void addButton(string buttonname, string buttontext);
	void addCheckbox(string checkboxname, string string, CheckboxTypes type);
	void addTextBox(string str);
	void addSmallText(string str);
	void addInputBox(string name, string text, string cont, int size);
	void addQuickExit();
	void endDialog(string name, string accept, string nvm);
	void addCustom(string name);
	string finishDialog();

	operator string() {
		return this->dialogstr;
	}
};


void GTDialog::addSpacer(SpacerTypes type) {
	switch (type)
	{
	case SPACER_BIG:
		this->dialogstr.append("add_spacer|big|\n");
		break;
	case SPACER_SMALL:
		this->dialogstr.append("add_spacer|small|\n");
		break;
	default:
		break;
	}
}

void GTDialog::addLabelWithIcon(string text, int tileid, LabelStyles type) {
	switch (type)
	{
	case LABEL_BIG:
		this->dialogstr.append("add_label_with_icon|big|" + text + "|left|" + to_string(tileid) + "|\n");
		break;
	case LABEL_SMALL:
		this->dialogstr.append("add_label_with_icon|small|" + text + "|left|" + to_string(tileid) + "|\n");
		break;
	default:
		break;
	}
}

void GTDialog::addLabel(string text, int tileid, LabelStyles type) {
	switch (type)
	{
	case LABEL_BIG:
		this->dialogstr.append("add_label|big|" + text + "|left|\n");
		break;
	case LABEL_SMALL:
		this->dialogstr.append("add_label|small|" + text + "|left|\n");
		break;
	default:
		break;
	}
}
void GTDialog::addButton(string buttonname, string buttontext) {
	this->dialogstr.append("add_button|" + buttonname + "|" + buttontext + "|noflags|0|0|\n");
}
void GTDialog::addCheckbox(string checkboxname, string string, CheckboxTypes type) {
	switch (type)
	{
	case CHECKBOX_SELECTED:
		this->dialogstr.append("add_checkbox|" + checkboxname + "|" + string + "|1|\n");
		break;
	case CHECKBOX_NOT_SELECTED:
		this->dialogstr.append("add_checkbox|" + checkboxname + "|" + string + "|0|\n");
		break;
	default:
		break;
	}
}

void GTDialog::addTextBox(string str) {
	this->dialogstr.append("add_textbox|" + str + "|left|\n");
}

void GTDialog::addSmallText(string str) {
	this->dialogstr.append("add_smalltext|" + str + "|\n");
}

void GTDialog::addInputBox(string name, string text, string cont, int size) {
	this->dialogstr.append("add_text_input|" + name + "|" + text + "|" + cont + "|" + to_string(size) + "|\n");
}

void GTDialog::addQuickExit() {
	this->dialogstr.append("add_quick_exit|\n");
}

void GTDialog::endDialog(string name, string accept, string nvm) {
	this->dialogstr.append("end_dialog|" + name + "|" + nvm + "|" + accept + "|\n");
}

void GTDialog::addCustom(string name) {
	this->dialogstr.append(name + "\n");
}

string GTDialog::finishDialog() {
	return this->dialogstr;
}

namespace natives
{
	typedef int16_t             int16;
	typedef int32_t             int32;
	typedef int64_t             int64;

	typedef std::atomic_bool    flag;
}

class ThreadPool
{
public:
	struct BaseTask
	{
		virtual void runTask() = 0;
	};

	template <class T> struct Task : public BaseTask
	{
		Task(T task)
			: m_Task(task)
		{}

		virtual void runTask()
		{
			m_Task();
		}

		T m_Task;
	};

	template <class T, class P1> struct ParameteredTask : public BaseTask
	{
		ParameteredTask(T task, const P1& p1)
			: m_Task(task), m_P1(p1)
		{}

		virtual void runTask()
		{
			m_Task(m_P1);
		}

		T  m_Task;
		P1 m_P1;
	};

	typedef std::queue<BaseTask*>                       TaskQueue;
	typedef std::vector <std::shared_ptr<std::thread> > WorkerGroup;
	typedef std::mutex                                  QueueLock;
	typedef std::unique_lock<std::mutex>                QueueGuard;
	typedef std::condition_variable                     WorkerSignal;

	static void thMain(TaskQueue* queue, QueueLock* qlock, WorkerSignal* signal, natives::flag* online)
	{
		while (*online)
		{
			BaseTask* task = nullptr;

			std::shared_ptr<ThreadPool::QueueGuard> qguard(std::make_shared<ThreadPool::QueueGuard>(*qlock));

			if (!queue->empty())
			{
				task = queue->front();
				queue->pop();

				qguard.reset();
			}
			else if (*online)
			{
				signal->wait(*qguard);
			}

			if (nullptr != task)
			{
				task->runTask();
				delete task;
			}
		}
	}

	ThreadPool(natives::int32 size)
		: m_Online(true)
	{
		for (natives::int32 counter = 0; size > counter; ++counter)
		{
			m_Workers.push_back(std::make_shared<std::thread>(thMain, &m_Queue, &m_QLock, &m_Signal, &m_Online));
		}
	}

	void addThread()
	{
		m_Workers.push_back(std::make_shared<std::thread>(thMain, &m_Queue, &m_QLock, &m_Signal, &m_Online));
	}

	~ThreadPool()
	{
		m_Online = false;

		m_Signal.notify_all();

		std::for_each(m_Workers.begin(), m_Workers.end(), [](std::shared_ptr<std::thread> thread)->void {thread->join(); });
	}

	void enqueue(BaseTask* task)
	{
		QueueGuard guard(m_QLock);
		m_Queue.push(task);

		m_Signal.notify_all();
	}

	template <class T> void enqueue(T task)
	{
		QueueGuard guard(m_QLock);
		m_Queue.push(new Task<T>(task));

		m_Signal.notify_all();
	}

	template <class T, class P1> void enqueue(T task, const P1& p1)
	{
		QueueGuard guard(m_QLock);
		m_Queue.push(new ParameteredTask<T, P1>(task, p1));

		m_Signal.notify_all();
	}

	natives::int32 getQueueSize()
	{
		QueueGuard guard(m_QLock);
		natives::int32 size = m_Queue.size();

		return size;
	}

	WorkerGroup   m_Workers;
	TaskQueue     m_Queue;
	QueueLock     m_QLock;
	WorkerSignal  m_Signal;
	natives::flag m_Online;
};
int maxItems = 9439;
std::mutex m;

string PlayerDB::getProperName(string name) {
	string newS;
	for (char c : name) newS += (c >= 'A' && c <= 'Z') ? c - ('A' - 'a') : c;
	string ret;
	for (int i = 0; i < newS.length(); i++)
	{
		if (newS[i] == '`') i++; else ret += newS[i];
	}
	string ret2;
	for (char c : ret) if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) ret2 += c;
	return ret2;
}
void BlockLoginNoUrl(ENetPeer* peer, string message) {
	string text = "action|log\nmsg|" + message + "\n";
	string text3 = "action|logon_fail\n";

	BYTE* data = new BYTE[5 + text.length()];
	BYTE* data3 = new BYTE[5 + text3.length()];
	BYTE zero = 0;
	int type = 3;
	memcpy(data, &type, 4);
	memcpy(data + 4, text.c_str(), text.length());
	memcpy(data + 4 + text.length(), &zero, 1);

	memcpy(data3, &type, 4);
	memcpy(data3 + 4, text3.c_str(), text3.length());
	memcpy(data3 + 4 + text3.length(), &zero, 1);

	ENetPacket* p = enet_packet_create(data,
		5 + text.length(),
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, p);
	ENetPacket* p2 = enet_packet_create(data3,
		5 + text3.length(),
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, p2);

	delete data;
	delete data3;


}
string PlayerDB::fixColors(string text) {
	string ret = "";
	int colorLevel = 0;
	for (int i = 0; i < text.length(); i++)
	{
		if (text[i] == '`')
		{
			ret += text[i];
			if (i + 1 < text.length())
				ret += text[i + 1];


			if (i + 1 < text.length() && text[i + 1] == '`')
			{
				colorLevel--;
			}
			else {
				colorLevel++;
			}
			i++;
		}
		else {
			ret += text[i];
		}
	}
	for (int i = 0; i < colorLevel; i++) {
		ret += "``";
	}
	for (int i = 0; i > colorLevel; i--) {
		ret += "`w";
	}
	return ret;
}

void toUpperCase(std::string& str)
{
	std::transform(str.begin(), str.end(), str.begin(), ::toupper);
}
long long GetCurrentTimeInternalSeconds()
{
	using namespace std::chrono;
	return (duration_cast<seconds>(system_clock::now().time_since_epoch())).count();
}
long long GetCurrentTimeInternals()
{
	using namespace std::chrono;
	return (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
}
long long GetCurrentTimeInternal()
{
	using namespace std::chrono;
	return (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
}
long long GetCurrentTimeInternalsSeconds()
{
	using namespace std::chrono;
	return (duration_cast<seconds>(system_clock::now().time_since_epoch())).count();
}
string BanDays(int time) {
	string x;
	int day = time / (24 * 3600);
	x.append(to_string(day));
	//n = n % (24 * 3600);
	return x;
}

string BanHours(int time) {
	string x;
	time = time % (24 * 3600);
	int hour = time / 3600;
	x.append(to_string(hour));
	//n = n % (24 * 3600);
	return x;
}
string BanSecs(int n) {
	string x;
	n %= 60;
	int seconds = n;
	x.append(to_string(seconds));
	//n = n % (24 * 3600);
	return x;
}
string BanMinutes(int n) {
	string x;
	n %= 3600;
	int minutes = n / 60;
	x.append(to_string(minutes));
	//n = n % (24 * 3600);
	return x;
}


void sendLogonFail(ENetPeer* peer, string texts)
{
	string text = "action|log\nmsg|" + texts + "\n";
	string text3 = "action|logon_fail\n";
	BYTE* data = new BYTE[5 + text.length()];
	BYTE* data3 = new BYTE[5 + text3.length()];
	BYTE zero = 0;
	int type = 3;
	memcpy(data, &type, 4);
	memcpy(data + 4, text.c_str(), text.length());
	memcpy(data + 4 + text.length(), &zero, 1);
	memcpy(data3, &type, 4);
	memcpy(data3 + 4, text3.c_str(), text3.length());
	memcpy(data3 + 4 + text3.length(), &zero, 1);

	ENetPacket* p = enet_packet_create(data,
		5 + text.length(),
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, p);
	ENetPacket* p2 = enet_packet_create(data3,
		5 + text3.length(),
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, p2);

	delete data;
	delete data3;
}
int getPlayersCountInServer()
{
	int count = 0;
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		count++;
	}
	return count;
}
namespace player {
	void consolemessage(ENetPeer* peer, string message) {
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), message));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}
	void disconnect(ENetPeer* peer) {
		enet_peer_disconnect_later(peer, 0);
	}
	void growmoji(ENetPeer* peer) {
		GamePacket p2ssw = packetEnd(appendString(appendInt(appendString(createPacket(), "OnEmoticonDataChanged"), 20156052028), "(wl)|Ä|1&(yes)|Ä‚|1&(no)|Äƒ|1&(love)|Ä„|1&(oops)|Ä…|1&(shy)|Ä†|1&(wink)|Ä‡|1&(tongue)|Äˆ|1&(agree)|Ä‰|1&(sleep)|ÄŠ|1&(punch)|Ä‹|1&(music)|ÄŒ|1&(build)|Ä|1&(megaphone)|ÄŽ|1&(sigh)|Ä|1&(mad)|Ä|1&(wow)|Ä‘|1&(dance)|Ä’|1&(see-no-evil)|Ä“|1&(bheart)|Ä”|1&(heart)|Ä•|1&(grow)|Ä–|1&(gems)|Ä—|1&(kiss)|Ä˜|1&(gtoken)|Ä™|1&(lol)|Äš|1&(smile)|Ä€|1&(cool)|Äœ|1&(cry)|Ä|1&(vend)|Äž|1&(bunny)|Ä›|1&(cactus)|ÄŸ|1&(pine)|Ä¤|1&(peace)|Ä£|1&(terror)|Ä¡|1&(troll)|Ä¢|1&(evil)|Ä¢|1&(fireworks)|Ä¦|1&(football)|Ä¥|1&(alien)|Ä§|1&(party)|Ä¨|1&(pizza)|Ä©|1&(clap)|Äª|1&(song)|Ä«|1&(ghost)|Ä¬|1&(nuke)|Ä­|1&(halo)|Ä®|1&(turkey)|Ä¯|1&(gift)|Ä°|1&(cake)|Ä±|1&(heartarrow)|Ä²|1&(lucky)|Ä³|1&(shamrock)|Ä´|1&(grin)|Äµ|1&(ill)|Ä¶|1&"));
		ENetPacket* packet2ssw = enet_packet_create(p2ssw.data,
			p2ssw.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet2ssw);
		delete p2ssw.data;
	}
	void dialogDuration(ENetPeer* peer, int duration, string message) {
		gamepacket_t p(duration);
		p.Insert("OnDialogRequest");
		p.Insert(message);
		p.CreatePacket(peer);
	}
}
void wrongpass(ENetPeer* peer) {
	string text = "action|log\nmsg|`o`4Unable to log on: `$That `0GrowID`$ or password doesnt look valid. Please try again!````\n";
	string text3 = "action|logon_fail\n";
	string dc = "https://discord.gg/ybg7TVH";
	string url = "action|set_url\nurl|" + dc + "\nlabel|Recover Password\n";


	BYTE* data = new BYTE[5 + text.length()];
	BYTE* data3 = new BYTE[5 + text3.length()];
	BYTE* dataurl = new BYTE[5 + url.length()];
	BYTE zero = 0;
	int type = 3;
	memcpy(data, &type, 4);
	memcpy(data + 4, text.c_str(), text.length());
	memcpy(data + 4 + text.length(), &zero, 1);

	memcpy(dataurl, &type, 4);
	memcpy(dataurl + 4, url.c_str(), url.length());
	memcpy(dataurl + 4 + url.length(), &zero, 1);

	memcpy(data3, &type, 4);
	memcpy(data3 + 4, text3.c_str(), text3.length());
	memcpy(data3 + 4 + text3.length(), &zero, 1);

	ENetPacket* p = enet_packet_create(data,
		5 + text.length(),
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, p);
	ENetPacket* p3 = enet_packet_create(dataurl,
		5 + url.length(),
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, p3);
	ENetPacket* p2 = enet_packet_create(data3,
		5 + text3.length(),
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, p2);

	delete data;
	delete dataurl;
	delete data3;

	player::disconnect(peer);


}
void SendTalkSelf(ENetPeer* peer, string text)
{
	GamePacket p2 = packetEnd(appendIntx(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), text), 0), 1));

	ENetPacket* packet2 = enet_packet_create(p2.data,
		p2.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet2);
	delete p2.data;
}

void sendConsoleMsg(ENetPeer* peer, string message) {
	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), message));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}

void SendConsoleMsg(ENetPeer* peer, string message) {
	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), message));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}

int calcBanDuration(long long banDuration) {
	int duration = 0;
	duration = banDuration - GetCurrentTimeInternalSeconds();
	return duration;
}
void checkTimeBan(ENetPeer* peer, string username) {
	bool exist = experimental::filesystem::exists("timebanned/" + PlayerDB::getProperName(username) + ".txt");
	if (exist)
	{
		ifstream fd("timebanned/" + PlayerDB::getProperName(username) + ".txt");
		long long banDuration = 0;
		string bannedBy;
		if (fd.fail()) {
			cout << "[Stream-ERROR]: failed to check whether '" + username + "' is time banned." << endl;
			player::consolemessage(peer, "`5[Stream-ERROR]: `@ failed to check whether '" + username + "' is time banned. `5Please send this screenshot to GTOS developers.");
			enet_peer_disconnect_later(peer, 0);
		}
		else
		{
			fd >> banDuration;
			fd >> bannedBy;
			fd.close();
		}
		int bantimeleft = calcBanDuration(banDuration);
		if (bantimeleft < 1) {
			return;
		}
		player::consolemessage(peer, "`4Sorry, this account/location was temporary banned by `w" + bannedBy + "");
		player::consolemessage(peer, "`oThis ban will be removed after `w" + OutputBanTime(calcBanDuration(banDuration)) + "");
		string text3 = "action|logon_fail\n";
		string dc = "https://discord.gg/qtSdMWx";
		string url = "action|set_url\nurl|" + dc + "\nlabel|Join Growtopia Royal Discord\n";
		BYTE* data3 = new BYTE[5 + text3.length()];
		BYTE* dataurl = new BYTE[5 + url.length()];
		BYTE zero = 0;
		int type = 3;
		memcpy(dataurl, &type, 4);
		memcpy(dataurl + 4, url.c_str(), url.length());
		memcpy(dataurl + 4 + url.length(), &zero, 1);
		memcpy(data3, &type, 4);
		memcpy(data3 + 4, text3.c_str(), text3.length());
		memcpy(data3 + 4 + text3.length(), &zero, 1);
		ENetPacket* p3 = enet_packet_create(dataurl,
			5 + url.length(),
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, p3);
		ENetPacket* p2 = enet_packet_create(data3,
			5 + text3.length(),
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, p2);
		enet_peer_disconnect_later(peer, 0);
		delete dataurl;
		delete data3;
	}
}
int PlayerDB::playerLogin(ENetPeer* peer, string username, string password) {
	try {
		bool invsizeist = std::experimental::filesystem::exists("usersinventorysize/" + PlayerDB::getProperName(username) + ".txt");

		string uname = username;
		checkTimeBan(peer, username);
		if (uname.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
			return -99;
		}

		string unames = ((PlayerInfo*)(peer->data))->tankIDName;
		if (unames.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
			return -89;
		}

		if (username.find("oflegend") != string::npos) return -99;
		if (username.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) return -99;


		if (!invsizeist)
		{
			ofstream invof("usersinventorysize/" + PlayerDB::getProperName(username) + ".txt");
			invof << 15;
			invof.close();
		}
		std::ifstream ifs("players/" + PlayerDB::getProperName(username) + ".json");
		if (ifs.is_open()) {
			json j;
			ifs >> j;
			string pss = j["password"];
			int adminLevel = j["adminLevel"];
			if (verifyPassword(password, pss)) {
				((PlayerInfo*)(peer->data))->hasLogon = true;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (currentPeer == peer)
						continue;
					if (((PlayerInfo*)(currentPeer->data))->rawName == PlayerDB::getProperName(username))
					{
						{
							player::consolemessage(currentPeer, "Someone else logged into this account!");
						}
						{
							player::consolemessage(peer, "`4ALREADY ON!? `o: This account was already online, kicking it off so you can log on (If you are playing before, nothing to worry about!)");
						}
						enet_peer_disconnect_later(currentPeer, 0);
					}
				}
				return 1;
			}
			else {
				return -1;
			}
		}
		else {
			return -2;
		}
	}
	catch (...) {
		player::consolemessage(peer, "`oYour account data was corrupted, Please message Baskerville on discord!");
		enet_peer_disconnect_later(peer, 0);
		return -99;
	}
}

bool isHere(ENetPeer* peer, ENetPeer* peer2)
{
	return ((PlayerInfo*)(peer->data))->currentWorld == ((PlayerInfo*)(peer2->data))->currentWorld;
}
bool checkNetIDs(ENetPeer* peer, ENetPeer* peer2)
{
	return ((PlayerInfo*)(peer->data))->netID == ((PlayerInfo*)(peer2->data))->netID;
}

bool checkNetIDs2(ENetPeer* peer, string nid)
{
	return ((PlayerInfo*)(peer->data))->netID == stoi(nid);
}
int PlayerDB::guildRegister(ENetPeer* peer, string guildName, string guildStatement, string guildFlagfg, string guildFlagbg) {
	if (guildName.find(" ") != string::npos || guildName.find(".") != string::npos || guildName.find(",") != string::npos || guildName.find("@") != string::npos || guildName.find("[") != string::npos || guildName.find("]") != string::npos || guildName.find("#") != string::npos || guildName.find("<") != string::npos || guildName.find(">") != string::npos || guildName.find(":") != string::npos || guildName.find("{") != string::npos || guildName.find("}") != string::npos || guildName.find("|") != string::npos || guildName.find("+") != string::npos || guildName.find("_") != string::npos || guildName.find("~") != string::npos || guildName.find("-") != string::npos || guildName.find("!") != string::npos || guildName.find("$") != string::npos || guildName.find("%") != string::npos || guildName.find("^") != string::npos || guildName.find("&") != string::npos || guildName.find("`") != string::npos || guildName.find("*") != string::npos || guildName.find("(") != string::npos || guildName.find(")") != string::npos || guildName.find("=") != string::npos || guildName.find("'") != string::npos || guildName.find(";") != string::npos || guildName.find("/") != string::npos) {
		return -1;
	}

	if (guildName.length() < 3) {
		return -2;
	}
	if (guildName.length() > 15) {
		return -3;
	}
	int fg;
	int bg;

	try {
		fg = stoi(guildFlagfg);
	}
	catch (std::invalid_argument& e) {
		return -6;
	}
	try {
		bg = stoi(guildFlagbg);
	}
	catch (std::invalid_argument& e) {
		return -5;
	}
	if (guildFlagbg.length() > 4) {
		return -7;
	}
	if (guildFlagfg.length() > 4) {
		return -8;
	}

	string fixedguildName = PlayerDB::getProperName(guildName);

	std::ifstream ifs("guilds/" + fixedguildName + ".json");
	if (ifs.is_open()) {
		return -4;
	}


	/*std::ofstream o("guilds/" + fixedguildName + ".json");
	if (!o.is_open()) {
		cout << GetLastError() << endl;
		_getch();
	}

	json j;

	//  Guild Detail
	j["GuildName"] = guildName;
	j["GuildStatement"] = guildStatement;
	j["GuildWorld"] = ((PlayerInfo*)(peer->data))->currentWorld;

	//  Guild Level
	j["GuildLevel"] = 0;
	j["GuildExp"] = 0;

	// Guild Leader
	j["Leader"] = ((PlayerInfo*)(peer->data))->rawName;


	// Guild Flag
	j["foregroundflag"] = 0;
	j["backgroundflag"] = 0;


	// Role
	vector<string>guildmember;
	vector<string>guildelder;
	vector<string>guildco;

	j["CoLeader"] = guildelder;
	j["ElderLeader"] = guildco;
	j["Member"] = guildmem;

	o << j << std::endl; */
	return 1;
}

int PlayerDB::playerRegister(ENetPeer* peer, string username, string password, string passwordverify, string email, string discord) {
	if (username.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
		return -10;
	}

	string name = username;
	totaluserids++;
	if (totaluserids == 1) totaluserids++;
	toUpperCase(name);
	if (name == "CON" || name == "PRN" || name == "AUX" || name == "NUL" || name == "COM1" || name == "COM2" || name == "COM3" || name == "COM4" || name == "COM5" || name == "COM6" || name == "COM7" || name == "COM8" || name == "COM9" || name == "LPT1" || name == "LPT2" || name == "LPT3" || name == "LPT4" || name == "LPT5" || name == "LPT6" || name == "LPT7" || name == "LPT8" || name == "LPT9") return -1;
	if (name == "") return -1;
	username = PlayerDB::getProperName(username);
	if (discord.find("#") == std::string::npos && discord.length() != 0) return -5;
	if (email.find("@") == std::string::npos && email.length() != 0) return -4;
	if (passwordverify != password) return -3;
	if (username.length() < 3) return -2;
	std::ifstream ifs("players/" + username + ".json");
	if (ifs.is_open()) {
		return -1;
	}
	std::ofstream o("players/" + username + ".json");
	if (!o.is_open()) {
		cout << GetLastError() << endl;
		_getch();
	}
	json j;
	j["username"] = username;
	j["password"] = hashPassword(password);
	j["email"] = email;
	j["discord"] = discord;
	j["adminLevel"] = 0;
	j["ClothBack"] = 0;
	j["ClothHand"] = 0;
	j["ClothFace"] = 0;
	j["ClothShirt"] = 0;
	j["ClothPants"] = 0;
	j["ClothNeck"] = 0;
	j["ClothHair"] = 0;
	j["ClothFeet"] = 0;
	j["ClothMask"] = 0;
	j["ClothAnces"] = 0;
	j["skinColor"] = 0xC8E5FFFF;
	j["gems"] = 0;
	j["canDoubleJump"] = false;
	j["isLegend"] = false;
	j["notebook"] = "";
	j["gems"] = 100000;
	j["level"] = 1;
	j["xp"] = 0;
	j["worldsowned"] = ((PlayerInfo*)(peer->data))->createworldsowned;
	o << j << std::endl;
	std::ofstream oo("inventory/" + username + ".json");
	if (!oo.is_open()) {
		cout << GetLastError() << endl;
		_getch();
	}

	json items;
	json jjall = json::array();


	json jj;
	jj["aposition"] = 1;
	jj["itemid"] = 18;
	jj["quantity"] = 1;
	jjall.push_back(jj);


	jj["aposition"] = 2;
	jj["itemid"] = 32;
	jj["quantity"] = 1;
	jjall.push_back(jj);

	jj["aposition"] = 3;
	jj["itemid"] = 6336;
	jj["quantity"] = 1;
	jjall.push_back(jj);

	for (int i = 2; i < 200; i++)
	{
		jj["aposition"] = i + 1;
		jj["itemid"] = 0;
		jj["quantity"] = 0;
		jjall.push_back(jj);
	}

	items["items"] = jjall;
	oo << items << std::endl;
	((PlayerInfo*)(peer->data))->userID = totaluserids;
	ofstream myfile;
	myfile.open("uids.txt");
	myfile << to_string(totaluserids);
	myfile.close();
	((PlayerInfo*)(peer->data))->userID = totaluserids;
	return 1;
}

void report(natives::int32 i)
{
	{
		std::unique_lock<std::mutex> guard(m);
	}

	std::this_thread::sleep_for(std::chrono::seconds(5));
}

struct AWorld {
	WorldInfo* ptr;
	WorldInfo info;
	int id;
};

class WorldDB {
public:
	WorldInfo get(string name);
	int getworldStatus(string name);
	AWorld get2(string name);
	void flush(WorldInfo info);
	void flush2(AWorld info);
	void save(AWorld info);
	void saveAll();
	void saveRedundant();
	vector<WorldInfo> getRandomWorlds();
	WorldDB();
private:
	vector<WorldInfo> worlds;
};
namespace packet {
	void storerequest(ENetPeer* peer, string message) {
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), message));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}
	void OnStorePurchaseResults(ENetPeer* peer, string text)
	{
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), text));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}
	void OnConsoleMessage(ENetPeer* peer, string message) {
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), message));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}
	void OnDialogRequest(ENetPeer* peer, string message) {
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), message));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}
	void dialog(ENetPeer* peer, string message) {
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert(message);
		p.CreatePacket(peer);
	}
}
WorldDB::WorldDB() {
	// Constructor
}
void sendNotification(ENetPeer* peer, string song, string flag, string message) {
	GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), song), message), flag), 0));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}
string getStrUpper(string txt) {
	string ret;
	for (char c : txt) ret += toupper(c);
	return ret;
}

AWorld WorldDB::get2(string name) {
	if (worlds.size() > 200) {
#ifdef TOTAL_LOG
		cout << "[!] Saving redundant worlds!" << endl;
#endif
		saveRedundant();
#ifdef TOTAL_LOG
		cout << "[!] Redundant worlds are saved!" << endl;
#endif
	}
	AWorld ret;
	name = getStrUpper(name);
	if (name.length() < 1) throw 1; // too short name
	for (char c : name) {
		if ((c < 'A' || c>'Z') && (c < '0' || c>'9'))
			throw 2; // wrong name
	}
	if (name == "EXIT") {
		throw 3;
	}
	if (name == "CON" || name == "PRN" || name == "AUX" || name == "NUL" || name == "COM1" || name == "COM2" || name == "COM3" || name == "COM4" || name == "COM5" || name == "COM6" || name == "COM7" || name == "COM8" || name == "COM9" || name == "LPT1" || name == "LPT2" || name == "LPT3" || name == "LPT4" || name == "LPT5" || name == "LPT6" || name == "LPT7" || name == "LPT8" || name == "LPT9") throw 3;
	for (int i = 0; i < worlds.size(); i++) {
		if (worlds.at(i).name == name)
		{
			ret.id = i;
			ret.info = worlds.at(i);
			ret.ptr = &worlds.at(i);
			return ret;
		}

	}
	std::ifstream ifs("worlds/" + name + ".json");
	if (ifs.is_open()) {

		json j;
		ifs >> j;
		WorldInfo info;
		info.name = j["name"].get<string>();
		info.width = j["width"].get<int>();
		info.height = j["height"].get<int>();
		info.weather = j["weather"].get<int>();
		for (int i = 0; i < j["access"].size(); i++) {
			info.acclist.push_back(j["access"][i]);
		}
		info.owner = j["owner"].get<string>();
		info.ownerID = j["ownerID"].get<int>();
		info.magplant = j["magplant"].get<bool>();
		info.maggems = j["maggems"].get<int>();
		info.stuffID = j["stuff"].get<int>();
		info.gravity = j["gravity"].get<int>();
		info.isPublic = j["isPublic"].get<bool>();
		info.droppedCount = j["dc"].get<int>();
		info.gscanpublic = j["gscan"].get<bool>();

		json droppedobjects = j["dropped"];
		for (int i = 0; i < info.droppedCount; i++) {
			DroppedItem di;
			di.count = droppedobjects[i]["c"].get<byte>();
			di.id = droppedobjects[i]["id"].get<short>();
			di.x = droppedobjects[i]["x"].get<int>();
			di.y = droppedobjects[i]["y"].get<int>();
			di.uid = droppedobjects[i]["uid"].get<int>();
			info.droppedItems.push_back(di);
		}

		json tiles = j["tiles"];
		int square = info.width * info.height;
		info.items = new WorldItem[square];
		for (int i = 0; i < square; i++) {
			info.items[i].foreground = tiles[i]["fg"].get<int>();
			info.items[i].background = tiles[i]["bg"].get<int>();
			info.items[i].dshelf1 = tiles[i]["d1"].get<int>();
			info.items[i].dshelf2 = tiles[i]["d2"].get<int>();
			info.items[i].dshelf3 = tiles[i]["d3"].get<int>();
			info.items[i].dshelf4 = tiles[i]["d4"].get<int>();
			info.items[i].text = tiles[i]["text"].get<string>();
			info.items[i].label = tiles[i]["label"].get<string>();
			info.items[i].destWorld = tiles[i]["destWorld"].get<string>();
			info.items[i].destId = tiles[i]["destId"].get<string>();
			info.items[i].currId = tiles[i]["currId"].get<string>();
			info.items[i].password = tiles[i]["password"].get<string>();
			info.items[i].flipped = tiles[i]["flip"].get<bool>();
			info.items[i].active = tiles[i]["a"].get<bool>();
			info.items[i].intdata = tiles[i]["intdata"].get<int>();
			info.items[i].display = tiles[i]["display"].get<int>();
			info.items[i].sign = tiles[i]["s"].get<string>();
			info.items[i].activated = tiles[i]["activated"].get<bool>();
			info.items[i].fire = tiles[i]["fire"].get<bool>();
			info.items[i].water = tiles[i]["water"].get<bool>();
			info.items[i].green = tiles[i]["green"].get<bool>();
			info.items[i].blue = tiles[i]["blue"].get<bool>();
			info.items[i].red = tiles[i]["red"].get<bool>();
			info.items[i].glue = tiles[i]["glue"].get<bool>();
			info.items[i].flipped = tiles[i]["r"].get<bool>();
			info.items[i].magcollect = tiles[i]["magcollect"].get<bool>();
			info.items[i].magcount = tiles[i]["magcount"].get<int>();
			info.items[i].magitem = tiles[i]["magitem"].get<int>();
			info.items[i].clothBack = tiles[i]["back"].get<int>();
			info.items[i].clothMask = tiles[i]["mask"].get<int>();
			info.items[i].clothShirt = tiles[i]["shirt"].get<int>();
			info.items[i].clothFeet = tiles[i]["feet"].get<int>();
			info.items[i].clothHair = tiles[i]["hair"].get<int>();
			info.items[i].clothNeck = tiles[i]["neck"].get<int>();
			info.items[i].clothHand = tiles[i]["hand"].get<int>();
			info.items[i].clothHead = tiles[i]["head"].get<int>();
			info.items[i].clothPants = tiles[i]["pants"].get<int>();
			info.items[i].donate1 = tiles[i]["d1"].get<int>();
			info.items[i].donate2 = tiles[i]["d2"].get<int>();
			info.items[i].donate3 = tiles[i]["d3"].get<int>();
			info.items[i].donate4 = tiles[i]["d4"].get<int>();
			info.items[i].donate5 = tiles[i]["d5"].get<int>();
			info.items[i].donate6 = tiles[i]["d6"].get<int>();
			info.items[i].donate7 = tiles[i]["d7"].get<int>();
			info.items[i].donate8 = tiles[i]["d8"].get<int>();
			info.items[i].donate9 = tiles[i]["d9"].get<int>();
			info.items[i].donate10 = tiles[i]["d10"].get<int>();
			info.items[i].cdonate1 = tiles[i]["cd1"].get<int>();
			info.items[i].cdonate2 = tiles[i]["cd2"].get<int>();
			info.items[i].cdonate3 = tiles[i]["cd3"].get<int>();
			info.items[i].cdonate4 = tiles[i]["cd4"].get<int>();
			info.items[i].cdonate5 = tiles[i]["cd5"].get<int>();
			info.items[i].cdonate6 = tiles[i]["cd6"].get<int>();
			info.items[i].cdonate7 = tiles[i]["cd7"].get<int>();
			info.items[i].cdonate8 = tiles[i]["cd8"].get<int>();
			info.items[i].cdonate9 = tiles[i]["cd9"].get<int>();
			info.items[i].cdonate10 = tiles[i]["cd10"].get<int>();
			info.items[i].mdonate1 = tiles[i]["m1"].get<string>();
			info.items[i].mdonate2 = tiles[i]["m2"].get<string>();
			info.items[i].mdonate3 = tiles[i]["m3"].get<string>();
			info.items[i].mdonate4 = tiles[i]["m4"].get<string>();
			info.items[i].mdonate5 = tiles[i]["m5"].get<string>();
			info.items[i].mdonate6 = tiles[i]["m6"].get<string>();
			info.items[i].mdonate7 = tiles[i]["m7"].get<string>();
			info.items[i].mdonate8 = tiles[i]["m8"].get<string>();
			info.items[i].mdonate9 = tiles[i]["m9"].get<string>();
			info.items[i].mdonate10 = tiles[i]["m10"].get<string>();
			info.items[i].isopen = tiles[i]["upen"].get<bool>();
			info.items[i].counts1 = tiles[i]["cc"].get<int>();
		}
		worlds.push_back(info);
		ret.id = worlds.size() - 1;
		ret.info = info;
		ret.ptr = &worlds.at(worlds.size() - 1);
		return ret;
	}
	else {
		WorldInfo info = generateWorld(name, 100, 60);

		worlds.push_back(info);
		ret.id = worlds.size() - 1;
		ret.info = info;
		ret.ptr = &worlds.at(worlds.size() - 1);
		return ret;
	}
	throw 1;
}

WorldInfo WorldDB::get(string name) {

	return this->get2(name).info;
}
int WorldDB::getworldStatus(string name) {
	name = getStrUpper(name);
	//if (name == "CON" || name == "PRN" || name == "AUX" || name == "NUL" || name == "COM1" || name == "COM2" || name == "COM3" || name == "COM4" || name == "COM5" || name == "COM6" || name == "COM7" || name == "COM8" || name == "COM9" || name == "LPT1" || name == "LPT2" || name == "LPT3" || name == "LPT4" || name == "LPT5" || name == "LPT6" || name == "LPT7" || name == "LPT8" || name == "LPT9") return -1;

	//if (name.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) return -1;
	if (name.length() > 24) return -1;
	/*for (int i = 0; i < worlds.size(); i++) {
		if (worlds.at(i).name == name)
		{
			return 0;
		}
	}*/
	return 0;
}

void WorldDB::flush(WorldInfo info)
{
	std::ofstream o("worlds/" + info.name + ".json");
	if (!o.is_open()) {
		cout << GetLastError() << endl;
	}
	json j;
	j["name"] = info.name;
	j["width"] = info.width;
	j["height"] = info.height;
	j["weather"] = info.weather;
	j["isCasino"] = info.isCasino;
	j["access"] = info.acclist;
	j["owner"] = info.owner;
	j["ownerID"] = info.ownerID;
	j["magplant"] = info.magplant;
	j["maggems"] = info.maggems;
	j["stuff"] = info.stuffID;
	j["gravity"] = info.gravity;
	j["isPublic"] = info.isPublic;
	j["gscan"] = info.gscanpublic;
	j["dc"] = info.droppedItems.size();

	json tiles = json::array();
	json droppedarr = json::array();
	int square = info.width * info.height;

	for (int i = 0; i < info.droppedItems.size(); i++)
	{
		json droppedJ;
		droppedJ["c"] = (byte)info.droppedItems[i].count;
		droppedJ["id"] = (short)info.droppedItems[i].id;
		droppedJ["x"] = info.droppedItems[i].x;
		droppedJ["y"] = info.droppedItems[i].y;
		droppedJ["uid"] = info.droppedItems[i].uid;
		droppedarr.push_back(droppedJ);
	}
	j["dropped"] = droppedarr;


	for (int i = 0; i < square; i++)
	{
		json tile;
		tile["fg"] = info.items[i].foreground;
		tile["bg"] = info.items[i].background;
		tile["text"] = info.items[i].text;
		tile["label"] = info.items[i].label;
		tile["destWorld"] = info.items[i].destWorld;
		tile["destId"] = info.items[i].destId;
		tile["currId"] = info.items[i].currId;
		tile["password"] = info.items[i].password;
		tile["a"] = info.items[i].active;
		tile["flip"] = info.items[i].flipped;
		tile["intdata"] = info.items[i].intdata;
		tile["display"] = info.items[i].display;
		tile["s"] = info.items[i].sign;
		tile["activated"] = info.items[i].activated;
		tile["fire"] = info.items[i].fire;
		tile["water"] = info.items[i].water;
		tile["green"] = info.items[i].green;
		tile["blue"] = info.items[i].blue;
		tile["red"] = info.items[i].red;
		tile["glue"] = info.items[i].glue;
		tile["r"] = info.items[i].flipped;
		tile["d1"] = info.items[i].dshelf1;
		tile["d2"] = info.items[i].dshelf2;
		tile["d3"] = info.items[i].dshelf3;
		tile["d4"] = info.items[i].dshelf4;
		tile["magcount"] = info.items[i].magcount;
		tile["magcollect"] = info.items[i].magcollect;
		tile["magitem"] = info.items[i].magitem;
		tile["back"] = info.items[i].clothBack;
		tile["mask"] = info.items[i].clothMask;
		tile["shirt"] = info.items[i].clothShirt;
		tile["feet"] = info.items[i].clothFeet;
		tile["hair"] = info.items[i].clothHair;
		tile["neck"] = info.items[i].clothNeck;
		tile["hand"] = info.items[i].clothHand;
		tile["head"] = info.items[i].clothHead;
		tile["pants"] = info.items[i].clothPants;
		tile["upen"] = info.items[i].isopen;
		tile["d1"] = info.items[i].donate1;
		tile["d2"] = info.items[i].donate2;
		tile["d3"] = info.items[i].donate3;
		tile["d4"] = info.items[i].donate4;
		tile["d5"] = info.items[i].donate5;
		tile["d6"] = info.items[i].donate6;
		tile["d7"] = info.items[i].donate7;
		tile["d8"] = info.items[i].donate8;
		tile["d9"] = info.items[i].donate9;
		tile["d10"] = info.items[i].donate10;
		tile["cd1"] = info.items[i].cdonate1;
		tile["cd2"] = info.items[i].cdonate2;
		tile["cd3"] = info.items[i].cdonate3;
		tile["cd4"] = info.items[i].cdonate4;
		tile["cd5"] = info.items[i].cdonate5;
		tile["cd6"] = info.items[i].cdonate6;
		tile["cd7"] = info.items[i].cdonate7;
		tile["cd8"] = info.items[i].cdonate8;
		tile["cd9"] = info.items[i].cdonate9;
		tile["cd10"] = info.items[i].cdonate10;
		tile["m1"] = info.items[i].mdonate1;
		tile["m2"] = info.items[i].mdonate2;
		tile["m3"] = info.items[i].mdonate3;
		tile["m4"] = info.items[i].mdonate4;
		tile["m5"] = info.items[i].mdonate5;
		tile["m6"] = info.items[i].mdonate6;
		tile["m7"] = info.items[i].mdonate7;
		tile["m8"] = info.items[i].mdonate8;
		tile["m9"] = info.items[i].mdonate9;
		tile["m10"] = info.items[i].mdonate10;
		tile["cc"] = info.items[i].counts1;
		tiles.push_back(tile);
	}
	j["tiles"] = tiles;
	o << j << std::endl;
}

void WorldDB::flush2(AWorld info)
{
	this->flush(info.info);
}

void WorldDB::save(AWorld info)
{
	flush2(info);
	delete info.info.items;
	worlds.erase(worlds.begin() + info.id);
}

void WorldDB::saveAll()
{
	for (int i = 0; i < worlds.size(); i++) {
		flush(worlds.at(i));
	}
	worlds.clear();
}

vector<WorldInfo> WorldDB::getRandomWorlds() {
	vector<WorldInfo> ret;
	for (int i = 0; i < ((worlds.size() < 10) ? worlds.size() : 10); i++)
	{ // load first four worlds, it is excepted that they are special
		ret.push_back(worlds.at(i));
	}
	// and lets get up to 6 random
	if (worlds.size() > 4) {
		for (int j = 0; j < 6; j++)
		{
			bool isPossible = true;
			WorldInfo world = worlds.at(rand() % (worlds.size() - 4));
			for (int i = 0; i < ret.size(); i++)
			{
				if (world.name == ret.at(i).name || world.name == "EXIT")
				{
					isPossible = false;
				}
			}
			if (isPossible)
				ret.push_back(world);
		}
	}
	return ret;
}

void WorldDB::saveRedundant()
{
	for (int i = 4; i < worlds.size(); i++) {
		bool canBeFree = true;
		ENetPeer* currentPeer;

		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (((PlayerInfo*)(currentPeer->data))->currentWorld == worlds.at(i).name)
				canBeFree = false;
		}
		if (canBeFree)
		{
			flush(worlds.at(i));
			delete worlds.at(i).items;
			worlds.erase(worlds.begin() + i);
			i--;
		}
	}
}

//WorldInfo world;
//vector<WorldInfo> worlds;
WorldDB worldDB;

void saveAllWorlds() // atexit hack plz fix
{
	cout << "[!] Saving worlds..." << endl;
	worldDB.saveAll();
	cout << "[!] Worlds saved!" << endl;
}

WorldInfo* getPlyersWorld(ENetPeer* peer)
{
	try {
		return worldDB.get2(((PlayerInfo*)(peer->data))->currentWorld).ptr;
	}
	catch (int e) {
		return NULL;
	}
}
struct PlayerMoving {
	int packetType;
	int netID;
	float x;
	float y;
	int characterState;
	int plantingTree;
	float XSpeed;
	float YSpeed;
	int punchX;
	int punchY;
	int secondnetID;
};

struct BlockVisual {
	int packetType;
	int characterState;
	int punchX;
	int punchY;
	float x;
	float y;
	int plantingTree;
	float XSpeed;
	float YSpeed;
	int charStat;
	int blockid;
	int visual;
	int signs;
	int backgroundid;
	int displayblock;
	int time;
	int netID;
	//int bpm;
};


enum ClothTypes {
	HAIR,
	SHIRT,
	PANTS,
	FEET,
	FACE,
	HAND,
	BACK,
	MASK,
	NECKLACE,
	NONE
};

enum BlockTypes {
	FOREGROUND,
	BACKGROUND,
	CONSUMABLE,
	SEED,
	PAIN_BLOCK,
	BEDROCK,
	MAIN_DOOR,
	SIGN,
	DOOR,
	CLOTHING,
	FIST,
	WRENCH,
	CHECKPOINT,
	LOCK,
	GATEWAY,
	TREASURE,
	WEATHER,
	TRAMPOLINE,
	TOGGLE_FOREGROUND,
	SWITCH_BLOCK,
	SFX_FOREGROUND,
	RANDOM_BLOCK,
	PORTAL,
	PLATFORM,
	MAILBOX,
	MAGIC_EGG,
	GEMS,
	DEADLY,
	CHEST,
	FACTION,
	BULLETIN_BOARD,
	BOUNCY,
	ANIM_FOREGROUND,
	COMPONENT,
	UNKNOWN
};
struct ItemDefinition {
	int id;
	string name;
	int rarity;
	vector<int>gem;
	int breakHits;
	int growTime;
	ClothTypes clothType;
	BlockTypes blockType;
	string MultiFacing = "retarddddddd";
	string description = "This item has no description.";
	string effect = "(Mod removed)";
	string effects = "(Mod added)";
	bool puncheffectEXIST = false;
	int puncheffect;
	bool buffEXIST = false;
	string buff = "This item has no buff.";
	string equip = "This item has no equip message.";
	string unequip = "This item has no unequip message.";
	int properties;
};

struct PunchDefinition {
	int id;
	int pid;
};

vector<ItemDefinition> itemDefs;
vector<PunchDefinition> punchDefs;
ItemDefinition GetItemDef(int id)
{
	if (id < itemDefs.size() && id > -1)
		return itemDefs.at(id);
	return itemDefs.at(0);
}
ItemDefinition getItemDef(int id)
{
	if (id < itemDefs.size() && id > -1)
		return itemDefs.at(id);
	/*for (int i = 0; i < itemDefs.size(); i++)
	{
		if (id == itemDefs.at(i).id)
		{
			return itemDefs.at(i);
		}
	}*/
	throw 0;
	return itemDefs.at(0);
}

namespace MarketDB {
	void MarketOffers(ENetPeer* peer) {
		if (((PlayerInfo*)(peer->data))->haveGrowId == true)
		{
			// offers:
			string muser = ((PlayerInfo*)(peer->data))->muser;
			int itemcount = ((PlayerInfo*)(peer->data))->marketcount;
			int itemid = ((PlayerInfo*)(peer->data))->marketid;
			int mprice = ((PlayerInfo*)(peer->data))->marketprice;
			string moffer;
			moffer += "add_label_with_icon_button|small|`oPlayer: `2" + muser + " `oIs selling `2" + std::to_string(itemcount) + " " + getItemDef(itemid).name + " `oFor `5" + std::to_string(mprice) + " `oWorld Locks.|left|" + std::to_string(itemid) + "|";

			packet::OnDialogRequest(peer, "add_label_with_icon|big|`wWelcome to the Public-Market|left|242|\nadd_spacer|small|\nadd_textbox|`oWelcome, `w" + ((PlayerInfo*)(peer->data))->rawName + "`o To the public-market, here you can purchase items from other people!|\nadd_spacer|small|" + moffer + "\nadd_spacer|small|\nadd_textbox|`oEnter the player's name you'd like to purchase their item from!|\nadd_text_input|puser|||30|\nend_dialog|buymarket|Cancel|`wOK|\n");
		}
		else {
			packet::OnConsoleMessage(peer, "`o>> You must be `2registered `oto access the `4market`o!");
		}
	}
}
PunchDefinition getPunchDef(int id)
{
	if (id < punchDefs.size() && id > -1)
		return punchDefs.at(id);
	/*for (int i = 0; i < itemDefs.size(); i++)
	{
		if (id == itemDefs.at(i).id)
		{
			return itemDefs.at(i);
		}
	}*/
	throw 0;
	return punchDefs.at(0);
}

void craftItemDescriptions() {
	int current = -1;
	std::ifstream infile("Descriptions.txt");
	for (std::string line; getline(infile, line);)
	{
		if (line.length() > 3 && line[0] != '/' && line[1] != '/')
		{
			vector<string> ex = explode("|", line);
			ItemDefinition def;
			if (atoi(ex[0].c_str()) + 1 < itemDefs.size())
			{
				itemDefs.at(atoi(ex[0].c_str())).description = ex[1];
				if (!(atoi(ex[0].c_str()) % 2))
					itemDefs.at(atoi(ex[0].c_str()) + 1).description = "This is a tree.";
			}
		}
	}
}
void craftItemText() {
	int current = -1;
	std::ifstream infile("effect.txt");
	for (std::string line; getline(infile, line);)
	{
		if (line.length() > 5 && line[0] != '/' && line[1] != '/')
		{
			vector<string> ex = explode("|", line);
			ItemDefinition def;
			itemDefs.at(atoi(ex[0].c_str())).effect = ex[3] + " `$(`o" + ex[1] + " `omod removed)";
			itemDefs.at(atoi(ex[0].c_str())).effects = ex[2] + " `$(`o" + ex[1] + " `omod added)";
		}
	}
}
void loadPunchEffect()
{
	int current = -1;
	std::ifstream infile("PunchEffect.txt");
	for (std::string line; getline(infile, line);)
	{
		if (line.length() > 3 && line[0] != '/' && line[1] != '/')
		{
			vector<string> ex = explode("|", line);
			ItemDefinition def;
			itemDefs.at(atoi(ex[0].c_str())).puncheffectEXIST = true;
			itemDefs.at(atoi(ex[0].c_str())).puncheffect = atoi(ex[1].c_str());
		}
	}
}

void BuildItemsDatabase()
{
	int current = -1;
	std::ifstream infile("CoreData.txt");
	for (std::string line; getline(infile, line);)
	{
		if (line.length() > 8 && line[0] != '/' && line[1] != '/')
		{
			vector<string> ex = explode("|", line);
			ItemDefinition def;
			def.id = atoi(ex[0].c_str());
			def.name = ex[1];
			def.rarity = atoi(ex[2].c_str());
			vector<string> properties = explode(",", ex[3]);
			def.properties = Property_Zero;
			for (auto& prop : properties)
			{
				if (prop == "NoSeed")
					def.properties |= Property_NoSeed;
				if (prop == "Dropless")
					def.properties |= Property_Dropless;
				if (prop == "Beta")
					def.properties |= Property_Beta;
				if (prop == "Mod")
					def.properties |= Property_Mod;
				if (prop == "Untradable")
					def.properties |= Property_Untradable;
				if (prop == "Wrenchable")
					def.properties |= Property_Wrenchable;
				if (prop == "MultiFacing")
					def.properties |= Property_MultiFacing;
				if (prop == "Permanent")
					def.properties |= Property_Permanent;
				if (prop == "AutoPickup")
					def.properties |= Property_AutoPickup;
				if (prop == "WorldLock")
					def.properties |= Property_WorldLock;
				if (prop == "NoSelf")
					def.properties |= Property_NoSelf;
				if (prop == "RandomGrow")
					def.properties |= Property_RandomGrow;
				if (prop == "Public")
					def.properties |= Property_Public;
			}
			string bt = ex[4];
			if (bt == "Foreground_Block") {
				def.blockType = BlockTypes::FOREGROUND;
			}
			else if (bt == "Seed") {
				def.blockType = BlockTypes::SEED;
			}
			else if (bt == "Consummable") {
				def.blockType = BlockTypes::CONSUMABLE;
			}
			else if (bt == "Pain_Block") {
				def.blockType = BlockTypes::PAIN_BLOCK;
			}
			else if (bt == "Main_Door") {
				def.blockType = BlockTypes::MAIN_DOOR;
			}
			else if (bt == "Bedrock") {
				def.blockType = BlockTypes::BEDROCK;
			}
			else if (bt == "Door") {
				def.blockType = BlockTypes::DOOR;
			}
			else if (bt == "Fist") {
				def.blockType = BlockTypes::FIST;
			}
			else if (bt == "Sign") {
				def.blockType = BlockTypes::SIGN;
			}
			else if (bt == "Background_Block") {
				def.blockType = BlockTypes::BACKGROUND;
			}
			else if (bt == "Sheet_Music") {
				def.blockType = BlockTypes::BACKGROUND;
			}
			else if (bt == "Wrench") {
				def.blockType = BlockTypes::WRENCH;
			}
			else if (bt == "Checkpoint") {
				def.blockType = BlockTypes::CHECKPOINT;
			}
			else if (bt == "Lock") {
				def.blockType = BlockTypes::LOCK;
			}
			else if (bt == "Gateway") {
				def.blockType = BlockTypes::GATEWAY;
			}
			else if (bt == "Clothing") {
				def.blockType = BlockTypes::CLOTHING;
			}
			else if (bt == "Platform") {
				def.blockType = BlockTypes::PLATFORM;
			}
			else if (bt == "SFX_Foreground") {
				def.blockType = BlockTypes::SFX_FOREGROUND;
			}
			else if (bt == "Gems") {
				def.blockType = BlockTypes::GEMS;
			}
			else if (bt == "Toggleable_Foreground") {
				def.blockType = BlockTypes::TOGGLE_FOREGROUND;
			}
			else if (bt == "Treasure") {
				def.blockType = BlockTypes::TREASURE;
			}
			else if (bt == "Deadly_Block") {
				def.blockType = BlockTypes::DEADLY;
			}
			else if (bt == "Trampoline_Block") {
				def.blockType = BlockTypes::TRAMPOLINE;
			}
			else if (bt == "Animated_Foreground_Block") {
				def.blockType = BlockTypes::ANIM_FOREGROUND;
			}
			else if (bt == "Portal") {
				def.blockType = BlockTypes::PORTAL;
			}
			else if (bt == "Random_Block") {
				def.blockType = BlockTypes::RANDOM_BLOCK;
			}
			else if (bt == "Bouncy") {
				def.blockType = BlockTypes::BOUNCY;
			}
			else if (bt == "Chest") {
				def.blockType = BlockTypes::CHEST;
			}
			else if (bt == "Switch_Block") {
				def.blockType = BlockTypes::SWITCH_BLOCK;
			}
			else if (bt == "Magic_Egg") {
				def.blockType = BlockTypes::MAGIC_EGG;
			}
			else if (bt == "Mailbox") {
				def.blockType = BlockTypes::MAILBOX;
			}
			else if (bt == "Bulletin_Board") {
				def.blockType = BlockTypes::BULLETIN_BOARD;
			}
			else if (bt == "Faction") {
				def.blockType = BlockTypes::FACTION;
			}
			else if (bt == "Component") {
				def.blockType = BlockTypes::COMPONENT;
			}
			else if (bt == "Weather_Machine") {
				def.blockType = BlockTypes::WEATHER;
			}
			else {
				//cout << "[!] Unknown property for ID: " << def.id << " which wants property " << bt << endl;
				def.blockType = BlockTypes::UNKNOWN;
			}
			def.breakHits = atoi(ex[7].c_str());
			def.growTime = atoi(ex[8].c_str());
			string cl = ex[9];
			if (def.blockType == BlockTypes::CLOTHING)
			{
				if (cl == "None") {
					def.clothType = ClothTypes::NONE;
				}
				else if (cl == "Hat") {
					def.clothType = ClothTypes::HAIR;
				}
				else if (cl == "Shirt") {
					def.clothType = ClothTypes::SHIRT;
				}
				else if (cl == "Pants") {
					def.clothType = ClothTypes::PANTS;
				}
				else if (cl == "Feet") {
					def.clothType = ClothTypes::FEET;
				}
				else if (cl == "Face") {
					def.clothType = ClothTypes::FACE;
				}
				else if (cl == "Hand") {
					def.clothType = ClothTypes::HAND;
				}
				else if (cl == "Back") {
					def.clothType = ClothTypes::BACK;
				}
				else if (cl == "Hair") {
					def.clothType = ClothTypes::MASK;
				}
				else if (cl == "Chest") {
					def.clothType = ClothTypes::NECKLACE;
				}
				else {
					def.clothType = ClothTypes::NONE;
				}
			}
			else
			{
				def.clothType = ClothTypes::NONE;
			}

			if (++current != def.id)
			{
				cout << "[!] Critical error! Unordered database at item " << std::to_string(current) << "/" << std::to_string(def.id) << "!" << endl;
			}
			maxItems = def.id;
			itemDefs.push_back(def);
		}
	}
	craftItemDescriptions();
	craftItemText();
}


struct Admin {
	string username;
	string password;
	int level = 0;
	long long int lastSB = 0;
	long long int lastBC = 0;
};

vector<Admin> admins;

void addAdmin(string username, string password, int level)
{
	Admin admin;
	admin.username = username;
	admin.password = password;
	admin.level = level;
	admins.push_back(admin);
}

int getAdminLevel(string username, string password) {
	for (int i = 0; i < admins.size(); i++) {
		Admin admin = admins[i];
		if (admin.username == username && admin.password == password) {
			return admin.level;
		}
	}
	return 0;
}

bool canSB(string username, string password) {
	for (int i = 0; i < admins.size(); i++) {
		Admin admin = admins[i];
		if (admin.username == username && admin.password == password && admin.level > 1) {
			using namespace std::chrono;
			if (admin.lastSB + 900000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count() || admin.level == 999)
			{
				admins[i].lastSB = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				return true;
			}
			else {
				return false;
			}
		}
	}
	return false;
}

bool canClear(string username, string password) {
	for (int i = 0; i < admins.size(); i++) {
		Admin admin = admins[i];
		if (admin.username == username && admin.password == password) {
			return admin.level > 0;
		}
	}
	return false;
}
int adminlevel(string name) {
	std::ifstream ifff("players/" + PlayerDB::getProperName(name) + ".json");
	json j;
	ifff >> j;

	int adminlevel;
	adminlevel = j["adminLevel"];

	ifff.close();
	if (adminlevel == 0) {
		return 0;
	}
	else {
		return adminlevel;
	}

}
int level(string name) {
	std::ifstream ifff("players/" + PlayerDB::getProperName(name) + ".json");
	json j;
	ifff >> j;

	int level;
	level = j["level"];

	ifff.close();
	return level;

}

string getRankText(string name) {
	int lvl = 0;
	lvl = adminlevel(name);
	if (lvl == 0) {
		return "`wTHE FALLEN";
	}
	if (lvl == 111) {
		return "`$THE RECLUSE";
	}
	else if (lvl == 444) {
		return "`#THE AMBITIOUS";
	}
	else if (lvl == 666) {
		return "`4Administrator";
	}
	else if (lvl == 777) {
		return "`4THE ROYAL GUARD";
	}
	else if (lvl == 999) {
		return "`4Server-Creator";
	}
	else if (lvl == 1337) {
		return "`cTHE JUDGE";
	}
}
string getRankId(string name) {
	int lvl = 0;
	lvl = adminlevel(name);
	if (lvl == 0) {
		return "18";
	}
	if (lvl == 111) {
		return "274";
	}
	else if (lvl == 444) {
		return "278";
	}
	else if (lvl == 666) {
		return "276";
	}
	else if (lvl == 777) {
		return "732";
	}
	else if (lvl == 999) {
		return "1956";
	}
	else if (lvl == 1337) {
		return "2376";
	}
}
string getRankTexts(string name) {
	int lvl = 0;
	lvl = level(name);
	if (lvl <= 10) {
		return "`2Newbie";
	}
	if (lvl >= 11) {
		return "`1Advance";
	}
	if (lvl >= 50) {
		return "`cPro";
	}
	if (lvl >= 100) {
		return "`eMaster";
	}
	if (lvl >= 150) {
		return "`9Expert";
	}
	if (lvl >= 200) {
		return "`5A`4C`qE";
	}
}
string getRankIds(string name) {
	int lvl = 0;
	lvl = level(name);
	if (lvl <= 10) {
		return "3900";
	}
	if (lvl >= 11) {
		return "3192";
	}
	if (lvl >= 50) {
		return "7832";
	}
	if (lvl >= 100) {
		return "7586";
	}
	if (lvl >= 150) {
		return "6312";
	}
	if (lvl >= 200) {
		return "1956";
	}
}
bool isSuperAdmin(string username, string password) {
	for (int i = 0; i < admins.size(); i++) {
		Admin admin = admins[i];
		if (admin.username == username && admin.password == password && admin.level == 999) {
			return true;
		}
	}
	return false;
}
bool isMail(int id)
{
	if (id == 656 || id == 1006) {
		return true;
	}
	else {
		return false;
	}
	return false;
}
int GetPlayerCountServer()
{
	int count = 0;
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		count++;
	}
	return count;
}
bool CheckItemMaxed(ENetPeer* peer, int fItemId, int fQuantityAdd)
{
	bool isMaxed = false;
	for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
	{
		if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == fItemId && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount + fQuantityAdd > 200) {
			isMaxed = true;
			break;
		}
	}
	return isMaxed;
}

bool CheckItemExists(ENetPeer* peer, int fItemId)
{
	bool isExists = false;
	for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
	{
		if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == fItemId) {
			isExists = true;
			break;
		}
	}
	return isExists;
}


void sendInventory(ENetPeer* peer, PlayerInventory inventory)
{
	string asdf2 = "0400000009A7379237BB2509E8E0EC04F8720B050000000000000000FBBB0000010000007D920100FDFDFDFD04000000040000000000000000000000000000000000";
	int inventoryLen = inventory.items.size();
	int packetLen = (asdf2.length() / 2) + (inventoryLen * 4) + 4;
	BYTE* data2 = new BYTE[packetLen];
	for (int i = 0; i < asdf2.length(); i += 2)
	{
		char x = ch2n(asdf2[i]);
		x = x << 4;
		x += ch2n(asdf2[i + 1]);
		memcpy(data2 + (i / 2), &x, 1);
	}
	int endianInvVal = _byteswap_ulong(inventoryLen);
	memcpy(data2 + (asdf2.length() / 2) - 4, &endianInvVal, 4);
	endianInvVal = _byteswap_ulong(((PlayerInfo*)(peer->data))->currentInventorySize);
	memcpy(data2 + (asdf2.length() / 2) - 8, &endianInvVal, 4);
	int val = 0;
	for (int i = 0; i < inventoryLen; i++)
	{
		val = 0;
		val |= inventory.items.at(i).itemID;
		val |= inventory.items.at(i).itemCount << 16;
		val &= 0x00FFFFFF;
		val |= 0x00 << 24;
		memcpy(data2 + (i * 4) + (asdf2.length() / 2), &val, 4);
	}
	ENetPacket* packet3 = enet_packet_create(data2,
		packetLen,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet3);
	delete data2;
	//enet_host_flush(server);
}

void LoadInventory(ENetPeer* peer)
{
	try {
		std::ifstream ifff("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");

		if (ifff.fail()) {
			ifff.close();


		}
		if (ifff.is_open()) {


		}
		json j;
		ifff >> j; //load

		if (j["items"][0]["itemid"] != 18 || j["items"][1]["itemid"] != 32)
		{
			j["items"][0]["itemid"] = 18;
			j["items"][1]["itemid"] = 32;

			j["items"][0]["quantity"] = 1;
			j["items"][1]["quantity"] = 1;

			std::ofstream oo("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
			if (!oo.is_open()) {
				cout << GetLastError() << endl;
				_getch();
			}
			oo << j << std::endl;
		}

		PlayerInventory inventory;
		{
			InventoryItem item;

			for (int i = 0; i < ((PlayerInfo*)(peer->data))->currentInventorySize; i++)
			{
				int itemid = j["items"][i]["itemid"];
				int quantity = j["items"][i]["quantity"];
				if (itemid != 0 && quantity != 0)
				{
					item.itemCount = quantity;
					item.itemID = itemid;
					inventory.items.push_back(item);
					sendInventory(peer, inventory);
				}

			}
		}
		((PlayerInfo*)(peer->data))->inventory = inventory;
	}
	catch (...) {
		player::consolemessage(peer, "It appears that this account inventory is corrupted!");
		player::disconnect(peer);
	}
}
void claim(ENetPeer* peer)
{
	std::ifstream ifff("claim/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
	int gems = 0;
	int level = 0;
	int wls = 0;
	int cgems = 0;
	int clevel = 0;
	int cwls = 0;
	int tgems = 0;
	int tlevel = 0;
	int twls = 0;

	if (ifff.fail()) {
		ifff.close();


	}
	if (ifff.is_open()) {
	}
	json j;
	ifff >> j; //load

	gems = j["gems"];
	level = j["level"];


	std::ifstream ifsz("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
	std::string content((std::istreambuf_iterator<char>(ifsz)),
		(std::istreambuf_iterator<char>()));

	int b = atoi(content.c_str());

	std::ifstream iff("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
	if (iff.fail()) {
		iff.close();


	}
	if (iff.is_open()) {
	}
	json x;
	iff >> x; //load

	cgems = b;
	clevel = x["level"];

	((PlayerInfo*)(peer->data))->gem = gems + cgems;
	tlevel = level + clevel;
	twls = wls + cwls;


	ofstream myfile2;
	GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
	ENetPacket* packetpp = enet_packet_create(pp.data,
		pp.len,
		ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, packetpp);
	delete pp.data;

	((PlayerInfo*)(peer->data))->level = tlevel;



	std::ifstream ifffx("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");


	if (ifffx.fail()) {
		ifffx.close();


	}
	if (ifffx.is_open()) {
	}
	json jx;
	ifffx >> jx; //load


	jx["level"] = ((PlayerInfo*)(peer->data))->level;



	std::ofstream o("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json"); //save
	if (!o.is_open()) {
		cout << GetLastError() << endl;
		_getch();
	}

	o << jx << std::endl;

	GamePacket ps = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`wMessage from `4Admin`0: `2You have claim your `5Items `9Thx for `qPurchasing"), "audio/hub_open.wav"), 0));

	ENetPacket* packet = enet_packet_create(ps.data,
		ps.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete ps.data;

	std::ifstream ifffxx("claim/" + ((PlayerInfo*)(peer->data))->rawName + ".json");


	if (ifffxx.fail()) {
		ifffxx.close();


	}
	if (ifffxx.is_open()) {
	}
	json jxx;
	ifffxx >> jxx; //load


	jxx["level"] = 0;
	jxx["gems"] = 0; //edit



	std::ofstream oxx("claim/" + ((PlayerInfo*)(peer->data))->rawName + ".json"); //save
	if (!oxx.is_open()) {
		cout << GetLastError() << endl;
		_getch();
	}

	oxx << jxx << std::endl;
}
void GiveRank(string rankName, string playerName, bool& success)
{
	bool existsPlayer = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(playerName) + ".json");
	if (existsPlayer)
	{

		std::ifstream iffff("players/" + playerName + ".json");

		json jj;

		success = false;

		if (iffff.fail()) {
			iffff.close();

		}
		if (iffff.is_open()) {


		}

		iffff >> jj; //load

		std::ofstream oo("players/" + playerName + ".json");
		if (!oo.is_open()) {
			cout << GetLastError() << endl;
			_getch();
		}

		int countranks, rankNumber;
		string rankText;
		ifstream ranks("giverank.txt");
		ranks >> countranks;
		for (int i = 0; i < countranks; i++)
		{
			ranks >> rankNumber >> rankText;
			if (rankText == rankName)
			{
				jj["adminLevel"] = rankNumber;
				success = true;
				break;
			}

		}
		ranks.close();
		if (success) oo << jj << std::endl;
	}
	else
	{
		success = false;
	}
}
void SearchInventoryItem(ENetPeer* peer, int fItemid, int fQuantity, bool& iscontains)
{
	iscontains = false;
	for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
	{
		if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == fItemid && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= fQuantity) {

			iscontains = true;
			break;
		}
	}
}
void SaveShopsItem(int fItemid, int fQuantity, ENetPeer* peer, bool& success)
{
	size_t invsizee = ((PlayerInfo*)(peer->data))->currentInventorySize;
	bool invfull = false;
	bool alreadyhave = false;


	bool iscontains = false;
	for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
	{


		if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == fItemid) {


			GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`4Whoops!|left|2398|\nadd_spacer|small|\nadd_textbox|`9Sorry! You already have this!.|\nadd_spacer|small|\nadd_button|close|`5Close|0|0|"));
			ENetPacket* packet = enet_packet_create(ps.data,
				ps.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete ps.data;


			iscontains = true;
		}
	}

	if (iscontains == true || alreadyhave == true)
	{
		success = false;
	}
	else
	{
		success = true;

		std::ifstream iffff("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");

		json jj;

		if (iffff.fail()) {
			iffff.close();
			cout << "[!] SaveShopsItem funkcijoje (ifstream dalyje) error: itemid - " << fItemid << ", kiekis - " << fQuantity << endl;

		}
		if (iffff.is_open()) {


		}

		iffff >> jj; //load


		std::ofstream oo("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
		if (!oo.is_open()) {
			cout << GetLastError() << " SaveShopsItem funkcijoje (ofstream dalyje) error: itemid - " << fItemid << ", kiekis - " << fQuantity << endl;
			_getch();
		}

		//jj["items"][aposition]["aposition"] = aposition;

		for (int i = 0; i < ((PlayerInfo*)(peer->data))->currentInventorySize; i++)
		{
			int itemid = jj["items"][i]["itemid"];
			int quantity = jj["items"][i]["quantity"];
			if (itemid == 0 && quantity == 0)
			{
				jj["items"][i]["itemid"] = fItemid;
				jj["items"][i]["quantity"] = fQuantity;
				break;
			}

		}
		oo << jj << std::endl;


		InventoryItem item;
		item.itemID = fItemid;
		item.itemCount = fQuantity;
		((PlayerInfo*)(peer->data))->inventory.items.push_back(item);

		sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
	}
}

void SaveShopsItemMoreTimes(int fItemid, int fQuantity, ENetPeer* peer, bool& success)
{
	size_t invsizee = ((PlayerInfo*)(peer->data))->currentInventorySize;
	bool invfull = false;
	bool alreadyhave = false;


	if (((PlayerInfo*)(peer->data))->inventory.items.size() == invsizee) {
		sendConsoleMsg(peer, "Your inventory is full! please upgrade it on the store.");
		alreadyhave = true;
	}

	bool isFullStock = false;
	bool isInInv = false;
	for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
	{

		if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == fItemid && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 200) {


			sendConsoleMsg(peer, "You already reached the max count of the item!");

			isFullStock = true;
		}

		if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == fItemid && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount < 200)	isInInv = true;

	}

	if (isFullStock == true || alreadyhave == true)
	{
		success = false;
	}
	else
	{
		success = true;

		std::ifstream iffff("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");

		json jj;

		if (iffff.fail()) {
			iffff.close();


		}
		if (iffff.is_open()) {


		}

		iffff >> jj; //load


		std::ofstream oo("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
		if (!oo.is_open()) {
			cout << GetLastError() << endl;
			_getch();
		}

		//jj["items"][aposition]["aposition"] = aposition;

		if (isInInv == false)
		{

			for (int i = 0; i < ((PlayerInfo*)(peer->data))->currentInventorySize; i++)
			{
				int itemid = jj["items"][i]["itemid"];
				int quantity = jj["items"][i]["quantity"];

				if (itemid == 0 && quantity == 0)
				{
					jj["items"][i]["itemid"] = fItemid;
					jj["items"][i]["quantity"] = fQuantity;
					break;
				}

			}
			oo << jj << std::endl;


			InventoryItem item;
			item.itemID = fItemid;
			item.itemCount = fQuantity;
			((PlayerInfo*)(peer->data))->inventory.items.push_back(item);

			sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
		}
		else
		{
			for (int i = 0; i < ((PlayerInfo*)(peer->data))->currentInventorySize; i++)
			{
				int itemid = jj["items"][i]["itemid"];
				int quantity = jj["items"][i]["quantity"];

				if (itemid == fItemid)
				{
					jj["items"][i]["quantity"] = quantity + fQuantity;
					break;
				}

			}
			oo << jj << std::endl;


			for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
			{
				if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == fItemid)
				{
					((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount += fQuantity;
					sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
				}
			}

		}
	}
}

void SaveFindsItem(int fItemid, int fQuantity, ENetPeer* peer)
{

	std::ifstream iffff("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");

	json jj;

	if (iffff.fail()) {
		iffff.close();


	}
	if (iffff.is_open()) {


	}

	iffff >> jj; //load


	std::ofstream oo("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
	if (!oo.is_open()) {
		cout << GetLastError() << endl;
		_getch();
	}

	//jj["items"][aposition]["aposition"] = aposition;

	for (int i = 0; i < ((PlayerInfo*)(peer->data))->currentInventorySize; i++)
	{
		int itemid = jj["items"][i]["itemid"];
		int quantity = jj["items"][i]["quantity"];
		if (itemid == 0 && quantity == 0)
		{
			jj["items"][i]["itemid"] = fItemid;
			jj["items"][i]["quantity"] = fQuantity;
			break;
		}

	}
	oo << jj << std::endl;


	InventoryItem item;
	item.itemID = fItemid;
	item.itemCount = fQuantity;
	((PlayerInfo*)(peer->data))->inventory.items.push_back(item);

	sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
}
bool SaveConvertedItem(int fItemid, int fQuantity, ENetPeer* peer)
{
	int invsizee = ((PlayerInfo*)(peer->data))->currentInventorySize;

	bool doesItemInInventryAlready = false;

	for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
	{
		if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == fItemid)
		{
			doesItemInInventryAlready = true;
			if (((PlayerInfo*)(peer->data))->inventory.items[i].itemCount >= 101) return false;
			break;
		}
	}

	std::ifstream iffff("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");

	json jj;

	if (iffff.fail()) {
		iffff.close();
		cout << "SaveConvertedItem funkcijoje (ifstream dalyje) error: itemid - " << fItemid << ", kiekis - " << fQuantity << endl;

	}
	if (iffff.is_open()) {


	}

	iffff >> jj; //load


	std::ofstream oo("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
	if (!oo.is_open()) {
		cout << GetLastError() << " SaveConvertedItem funkcijoje (ofstream dalyje) error: itemid - " << fItemid << ", kiekis - " << fQuantity << endl;
		_getch();
	}
	int howManyHasNow = 0;

	for (int i = 0; i < ((PlayerInfo*)(peer->data))->currentInventorySize; i++)
	{
		int itemidFromJson = jj["items"][i]["itemid"];
		int quantityFromJson = jj["items"][i]["quantity"];;
		if (doesItemInInventryAlready)
		{
			if (itemidFromJson == fItemid)
			{
				howManyHasNow = jj["items"][i]["quantity"];
				howManyHasNow += fQuantity;
				jj["items"][i]["quantity"] = howManyHasNow;

				for (int k = 0; k < ((PlayerInfo*)(peer->data))->inventory.items.size(); k++)
				{
					if (((PlayerInfo*)(peer->data))->inventory.items[k].itemID == fItemid)
					{
						((PlayerInfo*)(peer->data))->inventory.items[k].itemCount += (byte)fQuantity;
						break;
					}
				}
				sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);

				break;
			}
		}
		else if (itemidFromJson == 0 && quantityFromJson == 0)
		{
			jj["items"][i]["quantity"] = fQuantity;
			jj["items"][i]["itemid"] = fItemid;

			InventoryItem item;
			item.itemID = fItemid;
			item.itemCount = fQuantity;
			((PlayerInfo*)(peer->data))->inventory.items.push_back(item);

			sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);

			break;
		}
	}

	oo << jj << std::endl;
	return true;
}

void RemoveInventoryItem(int fItemid, int fQuantity, ENetPeer* peer)
{
	std::ifstream iffff("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");

	json jj;

	if (iffff.fail()) {
		iffff.close();
		cout << "[!]  RemoveInventoryItem funkcijoje (ofstream dalyje) error: itemid - " << fItemid << ", kiekis - " << fQuantity << endl;

	}
	if (iffff.is_open()) {


	}

	iffff >> jj; //load


	std::ofstream oo("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
	if (!oo.is_open()) {
		cout << GetLastError() << " RemoveInventoryItem funkcijoje (ofstream dalyje) error: itemid - " << fItemid << ", kiekis - " << fQuantity << endl;
		_getch();
	}

	//jj["items"][aposition]["aposition"] = aposition;


	for (int i = 0; i < ((PlayerInfo*)(peer->data))->currentInventorySize; i++)
	{
		int itemid = jj["items"][i]["itemid"];
		int quantity = jj["items"][i]["quantity"];
		if (itemid == fItemid)
		{
			if (quantity - fQuantity == 0)
			{
				jj["items"][i]["itemid"] = 0;
				jj["items"][i]["quantity"] = 0;
			}
			else
			{
				jj["items"][i]["itemid"] = itemid;
				jj["items"][i]["quantity"] = quantity - fQuantity;
			}

			break;
		}

	}
	oo << jj << std::endl;

	for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
	{
		if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == fItemid)
		{
			if ((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount > fQuantity && (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount != fQuantity)
			{
				((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount -= fQuantity;
			}
			else
			{
				((PlayerInfo*)(peer->data))->inventory.items.erase(((PlayerInfo*)(peer->data))->inventory.items.begin() + i);
			}
			sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
		}
	}


}

void SaveInventoryWhenBuildingBlock(ENetPeer* peer)
{
	std::ifstream iffff("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");

	json jj;



	if (iffff.fail()) {
		iffff.close();
		cout << "[!] Klaida, skaitant inventoriu zaidejui " << ((PlayerInfo*)(peer->data))->rawName << " jam statant bloka worlde!" << endl;

	}
	if (iffff.is_open()) {


	}

	iffff >> jj; //load


	std::ofstream oo("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
	if (!oo.is_open()) {
		cout << GetLastError() << endl;
		_getch();
	}

	for (int i = 0; i < ((PlayerInfo*)(peer->data))->currentInventorySize; i++)
	{
		if (i < ((PlayerInfo*)(peer->data))->inventory.items.size())
		{
			jj["items"][i]["itemid"] = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID;
			jj["items"][i]["quantity"] = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
		}
		else
		{
			jj["items"][i]["itemid"] = 0;
			jj["items"][i]["quantity"] = 0;
		}
	}

	oo << jj << std::endl;

	if (oo.fail()) {
		oo.close();
		cout << "[!] Klaida, saugant inventoriu zaidejui " << ((PlayerInfo*)(peer->data))->rawName << " jam pastacius bloka worlde!" << endl;

	}
}


BYTE* packPlayerMoving(PlayerMoving* dataStruct)
{
	BYTE* data = new BYTE[64];
	for (int i = 0; i < 64; i++)
	{
		data[i] = 0;
	}
	memcpy(data, &dataStruct->packetType, 4);
	memcpy(data + 4, &dataStruct->netID, 4);
	memcpy(data + 12, &dataStruct->characterState, 4);
	memcpy(data + 20, &dataStruct->plantingTree, 4);
	memcpy(data + 24, &dataStruct->x, 4);
	memcpy(data + 28, &dataStruct->y, 4);
	memcpy(data + 32, &dataStruct->XSpeed, 4);
	memcpy(data + 36, &dataStruct->YSpeed, 4);
	memcpy(data + 44, &dataStruct->punchX, 4);
	memcpy(data + 48, &dataStruct->punchY, 4);
	return data;
}
string packPlayerMoving2(PlayerMoving* dataStruct)
{
	string data;
	data.resize(56);
	STRINT(data, 0) = dataStruct->packetType;
	STRINT(data, 4) = dataStruct->netID;
	STRINT(data, 12) = dataStruct->characterState;
	STRINT(data, 20) = dataStruct->plantingTree;
	STRINT(data, 24) = *(int*)&dataStruct->x;
	STRINT(data, 28) = *(int*)&dataStruct->y;
	STRINT(data, 32) = *(int*)&dataStruct->XSpeed;
	STRINT(data, 36) = *(int*)&dataStruct->YSpeed;
	STRINT(data, 44) = dataStruct->punchX;
	STRINT(data, 48) = dataStruct->punchY;
	return data;
}
string lockTileDatas(int visual, uint32_t owner, uint32_t adminLength, uint32_t* admins, bool isPublic = false, uint8_t bpm = 0) {
	string data;
	data.resize(4 + 2 + 4 + 4 + adminLength * 4 + 8);
	if (bpm) data.resize(data.length() + 4);
	data[2] = 0x01;
	if (isPublic) data[2] |= 0x80;
	data[4] = 3;
	data[5] = visual; // or 0x02
	STRINT(data, 6) = owner;
	//data[14] = 1;
	STRINT(data, 10) = adminLength;
	for (uint32_t i = 0; i < adminLength; i++) {
		STRINT(data, 14 + i * 4) = admins[i];
	}

	if (bpm) {
		STRINT(data, 10)++;
		STRINT(data, 14 + adminLength * 4) = -bpm;
	}
	return data;
}

uint8_t* lockTileData(uint32_t owner, uint32_t adminLength, uint32_t* admins) {
	uint8_t* data = new uint8_t[4 + 2 + 4 + 4 + adminLength * 4 + 8];
	memset(data, 0, 4 + 2 + 4 + 4 + adminLength * 4 + 8);
	data[2] = 0x1;
	data[4] = 3;
	*(uint32_t*)(data + 6) = owner;

	*(uint32_t*)(data + 10) = adminLength;
	for (uint32_t i = 0; i < adminLength; i++) {
		*(uint32_t*)(data + 14 + i * 4) = admins[i];
	}
	return data;
}
void sendLock(ENetPeer* peer, int x, int y, int lockid, uint32_t owner, uint32_t adminsize, uint32_t* admins)
{
	PlayerMoving pmov;
	pmov.packetType = 5;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = -1;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	*(uint32_t*)(pmovpacked + 52) = 4 + 22 + adminsize * 4;
	uint8_t* packet = new uint8_t[4 + 56 + 4 + 22 + adminsize * 4];
	memset(packet, 0, 4 + 56 + 4 + 22 + adminsize * 4);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, 56);
	*(uint16_t*)(packet + 56 + 4) = lockid;
	uint8_t* tiledata = lockTileData(owner, adminsize, admins);
	memcpy(packet + 60 + 4, tiledata, 22 + adminsize + 4);
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56 + 4 + 22 + adminsize * 4, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete packet;
	delete tiledata;
}
BYTE* packBlockVisual(BlockVisual* dataStruct)
{
	BYTE* data = new BYTE[72];
	for (int i = 0; i < 72; i++)
	{
		data[i] = 0;
	}
	memcpy(data, &dataStruct->packetType, 4);
	memcpy(data + 8, &dataStruct->netID, 4);
	memcpy(data + 12, &dataStruct->characterState, 4);
	memcpy(data + 44, &dataStruct->punchX, 4);
	memcpy(data + 48, &dataStruct->punchY, 4);
	memcpy(data + 52, &dataStruct->charStat, 4);
	memcpy(data + 56, &dataStruct->blockid, 4);
	//memcpy(data + 58, &dataStruct->backgroundid, 4);
	memcpy(data + 60, &dataStruct->visual, 4);
	memcpy(data + 64, &dataStruct->displayblock, 4);


	return data;
}

PlayerMoving* unpackPlayerMoving(BYTE* data)
{
	PlayerMoving* dataStruct = new PlayerMoving;
	dataStruct->packetType = *(int*)(data);
	dataStruct->netID = *(int*)(data + 4);
	dataStruct->characterState = *(int*)(data + 12);
	dataStruct->plantingTree = *(int*)(data + 20);
	dataStruct->x = *(float*)(data + 24);
	dataStruct->y = *(float*)(data + 28);
	dataStruct->XSpeed = *(float*)(data + 32);
	dataStruct->YSpeed = *(float*)(data + 36);
	dataStruct->punchX = *(int*)(data + 44);
	dataStruct->punchY = *(int*)(data + 48);
	return dataStruct;
}

void SendPacket(int a1, string a2, ENetPeer* enetPeer)
{
	if (enetPeer)
	{
		ENetPacket* v3 = enet_packet_create(0, a2.length() + 5, 1);
		memcpy(v3->data, &a1, 4);
		//*(v3->data) = (DWORD)a1;
		memcpy((v3->data) + 4, a2.c_str(), a2.length());

		//cout << std::hex << (int)(char)v3->data[3] << endl;
		enet_peer_send(enetPeer, 0, v3);
	}
}
void SendPacketRaw2(int a1, void* packetData, size_t packetDataSize, void* a4, ENetPeer* peer, int packetFlag)
{
	ENetPacket* p;

	if (peer) // check if we have it setup
	{
		if (a1 == 4 && *((BYTE*)packetData + 12) & 8)
		{
			p = enet_packet_create(0, packetDataSize + *((DWORD*)packetData + 13) + 5, packetFlag);
			int four = 4;
			memcpy(p->data, &four, 4);
			memcpy((char*)p->data + 4, packetData, packetDataSize);
			memcpy((char*)p->data + packetDataSize + 4, a4, *((DWORD*)packetData + 13));
			enet_peer_send(peer, 0, p);

		}
		else
		{
			if (a1 == 192) {
				a1 = 4;
				p = enet_packet_create(0, packetDataSize + 5, packetFlag);
				memcpy(p->data, &a1, 4);
				memcpy((char*)p->data + 4, packetData, packetDataSize);
				enet_peer_send(peer, 0, p);


			}
			else {
				p = enet_packet_create(0, packetDataSize + 5, packetFlag);
				memcpy(p->data, &a1, 4);
				memcpy((char*)p->data + 4, packetData, packetDataSize);
				enet_peer_send(peer, 0, p);


			}
		}
	}

	delete packetData;
}
void SendPacketRaw(int a1, void* packetData, size_t packetDataSize, void* a4, ENetPeer* peer, int packetFlag)
{
	ENetPacket* p;

	if (peer) // check if we have it setup
	{
		if (a1 == 4 && *((BYTE*)packetData + 12) & 8)
		{
			p = enet_packet_create(0, packetDataSize + *((DWORD*)packetData + 13) + 5, packetFlag);
			int four = 4;
			memcpy(p->data, &four, 4);
			memcpy((char*)p->data + 4, packetData, packetDataSize);
			memcpy((char*)p->data + packetDataSize + 4, a4, *((DWORD*)packetData + 13));
			enet_peer_send(peer, 0, p);

		}
		else
		{
			if (a1 == 192) {
				a1 = 4;
				p = enet_packet_create(0, packetDataSize + 5, packetFlag);
				memcpy(p->data, &a1, 4);
				memcpy((char*)p->data + 4, packetData, packetDataSize);
				enet_peer_send(peer, 0, p);

				/*p = enet_packet_create(0, packetDataSize + *((DWORD *)packetData + 16) + 5, packetFlag);
				int four = 4;
				memcpy(p->data, &four, 4);
				memcpy((char *)p->data + 4, packetData, packetDataSize);
				memcpy((char *)p->data + packetDataSize + 4, a4, *((DWORD *)packetData + 16));
				enet_peer_send(peer, 0, p);*/
			}
			else {
				p = enet_packet_create(0, packetDataSize + 5, packetFlag);
				memcpy(p->data, &a1, 4);
				memcpy((char*)p->data + 4, packetData, packetDataSize);
				enet_peer_send(peer, 0, p);


			}
		}
	}

	delete packetData;
}
void updateGuild(ENetPeer* peer) {
	string guildname = PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild);
	if (guildname != "") {
		std::ifstream ifff("guilds/" + guildname + ".json");
		if (ifff.fail()) {
			ifff.close();
			cout << "[!] Failed loading guilds/" + guildname + ".json! From " + ((PlayerInfo*)(peer->data))->displayName + "." << endl;
			((PlayerInfo*)(peer->data))->guild = "";
			updateGuild;
		}
		json j;
		ifff >> j;

		int gfbg, gffg;

		string gstatement, gleader;

		vector<string> gmembers;

		gfbg = j["backgroundflag"];
		gffg = j["foregroundflag"];
		gstatement = j["GuildStatement"].get<string>();
		gleader = j["Leader"].get<string>();
		for (int i = 0; i < j["Member"].size(); i++) {
			gmembers.push_back(j["Member"][i]);
		}

		if (find(gmembers.begin(), gmembers.end(), ((PlayerInfo*)(peer->data))->rawName) == gmembers.end()) {
			((PlayerInfo*)(peer->data))->guild = "";
		}
		else {
			((PlayerInfo*)(peer->data))->guildBg = gfbg;
			((PlayerInfo*)(peer->data))->guildFg = gffg;
			((PlayerInfo*)(peer->data))->guildStatement = gstatement;
			((PlayerInfo*)(peer->data))->guildLeader = gleader;
			((PlayerInfo*)(peer->data))->guildMembers = gmembers;
		}

		ifff.close();
	}
}
void addInventoryItem(ENetPeer* peer, int id, int netID, int amount) {
	PlayerMoving pmov;
	memset(&pmov, 0, sizeof(PlayerMoving));
	pmov.netID = netID;
	pmov.plantingTree = id;
	pmov.packetType = 13;
	string packet;
	packet.resize(4);
	packet[0] = 4;
	packet += packPlayerMoving2(&pmov);
	packet[4 + 3] = amount;
	ENetPacket* epacket = enet_packet_create(&packet[0],
		packet.length(),
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, epacket);
}

void removeInventoryItem(ENetPeer* peer, int id, int amount) {

	PlayerMoving pmov;
	pmov.netID = -1;
	pmov.plantingTree = id;
	pmov.packetType = 13;
	string packet;
	packet.resize(4);
	packet[0] = 4;
	packet += packPlayerMoving2(&pmov);
	packet[4 + 2] = amount;
	ENetPacket* epacket = enet_packet_create(&packet[0],
		packet.length(),
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, epacket);
}
int HasItemsInInv(ENetPeer* peer, int itemId, int count);
bool HasInventoryFull(ENetPeer* peer);
bool HasInventoryEmpty(ENetPeer* peer);
void AddItemToInv(ENetPeer* peer, int itemId, int count);

void sendDrop(ENetPeer* peer, int netID, int x, int y, int item, int count, BYTE specialEffect)
{
	if (item >= 100000) return;
	if (item < 0) return;

	ENetPeer* currentPeer;
	string name = "";
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			PlayerMoving data;
			data.packetType = 14;
			data.x = x;
			data.y = y;
			data.netID = netID;
			data.plantingTree = item;
			float val = count; // item count
			BYTE val2 = specialEffect;

			BYTE* raw = packPlayerMoving(&data);
			memcpy(raw + 16, &val, 4);
			memcpy(raw + 1, &val2, 1);

			SendPacketRaw(4, raw, 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
}
void sendDropgold(ENetPeer* peer, int netID, int x, int y, int item, int count, BYTE specialEffect, bool& success)
{
	if (item >= 7196) return;
	if (item < 0) return;

	ENetPeer* currentPeer;
	string name = "";
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			PlayerMoving data;
			data.packetType = 14;
			data.x = x;
			data.y = y;
			data.netID = netID;
			data.plantingTree = item;
			float val = count; // item count
			BYTE val2 = specialEffect;

			BYTE* raw = packPlayerMoving(&data);
			memcpy(raw + 16, &val, 4);
			memcpy(raw + 1, &val2, 1);

			SendPacketRaw(4, raw, 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
}
void SendThrowEffect(ENetPeer* peer, int id, int netIDsrc, int netIDdst, int timeMs, byte type, int x, int y)
{
	PlayerMoving data;
	data.packetType = 0x13;
	data.punchX = id;
	data.punchY = id;
	data.x = x;
	data.y = y;
	BYTE* raw = packPlayerMoving(&data);
	int netIdSrc = netIDsrc;
	int netIdDst = netIDdst;
	int three = 3;
	int n1 = timeMs;
	memcpy(raw + 3, &type, 1);
	memcpy(raw + 4, &netIdDst, 4);
	memcpy(raw + 8, &netIdSrc, 4);
	memcpy(raw + 20, &n1, 4);

	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer))
		{
			BYTE* raw2 = new BYTE[56];
			memcpy(raw2, raw, 56);
			SendPacketRaw(4, raw2, 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	delete raw;
}

void sendCollect(ENetPeer* peer, int netID, int x, int y, int uid)
{
	if (uid >= 2147480000) return;
	if (uid < 0) return;
	ENetPeer* currentPeer;
	string name = "";
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			PlayerMoving data;
			data.packetType = 14;
			data.x = x;
			data.y = y;
			data.netID = netID;
			data.plantingTree = uid;
			SendPacketRaw(4, packPlayerMoving(&data), 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
}
void processTake(ENetPeer* peer, PlayerMoving* pMov, int itemIdx, float x, float y)
{
	PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
	WorldInfo* world = getPlyersWorld(peer);
	if (!world) return;
	if (x == 0 || y == 0) return;
	int blockX = (int)x / 32;
	int blockY = (int)y / 32;
	if (blockX<0 || blockY<0 || blockX>world->width || blockY>world->height) return;
	bool legit = true;
	int atik = -1;
	int errcode = 1;
	for (int i = 0; i < world->droppedItems.size(); i++)
	{
		if (world->droppedItems.at(i).uid == itemIdx)
		{
			atik = i;
			break;
		}
	}
	legit = atik != -1;
	if (legit) {
		try {
			DroppedItem droppedItem = world->droppedItems.at(atik);

			int did = droppedItem.id;
			if (droppedItem.id != 112) {
				if (getItemDef(droppedItem.id).rarity == 999) {
					player::consolemessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o.");
				}
				else {
					player::consolemessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o. Rarity: `w" + to_string(getItemDef(droppedItem.id).rarity) + "`o.");
				}
				bool success = true;
				SaveShopsItemMoreTimes(droppedItem.id, droppedItem.count, peer, success);
			}
			else {
				pinfo->gem += droppedItem.count;
				GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
				int respawnTimeout = 1000;
				int deathFlag = 0x19;
				memcpy(pp.data + 24, &respawnTimeout, 4);
				memcpy(pp.data + 56, &deathFlag, 4);
				ENetPacket* packetpp = enet_packet_create(pp.data,
					pp.len,
					ENET_PACKET_FLAG_RELIABLE);

				enet_peer_send(peer, 0, packetpp);
				delete pp.data;
			}
			
			sendCollect(peer, pinfo->netID, pMov ? pMov->x : pinfo->x, pMov ? pMov->y : pinfo->y, itemIdx + 1);
			world->droppedItems.erase(world->droppedItems.begin() + atik);
		}
		catch (...) {
			return;
		}
	}
}
void RemoveDroppedItem(ENetPeer* peer, int obj_id, WorldInfo* world)
{
	if (!world) return;

	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			BYTE* b = new BYTE[56];
			memset(b, 0, 56);
			*((int*)&b[0]) = 0xe;
			*((int*)&b[4]) = -2; // type
			*((int*)&b[8]) = -1;
			*((int*)&b[20]) = obj_id + 1; // source ID 1

			SendPacketRaw(4, b, 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
}


void Dropgold(ENetPeer* peer, int netID, int x, int y, int item, int count, BYTE specialEffect, bool& success)
{
	WorldInfo* world = getPlyersWorld(peer);
	if (!world) return;
	if (item >= maxItems) return;
	if (item < 0) return;
	try {
		for (int i = 0; i < world->width * world->height; i++)
		{
			if (world->items[i].foreground == 5638) {
				if (item == world->items[i].magitem && world->items[i].magcollect == true) {
					ENetPeer* currentPeer;
					for (currentPeer = server->peers;
						currentPeer < &server->peers[server->peerCount];
						++currentPeer)
					{
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
							continue;
						if (isHere(peer, currentPeer)) {
							SendThrowEffect(currentPeer, world->items[i].magitem, netID, -1, 150, 5, world->items[i].magX * 32 + 16, world->items[i].magY * 32 + 16);
						}
					}
					world->items[i].magcount += count;
					return;
				}
			}
		}
		DroppedItem itemDropped;
		itemDropped.id = item;
		itemDropped.count = count;
		itemDropped.x = x;
		itemDropped.y = y;
		itemDropped.uid = world->droppedItemUid++;
		world->droppedItems.push_back(itemDropped);
		sendDropgold(peer, netID, x, y, item, count, specialEffect, success);
	}
	catch (...) {
		return;
	}
}
void SendDropSingle(ENetPeer* peer, int netID, int x, int y, int item, int count, BYTE specialEffect)
{
	if (item >= maxItems) return;
	if (item < 0) return;

	PlayerMoving data;
	data.packetType = 14;
	data.x = x;
	data.y = y;
	data.netID = netID;
	data.plantingTree = item;
	float val = count; // item count
	BYTE val2 = specialEffect;

	BYTE* raw = packPlayerMoving(&data);
	memcpy(raw + 16, &val, 4);
	memcpy(raw + 1, &val2, 1);

	SendPacketRaw(4, raw, 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
}
void SendTradeEffect(ENetPeer* peer, int id, int netIDsrc, int netIDdst, int timeMs)
{
	PlayerMoving data;
	data.packetType = 0x13;
	data.punchX = id;
	data.punchY = id;

	BYTE* raw = packPlayerMoving(&data);
	int netIdSrc = netIDsrc;
	int netIdDst = netIDdst;
	int three = 3;
	int n1 = timeMs;
	memcpy(raw + 3, &three, 1);
	memcpy(raw + 4, &netIdDst, 4);
	memcpy(raw + 8, &netIdSrc, 4);
	memcpy(raw + 20, &n1, 4);

	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer))
		{
			BYTE* raw2 = new BYTE[56];
			memcpy(raw2, raw, 56);
			SendPacketRaw(4, raw2, 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	delete raw;
}
void sendArrow(ENetPeer* peer, uint16_t itemid, bool droppeditem) {
	PlayerMoving pmov;
	memset(&pmov, 0, sizeof(PlayerMoving));
	*(uint32_t*)(&pmov) = 37 | (droppeditem << 8);
	pmov.netID = itemid;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	uint8_t* packet = new uint8_t[4 + 56];
	memset(packet, 0, 4 + 56);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, sizeof(PlayerMoving));
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete packet;
}

void SendTake(ENetPeer* peer, int netID, int x, int y, int item)
{
	ENetPeer* currentPeer;
	string name = "";
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			PlayerMoving data;
			data.packetType = 14;
			data.x = x;
			data.y = y;
			data.netID = netID;
			data.plantingTree = item;

			BYTE* raw = packPlayerMoving(&data);

			SendPacketRaw(4, raw, 56, 0, currentPeer, ENET_EVENT_TYPE_RECEIVE);
		}
	}
}

void onPeerConnect(ENetPeer* peer)
{
	ENetPeer* currentPeer;

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (peer != currentPeer)
		{
			if (isHere(peer, currentPeer))
				if (((PlayerInfo*)(currentPeer->data))->isinv == true)
				{
					if (((PlayerInfo*)(currentPeer->data))->adminLevel == 999) {
						string netIdS = std::to_string(((PlayerInfo*)(currentPeer->data))->netID);
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + netIdS + "\nuserID|" + netIdS + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(((PlayerInfo*)(currentPeer->data))->x) + "|" + std::to_string(((PlayerInfo*)(currentPeer->data))->y) + "\nname|``" + ((PlayerInfo*)(currentPeer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(currentPeer->data))->country + "\ninvis|1\nmstate|0\nsmstate|1\n")); // ((PlayerInfo*)(server->peers[i].data))->tankIDName
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);


						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
					else
					{
						string netIdS = std::to_string(((PlayerInfo*)(currentPeer->data))->netID);
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + netIdS + "\nuserID|" + netIdS + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(((PlayerInfo*)(currentPeer->data))->x) + "|" + std::to_string(((PlayerInfo*)(currentPeer->data))->y) + "\nname|``" + ((PlayerInfo*)(currentPeer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(currentPeer->data))->country + "\ninvis|1\nmstate|0\nsmstate|0\n")); // ((PlayerInfo*)(server->peers[i].data))->tankIDName
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);


						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
				}
				else
				{
					string netIdS = std::to_string(((PlayerInfo*)(currentPeer->data))->netID);
					GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + netIdS + "\nuserID|" + netIdS + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(((PlayerInfo*)(currentPeer->data))->x) + "|" + std::to_string(((PlayerInfo*)(currentPeer->data))->y) + "\nname|``" + ((PlayerInfo*)(currentPeer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(currentPeer->data))->country + "\ninvis|0\nmstate|0\nsmstate|0\n")); // ((PlayerInfo*)(server->peers[i].data))->tankIDName
					ENetPacket* packet = enet_packet_create(p.data,
						p.len,
						ENET_PACKET_FLAG_RELIABLE);


					enet_peer_send(peer, 0, packet);
					delete p.data;
				}
			if (((PlayerInfo*)(peer->data))->isinv == true)
			{
				string netIdS2 = std::to_string(((PlayerInfo*)(peer->data))->netID);
				GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + netIdS2 + "\nuserID|" + netIdS2 + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(((PlayerInfo*)(peer->data))->x) + "|" + std::to_string(((PlayerInfo*)(peer->data))->y) + "\nname|``" + ((PlayerInfo*)(peer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(peer->data))->country + "\ninvis|1\nmstate|0\nsmstate|0\n")); // ((PlayerInfo*)(server->peers[i].data))->tankIDName
				ENetPacket* packet2 = enet_packet_create(p2.data,
					p2.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packet2);
				delete p2.data;
				//enet_host_flush(server);
			}
			else
			{
				string netIdS2 = std::to_string(((PlayerInfo*)(peer->data))->netID);
				GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + netIdS2 + "\nuserID|" + netIdS2 + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(((PlayerInfo*)(peer->data))->x) + "|" + std::to_string(((PlayerInfo*)(peer->data))->y) + "\nname|``" + ((PlayerInfo*)(peer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(peer->data))->country + "\ninvis|0\nmstate|0\nsmstate|0\n")); // ((PlayerInfo*)(server->peers[i].data))->tankIDName
				ENetPacket* packet2 = enet_packet_create(p2.data,
					p2.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packet2);
				delete p2.data;
				//enet_host_flush(server);
			}
		}
	}

}

void updateDoor(ENetPeer* peer, int foreground, int x, int y, string text)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	int hmm = 8;
	int text_len = text.length();
	int lol = 0;
	int wut = 5;
	int yeh = hmm + 3 + 1;
	int idk = 15 + text_len;
	int is_locked = 0;
	int bubble_type = 1;
	int ok = 52 + idk;
	int kek = ok + 4;
	int yup = ok - 8 - idk;
	int four = 4;
	int magic = 56;
	int wew = ok + 5 + 4;
	int wow = magic + 4 + 5;

	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	memcpy(data, &wut, four); //4
	memcpy(data + yeh, &hmm, four); //8
	memcpy(data + yup, &x, 4); //12
	memcpy(data + yup + 4, &y, 4); //16
	memcpy(data + 4 + yup + 4, &idk, four); //20
	memcpy(data + magic, &foreground, 2); //22
	memcpy(data + four + magic, &lol, four); //26
	memcpy(data + magic + 4 + four, &bubble_type, 1); //27
	memcpy(data + wow, &text_len, 2); //data + wow = text_len, pos 29
	memcpy(data + 2 + wow, text.c_str(), text_len); //data + text_len_len + text_len_offs = text, pos 94
	memcpy(data + ok, &is_locked, four); //98
	memcpy(p->data, &four, four); //4
	memcpy((char*)p->data + four, data, kek); //kek = data_len
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, p);
		}
	}
	delete data;
}
/*void Respawn(ENetPeer* peer) {
	int x = 3040;
	int y = 736;

	WorldInfo* world = getPlyersWorld(peer);
	if (world)
	{


		ENetPeer* currentPeer;

		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {

				int x = ((PlayerInfo*)(peer->data))->x;
				int y = ((PlayerInfo*)(peer->data))->y;
				GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 3), x, (y + 8)));

				ENetPacket* packetd = enet_packet_create(psp.data,
					psp.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packetd);
				delete psp.data;

				string text = "action|play_sfx\nfile|audio/male_scream.wav\ndelayMS|0\n";
				BYTE* data = new BYTE[5 + text.length()];
				BYTE zero = 0;
				int type = 3;
				memcpy(data, &type, 4);
				memcpy(data + 4, text.c_str(), text.length());
				memcpy(data + 4 + text.length(), &zero, 1);

				{
					ENetPacket* packetres = enet_packet_create(data,
						5 + text.length(),
						ENET_PACKET_FLAG_RELIABLE);

					if (isHere(peer, currentPeer)) {
						enet_peer_send(currentPeer, 0, packetres);

					}
				}
			}
		}

		for (int i = 0; i < world->width * world->height; i++)
		{
			if (world->items[i].foreground == 6) {
				x = (i % world->width) * 32;
				y = (i / world->width) * 32;
				//world->items[i].foreground = 8;
			}
		}
		{
			PlayerMoving data;
			data.packetType = 0x0;
			data.characterState = 0x924; // animation
			data.x = x;
			data.y = y;
			data.punchX = -1;
			data.punchY = -1;
			data.XSpeed = 0;
			data.YSpeed = 0;
			data.netID = ((PlayerInfo*)(peer->data))->netID;
			data.plantingTree = 0x0; // 0x0
			SendPacketRaw(4, packPlayerMoving(&data), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
		}

		{
			int x = 3040;
			int y = 736;


			for (int i = 0; i < world->width * world->height; i++)
			{
				if (world->items[i].foreground == 6) {
					x = (i % world->width) * 32;
					y = (i / world->width) * 32;
					//world->items[i].foreground = 8;
				}
			}
			GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), x, y));
			memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
			ENetPacket* packet2 = enet_packet_create(p2.data,
				p2.len,
				ENET_PACKET_FLAG_RELIABLE);


			enet_peer_send(peer, 0, packet2);
			delete p2.data;
			//enet_host_flush(server);
		}
		{
			int x = 3040;
			int y = 736;


			for (int i = 0; i < world->width * world->height; i++)
			{
				if (world->items[i].foreground == 6) {
					x = (i % world->width) * 32;
					y = (i / world->width) * 32;
					//world->items[i].foreground = 8;
				}
			}
			GamePacket p2 = packetEnd(appendIntx(appendString(createPacket(), "OnSetFreezeState"), 0));
			memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
			ENetPacket* packet2 = enet_packet_create(p2.data,
				p2.len,
				ENET_PACKET_FLAG_RELIABLE);


			enet_peer_send(peer, 0, packet2);
			delete p2.data;
			enet_host_flush(server);
		}
	}
	if (((PlayerInfo*)(peer->data))->ischeck == false)
	{
		GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), x, y));
		memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
		ENetPacket* packet2 = enet_packet_create(p2.data,
			p2.len,
			ENET_PACKET_FLAG_RELIABLE);


		enet_peer_send(peer, 0, packet2);
		delete p2.data;
	}
	else
	{
		GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), ((PlayerInfo*)(peer->data))->checkx, ((PlayerInfo*)(peer->data))->checky));
		memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
		ENetPacket* packet2 = enet_packet_create(p2.data,
			p2.len,
			ENET_PACKET_FLAG_RELIABLE);


		enet_peer_send(peer, 0, packet2);
		delete p2.data;
	}
}*/
void doorlocked(ENetPeer* peer, int foreground, int x, int y, string text)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	int hmm = 8;
	int text_len = text.length();
	int lol = 0;
	int wut = 5;
	int yeh = hmm + 3 + 1;
	int idk = 15 + text_len;
	int is_locked = -1;
	int bubble_type = 1;
	int ok = 52 + idk;
	int kek = ok + 4;
	int yup = ok - 8 - idk;
	int four = 4;
	int magic = 56;
	int wew = ok + 5 + 4;
	int wow = magic + 4 + 5;

	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	memcpy(data, &wut, four); //4
	memcpy(data + yeh, &hmm, four); //8
	memcpy(data + yup, &x, 4); //12
	memcpy(data + yup + 4, &y, 4); //16
	memcpy(data + 4 + yup + 4, &idk, four); //20
	memcpy(data + magic, &foreground, 2); //22
	memcpy(data + four + magic, &lol, four); //26
	memcpy(data + magic + 4 + four, &bubble_type, 1); //27
	memcpy(data + wow, &text_len, 2); //data + wow = text_len, pos 29
	memcpy(data + 2 + wow, text.c_str(), text_len); //data + text_len_len + text_len_offs = text, pos 94
	memcpy(data + ok, &is_locked, four); //98
	memcpy(p->data, &four, four); //4
	memcpy((char*)p->data + four, data, kek); //kek = data_len
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, p);
		}
	}
	delete data;
}
void updateGayItem(ENetPeer* peer, int foreground, int x, int y, string text)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	int hmm = 8;
	int text_len = text.length();
	int lol = 0;
	int wut = 5;
	int yeh = hmm + 3 + 1;
	int idk = 15 + text_len;
	int is_locked = 0;
	int bubble_type = 1;
	int ok = 52 + idk;
	int kek = ok + 4;
	int yup = ok - 8 - idk;
	int four = 4;
	int magic = 56;
	int wew = ok + 5 + 4;
	int wow = magic + 4 + 5;

	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	memcpy(data, &wut, four); //4
	memcpy(data + yeh, &hmm, four); //8
	memcpy(data + yup, &x, 4); //12
	memcpy(data + yup + 4, &y, 4); //16
	memcpy(data + 4 + yup + 4, &idk, four); //20
	memcpy(data + magic, &foreground, 2); //22
	memcpy(data + four + magic, &lol, four); //26
	memcpy(data + magic + 4 + four, &bubble_type, 1); //27
	memcpy(data + wow, &text_len, 2); //data + wow = text_len, pos 29
	memcpy(data + 2 + wow, text.c_str(), text_len); //data + text_len_len + text_len_offs = text, pos 94
	memcpy(data + ok, &is_locked, four); //98
	memcpy(p->data, &four, four); //4
	memcpy((char*)p->data + four, data, kek); //kek = data_len
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, p);
		}
	}
	delete data;
}
void updateDisplay(ENetPeer* peer, int foreground, int x, int y, string text, int background)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	int hmm = 8, wot = text.length(), lol = 0x00010000, wut = 5;
	int yeh = hmm + 3 + 1, idk = 15 + wot, lmao = -1, yey = 2; //idk = text_len + 15, wut = type(?), wot = text_len, yey = len of text_len
	int ok = 52 + idk;
	int kek = ok + 4, yup = ok - 8 - idk;
	int thonk = 4, magic = 56, wew = ok + 5 + 4;
	int wow = magic + 4 + 5;
	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	memcpy(data, &wut, thonk);
	memcpy(data + yeh, &hmm, thonk); //read discord
	memcpy(data + yup, &x, 4);
	memcpy(data + yup + 4, &y, 4);
	memcpy(data + 4 + yup + 4, &idk, thonk);
	memcpy(data + magic, &foreground, yey);
	memcpy(data + magic + 2, &background, yey); // gai?
	memcpy(data + thonk + magic, &lol, thonk);
	memcpy(data + magic + 4 + thonk, &yey, 1);
	memcpy(data + wow, &wot, yey); //data + wow = text_len
	memcpy(data + yey + wow, text.c_str(), wot); //data + text_len_len + text_len_offs = text
	memcpy(data + ok, &lmao, thonk); //end ?
	memcpy(p->data, &thonk, thonk);
	memcpy((char*)p->data + thonk, data, kek); //kek = data_len
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, p);
		}
	}
	delete data;
}
uint8_t* magplantTileData(uint16_t itemid, uint16_t itemamount, uint8_t magnet_on, uint8_t remote_on) {
	uint8_t* data = new uint8_t[15];
	memset(data, 0, 15);
	data[0] = 0x3E;
	*(uint16_t*)(data + 1) = itemid;
	*(uint16_t*)(data + 5) = itemamount;
	*(uint8_t*)(data + 9) = magnet_on;
	*(uint8_t*)(data + 10) = remote_on;
	*(uint8_t*)(data + 12) = 1;
	return data;
}
void sendMag(ENetPeer* peer, int x, int y, uint16_t itemid, uint16_t itemamount, uint8_t magneton, uint8_t remoteon)
{
	PlayerMoving pmov;
	pmov.packetType = 5;
	pmov.characterState = 8;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = -1;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	*(uint32_t*)(pmovpacked + 52) = 15 + 8;
	uint8_t* packet = new uint8_t[4 + 56 + 15 + 8];
	memset(packet, 0, 4 + 56 + 15 + 8);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, 56);
	*(uint16_t*)(packet + 4 + 56) = 5638; // magplant id
	*(uint16_t*)(packet + 4 + 56 + 6) = 1;
	uint8_t* tiledata = magplantTileData(itemid, itemamount, magneton, remoteon);
	memcpy(packet + 4 + 56 + 8, tiledata, 15);
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56 + 8 + 15, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete packet;
	delete tiledata;
}
void updateWorldLock(ENetPeer* peer, int foreground, int x, int y, string text, int background, PlayerInfo* info)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	int hmm = 8, wot = text.length(), lol = info->blockvisual, wut = 5;
	int yeh = hmm + 3 + 1, idk = 15 + wot, lmao = -1, yey = 2; //idk = text_len + 15, wut = type(?), wot = text_len, yey = len of text_len
	int ok = 52 + idk;
	int kek = ok + 4, yup = ok - 8 - idk;
	int thonk = 4, magic = 56, wew = ok + 5 + 4;
	int wow = magic + 4 + 5;
	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	memcpy(data, &wut, thonk);
	memcpy(data + yeh, &hmm, thonk); //read discord
	memcpy(data + yup, &x, 4);
	memcpy(data + yup + 4, &y, 4);
	memcpy(data + 4 + yup + 4, &idk, thonk);
	memcpy(data + magic, &foreground, yey);
	memcpy(data + magic + 2, &background, yey); // gai?
	memcpy(data + thonk + magic, &lol, thonk);
	memcpy(data + magic + 4 + thonk, &yey, 1);
	memcpy(data + wow, &wot, yey); //data + wow = text_len
	memcpy(data + yey + wow, text.c_str(), wot); //data + text_len_len + text_len_offs = text
	memcpy(data + ok, &lmao, thonk); //end ?
	memcpy(p->data, &thonk, thonk);
	memcpy((char*)p->data + thonk, data, kek); //kek = data_len
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, p);
		}
	}
	delete data;
}
void updateRotatedItem(ENetPeer* peer, int foreground, int x, int y, string text, int background)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	int hmm = 8, wot = text.length(), lol = 0x00200000, wut = 5;
	int yeh = hmm + 3 + 1, idk = 15 + wot, lmao = -1, yey = 2; //idk = text_len + 15, wut = type(?), wot = text_len, yey = len of text_len
	int ok = 52 + idk;
	int kek = ok + 4, yup = ok - 8 - idk;
	int thonk = 4, magic = 56, wew = ok + 5 + 4;
	int wow = magic + 4 + 5;
	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	memcpy(data, &wut, thonk);
	memcpy(data + yeh, &hmm, thonk); //read discord
	memcpy(data + yup, &x, 4);
	memcpy(data + yup + 4, &y, 4);
	memcpy(data + 4 + yup + 4, &idk, thonk);
	memcpy(data + magic, &foreground, yey);
	memcpy(data + magic + 2, &background, yey); // gai?
	memcpy(data + thonk + magic, &lol, thonk);
	memcpy(data + magic + 4 + thonk, &yey, 1);
	memcpy(data + wow, &wot, yey); //data + wow = text_len
	memcpy(data + yey + wow, text.c_str(), wot); //data + text_len_len + text_len_offs = text
	memcpy(data + ok, &lmao, thonk); //end ?
	memcpy(p->data, &thonk, thonk);
	memcpy((char*)p->data + thonk, data, kek); //kek = data_len
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, p);
		}
	}
	delete data;
}
class Players
{
public:
	static void Players::OnStartTrade(ENetPeer* peer, string displayName, int netID)
	{
		GamePacket p = packetEnd(appendInt(appendString(appendString(createPacket(), "OnStartTrade"), displayName), netID));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}
	static void Players::OnForceTradeEnd(ENetPeer* peer)
	{
		GamePacket p = packetEnd(appendString(createPacket(), "OnForceTradeEnd"));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}
	static void Players::OnTradeStatus(ENetPeer* peer, int netID, string statustext, string items, string locked)
	{
		//"add_slot|20|3locked|0reset_locks|1accepted|1"
		GamePacket p = packetEnd(appendString(appendString(appendString(appendInt(appendString(createPacket(), "OnTradeStatus"), netID), items), statustext), locked));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}
};
class Player {
public:
	static void OnConsoleMessage(ENetPeer* peer, string text);
	static void OnTalkBubble(ENetPeer* peer, int netID, string text, int chatColor, bool isOverlay);
	static void OnAddNotification(ENetPeer* peer, string text, string audiosound, string interfaceimage);
	static void OnStartAcceptLogon(ENetPeer* peer, int itemdathash);
	static void OnRemove(ENetPeer* peer, int netID);
	static void OnSendToServer(ENetPeer* peer, int userID, int token, string ip, int port, string doorId, int lmode); // no need other args, sub servers done&working already... using fake data etc.
	static void SendTileAnimation(ENetPeer* peer, int x, int y, int causedBy, int tile);
	static void PlayAudio(ENetPeer* peer, string audioFile, int delayMS);
	static void showWrong(ENetPeer* peer, string itemFind, string listFull);
	static void OnZoomCamera(ENetPeer* peer, float value1, int value2);
	static void SmoothZoom(ENetPeer* peer);
	static void OnRaceStart(ENetPeer* peer, int netID);
	static void OnRaceEnd(ENetPeer* peer, int netID);
	static void OnSetCurrentWeather(ENetPeer* peer, int weather);
	static void OnPlayPositioned(ENetPeer* peer, string audiofile, int netID, bool broadcastInWorld, ENetPacket* pk);
	static void OnCountdownStart(ENetPeer* peer, int netID, int time, int score);
	static void OnCountdownUpdate(ENetPeer* peer, int netID, int score);
	static void OnCountdownEnd(ENetPeer* peer);
	static void OnStartTrade(ENetPeer* peer, int netID1, int netID2);
	static void OnTextOverlay(ENetPeer* peer, string text);
	static void OnForceTradeEnd(ENetPeer* peer);
	static void OnFailedToEnterWorld(ENetPeer* peer);
	static void OnNameChanged(ENetPeer* peer, int netID, string name);
	static void OnTradeStatus(ENetPeer* peer, int netIDOther, string offerstatus, string offer);
	static void OnDialogRequest(ENetPeer* peer, string args);
	static void OnKilled(ENetPeer* peer, int netID);
	static void OnSetFreezeState(ENetPeer* peer, int state, int netID);
	static void OnSetPos(ENetPeer* peer, int netID, int x, int y);
	static void OnFlagMay2019(ENetPeer* peer, int state, int netID);
	static void OnBillboardChange(ENetPeer* peer, int netID); //testing billboards
	static void SendTilePickup(ENetPeer* peer, int itemid, int netID, float x, float y, int itemcount, int itemamount);
	static void OnInvis(ENetPeer* peer, int state, int netID);
	static void OnChangeSkin(ENetPeer* peer, int skinColor, int netID);
	static void SetRespawnPos(ENetPeer* peer, int posX, int posY, int netID);
	static void OnSetBux(ENetPeer* peer, int gems, int accountstate);
	static void OnParticleEffect(ENetPeer* peer, int effect, float x, float y, int delay);
	static void SetHasGrowID(ENetPeer* peer, int status, string username, string password);
	static void SaveShopsItemMoreTimes(int fItemid, int fQuantity, ENetPeer* peer, bool& success);
	static void Ping(ENetPeer* peer);
};
void Player::OnInvis(ENetPeer* peer, int state, int netID) {
	GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnInvis"), state));
	memcpy(p.data + 8, &netID, 4);
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}

void Player::OnTradeStatus(ENetPeer* peer, int netIDOther, string offerstatus, string offer)
{
	GamePacket p = packetEnd(appendString(appendString(appendString(appendInt(appendString(createPacket(), "OnTradeStatus"), netIDOther), ""), offerstatus + "'s offer"), offer));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}
void Player::OnConsoleMessage(ENetPeer* peer, string text)
{
	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), text));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}
ENetPeer* findPeerWithName(string name)
{
	ENetPeer* currentPeer;

	bool found = false;

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;

		if (((PlayerInfo*)(currentPeer->data))->rawName == name) {
			return currentPeer;
		}
	}
	return NULL;
}
string FormatTradeItems(vector<TradeItem> tradeItems)
{
	string fmt;
	for (auto& t : tradeItems)
	{
		fmt += "add_slot|" + to_string(t.id) + "|" + to_string(t.count) + "\n";
	}
	return fmt;
}

string FormatTradeItemsForDialog(vector<TradeItem> tradeItems, bool getting)
{
	if (tradeItems.size() < 1)
	{
		string a = "add_textbox|";
		a += (getting ? "`2" : "`4");
		a += "Nothing!";
		return a;
	}
	string fmt;
	for (auto& t : tradeItems)
	{
		fmt += "add_label_with_icon|small|`o(`w" + to_string(t.count) + "`o) `w" + getItemDef(t.id).name + "``|left|" + to_string(t.id) + "|\n";
	}
	return fmt;
}
string FormatTradeItemsForMessage(vector<TradeItem> tradeItems)
{
	if (tradeItems.size() < 1) return "nothing";
	string fmt;
	for (auto& t : tradeItems)
	{
		if (fmt.size() > 0)
			fmt += ", " + to_string(t.count) + " " + getItemDef(t.id).name + "";
		else
			fmt += to_string(t.count) + " " + getItemDef(t.id).name + "";
		//fmt += "add_label_with_icon|big|`o(`w" + to_string(t.count) + "`o) `w" + getItemDef(t.id).name + "``|left|" + to_string(t.id) + "|\n";
	}
	return fmt;
}
bool DetectTradeConnection(ENetPeer* peer1, ENetPeer* peer2)
{
	PlayerInfo* pinfo = (PlayerInfo*)peer1->data;
	PlayerInfo* pinfo2 = (PlayerInfo*)peer2->data;

	if (pinfo->isWaitingForTrade)
	{
		if (pinfo->isWaitingForTradeWithUserID == pinfo2->userID)
		{
			if (pinfo2->isWaitingForTrade)
			{
				if (pinfo2->isWaitingForTradeWithUserID == pinfo->userID)
				{
					// set both peer's flags
					pinfo->isTrading = true;
					pinfo->isTradingWithUserID = pinfo->isWaitingForTradeWithUserID;
					pinfo->isWaitingForTradeWithUserID = 0;
					pinfo->isTradingWithUserID = pinfo2->userID;
					pinfo->isWaitingForTrade = false;

					pinfo2->isTradingWithUserID = pinfo->userID;
					pinfo2->isTrading = true;
					pinfo2->isTradingWithUserID = pinfo2->isWaitingForTradeWithUserID;
					pinfo2->isWaitingForTradeWithUserID = false;
					pinfo2->isWaitingForTrade = false;

					pinfo->tradeItems.clear();
					pinfo2->tradeItems.clear();

					Players::OnTradeStatus(peer1, pinfo->netID, "`oSelect an item from the inventory.``", "", FormatTradeItems(pinfo->tradeItems) + "\nlocked|0\nreset_locks|1\naccepted|" + to_string(pinfo->isAcceptingTrade) + "\n");
					Players::OnTradeStatus(peer1, pinfo2->netID, "`w" + pinfo2->displayName + "`o's offer.``", "", FormatTradeItems(pinfo2->tradeItems) + "\nlocked|0\naccepted|" + to_string(pinfo2->isAcceptingTrade) + "\n");

					Players::OnTradeStatus(peer2, pinfo2->netID, "`oSelect an item from the inventory.``", "", FormatTradeItems(pinfo2->tradeItems) + "\nlocked|0\naccepted|" + to_string(pinfo2->isAcceptingTrade) + "\n");
					Players::OnTradeStatus(peer2, pinfo->netID, "`w" + pinfo->displayName + "`o's offer.``", "", FormatTradeItems(pinfo->tradeItems) + "\nlocked|0\nreset_locks|1\naccepted|" + to_string(pinfo->isAcceptingTrade) + "\n");
					return true;
				}
			}
		}
	}
	return false;
}
void SendGamePacketEveryoneInWorld(ENetPeer* peer, GamePacket* p)
{
	ENetPacket* packet1 = enet_packet_create(p->data,
		p->len,
		ENET_PACKET_FLAG_RELIABLE);
	ENetPeer* currentPeer;

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer))
		{
			enet_peer_send(currentPeer, 0, packet1);
		}
	}
	delete p->data;
}
void SendCancelTrade(ENetPeer* peer, string overlay = "That player is busy.")
{
	try {
		cout << "Trade cancelled." << endl;
		PlayerInfo* pinfo = (PlayerInfo*)peer->data;
		Players::OnForceTradeEnd(peer); // just in case
		if (overlay != "") {
			Player::OnTextOverlay(peer, overlay);
		}
		pinfo->isTrading = false;
		pinfo->isAcceptingTrade = false;
		pinfo->isTradingWithUserID = 0;
		pinfo->isWaitingForTradeWithUserID = 0;
		pinfo->isWaitingForTrade = false;
	}
	catch (...) {
		cout << "error in void sendcanceltrade";
	}
}
void UpdateTradeStatus(ENetPeer* peer1, int userID, int showOverlay = 0, bool doSelfToo = true)
{
	cout << "Trade status updated." << endl;

	PlayerInfo* pinfo2 = NULL;
	PlayerInfo* pinfo = (PlayerInfo*)peer1->data;
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer1, currentPeer)) {
			if (pinfo->isTradingWithUserID != ((PlayerInfo*)(currentPeer->data))->userID || ((PlayerInfo*)(peer1->data))->userID != ((PlayerInfo*)(currentPeer->data))->isTradingWithUserID) {
				continue;
				break;
			}
			if (pinfo->isTradingWithUserID == ((PlayerInfo*)(currentPeer->data))->userID || ((PlayerInfo*)(peer1->data))->userID == ((PlayerInfo*)(currentPeer->data))->isTradingWithUserID) {
				pinfo2 = (PlayerInfo*)currentPeer->data;
				Players::OnTradeStatus(currentPeer, pinfo2->netID, "`oSelect an item from the inventory.``", "", FormatTradeItems(pinfo2->tradeItems) + "\nlocked|0\nreset_locks|1\naccepted|" + to_string(pinfo2->isAcceptingTrade) + "\n");
				Players::OnTradeStatus(currentPeer, pinfo->netID, "`o" + pinfo->displayName + "`o's offer.``", "", FormatTradeItems(pinfo->tradeItems) + "\nlocked|0\naccepted|" + to_string(pinfo->isAcceptingTrade) + "\n");
				Player::OnTextOverlay(currentPeer, "The deal has changed");
				if (doSelfToo) {
					Players::OnTradeStatus(peer1, pinfo->netID, "`o" + pinfo->displayName + "`o's offer.``", "", FormatTradeItems(pinfo->tradeItems) + "\nlocked|0\naccepted|" + to_string(pinfo->isAcceptingTrade) + "\n");
					Player::OnTextOverlay(peer1, "The deal has changed");
				}
				break;
			}
		}
	}
}
void UpdateTradeAcceptedStatus(ENetPeer* peer1, int showOverlay = 0)
{
	cout << "Trade accepted status updated." << endl;
	PlayerInfo* pinfo = (PlayerInfo*)peer1->data;
	ENetPeer* currentPeer;

	bool found = false;

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		PlayerInfo* pinfo2 = (PlayerInfo*)currentPeer->data;
		if (pinfo->isTradingWithUserID == pinfo2->userID) {

			Players::OnTradeStatus(currentPeer, pinfo->netID, "`o" + pinfo->displayName + "`o's offer.``", "", FormatTradeItems(pinfo->tradeItems) + "\nlocked|1\naccepted|" + to_string(pinfo->isAcceptingTrade) + "\n");
			Players::OnTradeStatus(currentPeer, pinfo2->netID, "`o" + pinfo2->displayName + "`o's offer.``", "", FormatTradeItems(pinfo2->tradeItems) + "\nlocked|1\naccepted|" + to_string(pinfo2->isAcceptingTrade) + "\n");
			break;
		}
	}
	//Player::OnTradeStatus(peer1, pinfo->netID, "`o" + pinfo->displayName + "`o's offer.``", "", FormatTradeItems(pinfo->tradeItems) + "\nlocked|1\naccepted|" + to_string(pinfo->isAcceptingTrade) + "\n");
}
int WaitForTradeWithThisPlayer(ENetPeer* peer1, ENetPeer* peer2)
{
	if (peer1 == peer2) return -2;
	PlayerInfo* pinfo = (PlayerInfo*)peer1->data;
	PlayerInfo* pinfo2 = (PlayerInfo*)peer2->data;
	if (pinfo->currentWorld != pinfo2->currentWorld) return -3;
	if (pinfo2->isTrading) return -1;
	pinfo->isTrading = false;
	pinfo->isWaitingForTrade = true;
	pinfo->isWaitingForTradeWithUserID = pinfo2->userID;
	Players::OnStartTrade(peer1, pinfo2->displayName, pinfo2->netID);
	if (!DetectTradeConnection(peer1, peer2))
	{
		Player::OnConsoleMessage(peer2, "`#TRADE ALERT`o: " + pinfo->displayName + " `owants to trade with you! To accept, type `w/trade " + pinfo->rawName + "`o.");
		Player::PlayAudio(peer2, "audio/cash_register.wav", 0);
	}
	return 0;
}
void Player::SaveShopsItemMoreTimes(int fItemid, int fQuantity, ENetPeer* peer, bool& success)
{
	size_t invsizee = ((PlayerInfo*)(peer->data))->currentInventorySize;
	bool invfull = false;
	bool alreadyhave = false;


	if (((PlayerInfo*)(peer->data))->inventory.items.size() == invsizee) {


		GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`4Whoops!|left|1048|\nadd_spacer|small|\nadd_textbox|`oSoory! Your inventory is full! You can purchase an inventory upgrade in the shop.|\nadd_spacer|small|\nadd_button|close|`5Close|0|0|"));
		ENetPacket* packet = enet_packet_create(ps.data,
			ps.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete ps.data;


		alreadyhave = true;
	}

	bool isFullStock = false;
	bool isInInv = false;
	for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
	{

		if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == fItemid && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount >= 200) {


			GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), ""));
			ENetPacket* packet = enet_packet_create(ps.data,
				ps.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete ps.data;


			isFullStock = true;
		}

		if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == fItemid && ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount < 200)	isInInv = true;

	}

	if (isFullStock == true || alreadyhave == true)
	{
		success = false;
	}
	else
	{
		success = true;

		std::ifstream iffff("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");

		json jj;

		if (iffff.fail()) {
			iffff.close();


		}
		if (iffff.is_open()) {


		}

		iffff >> jj; //load


		std::ofstream oo("inventory/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
		if (!oo.is_open()) {
			cout << GetLastError() << endl;
			_getch();
		}

		//jj["items"][aposition]["aposition"] = aposition;

		if (isInInv == false)
		{

			for (int i = 0; i < ((PlayerInfo*)(peer->data))->currentInventorySize; i++)
			{
				int itemid = jj["items"][i]["itemid"];
				int quantity = jj["items"][i]["quantity"];

				if (itemid == 0 && quantity == 0)
				{
					jj["items"][i]["itemid"] = fItemid;
					jj["items"][i]["quantity"] = fQuantity;
					break;
				}

			}
			oo << jj << std::endl;


			InventoryItem item;
			item.itemID = fItemid;
			item.itemCount = fQuantity;
			((PlayerInfo*)(peer->data))->inventory.items.push_back(item);

			sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
		}
		else
		{
			for (int i = 0; i < ((PlayerInfo*)(peer->data))->currentInventorySize; i++)
			{
				int itemid = jj["items"][i]["itemid"];
				int quantity = jj["items"][i]["quantity"];

				if (itemid == fItemid)
				{
					jj["items"][i]["quantity"] = quantity + fQuantity;
					break;
				}

			}
			oo << jj << std::endl;


			for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
			{
				if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == fItemid)
				{
					((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount += fQuantity;
					sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
				}
			}

		}
	}
}
void OnStorePurchaseResults(ENetPeer* peer, string text)
{
	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), text));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}
void Player::OnSetBux(ENetPeer* peer, int gems, int accountstate)
{
	GamePacket p = packetEnd(appendInt(appendInt(appendString(createPacket(), "OnSetBux"), gems), accountstate));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, packet);
	delete p.data;
}

void Player::OnNameChanged(ENetPeer* peer, int netID, string name)
{
	GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), "`0`0" + name));
	memcpy(p3.data + 8, &netID, 4);
	ENetPacket* packet3 = enet_packet_create(p3.data,
		p3.len,
		ENET_PACKET_FLAG_RELIABLE);
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer))
		{
			enet_peer_send(currentPeer, 0, packet3);
		}
	}
	delete p3.data;
}

void Player::PlayAudio(ENetPeer* peer, string audioFile, int delayMS)
{
	string text = "action|play_sfx\nfile|" + audioFile + "\ndelayMS|" + to_string(delayMS) + "\n";
	BYTE* data = new BYTE[5 + text.length()];
	BYTE zero = 0;
	int type = 3;
	memcpy(data, &type, 4);
	memcpy(data + 4, text.c_str(), text.length());
	memcpy(data + 4 + text.length(), &zero, 1);
	ENetPacket* packet = enet_packet_create(data,
		5 + text.length(),
		ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, packet);
	delete data;
}
void Player::OnFailedToEnterWorld(ENetPeer* peer) {
	GamePacket p = packetEnd(appendIntx(appendString(createPacket(), "OnFailedToEnterWorld"), 1));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}

void Player::OnTextOverlay(ENetPeer* peer, string text) {
	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), text));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}

void Player::OnKilled(ENetPeer* peer, int netID) {
	GamePacket p = packetEnd(appendString(createPacket(), "OnKilled"));
	memcpy(p.data + 8, &netID, 4);
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}
void Player::OnTalkBubble(ENetPeer* peer, int netID, string text, int chatColor, bool isOverlay)
{
	if (isOverlay == true) {
		GamePacket p = packetEnd(appendIntx(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"),
			((PlayerInfo*)(peer->data))->netID), text), chatColor), 1));

		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}
	else
	{
		GamePacket p = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"),
			((PlayerInfo*)(peer->data))->netID), text), chatColor));

		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}
}
void Player::SetRespawnPos(ENetPeer* peer, int posX, int posY, int netID) {
	GamePacket p22 = packetEnd(appendInt(appendString(createPacket(), "SetRespawnPos"), posX + posY)); // (world->width * posY)
	memcpy(p22.data + 8, &netID, 4);
	ENetPacket* packet22 = enet_packet_create(p22.data,
		p22.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet22);
	delete p22.data;
}
void updateWater(ENetPeer* peer, int foreground, int x, int y, string text, int background)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	int hmm = 8, wot = text.length(), lol = 0x04000000, wut = 5;
	int yeh = hmm + 3 + 1, idk = 15 + wot, lmao = -1, yey = 2; //idk = text_len + 15, wut = type(?), wot = text_len, yey = len of text_len
	int ok = 52 + idk;
	int kek = ok + 4, yup = ok - 8 - idk;
	int thonk = 4, magic = 56, wew = ok + 5 + 4;
	int wow = magic + 4 + 5;
	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	memcpy(data, &wut, thonk);
	memcpy(data + yeh, &hmm, thonk); //read discord
	memcpy(data + yup, &x, 4);
	memcpy(data + yup + 4, &y, 4);
	memcpy(data + 4 + yup + 4, &idk, thonk);
	memcpy(data + magic, &foreground, yey);
	memcpy(data + magic + 2, &background, yey); // gai?
	memcpy(data + thonk + magic, &lol, thonk);
	memcpy(data + magic + 4 + thonk, &yey, 1);
	memcpy(data + wow, &wot, yey); //data + wow = text_len
	memcpy(data + yey + wow, text.c_str(), wot); //data + text_len_len + text_len_offs = text
	memcpy(data + ok, &lmao, thonk); //end ?
	memcpy(p->data, &thonk, thonk);
	memcpy((char*)p->data + thonk, data, kek); //kek = data_len
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, p);
		}
	}
	delete data;
}
void updateFire(ENetPeer* peer, int foreground, int x, int y, string text, int background)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	int hmm = 8, wot = text.length(), lol = 0x10000000, wut = 5;
	int yeh = hmm + 3 + 1, idk = 15 + wot, lmao = -1, yey = 2; //idk = text_len + 15, wut = type(?), wot = text_len, yey = len of text_len
	int ok = 52 + idk;
	int kek = ok + 4, yup = ok - 8 - idk;
	int thonk = 4, magic = 56, wew = ok + 5 + 4;
	int wow = magic + 4 + 5;
	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	memcpy(data, &wut, thonk);
	memcpy(data + yeh, &hmm, thonk); //read discord
	memcpy(data + yup, &x, 4);
	memcpy(data + yup + 4, &y, 4);
	memcpy(data + 4 + yup + 4, &idk, thonk);
	memcpy(data + magic, &foreground, yey);
	memcpy(data + magic + 2, &background, yey); // gai?
	memcpy(data + thonk + magic, &lol, thonk);
	memcpy(data + magic + 4 + thonk, &yey, 1);
	memcpy(data + wow, &wot, yey); //data + wow = text_len
	memcpy(data + yey + wow, text.c_str(), wot); //data + text_len_len + text_len_offs = text
	memcpy(data + ok, &lmao, thonk); //end ?
	memcpy(p->data, &thonk, thonk);
	memcpy((char*)p->data + thonk, data, kek); //kek = data_len
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, p);
		}
	}
	delete data;
}
void sendState(ENetPeer* peer) {
	//return; // TODO
	PlayerInfo* info = ((PlayerInfo*)(peer->data));
	int netID = info->netID;
	ENetPeer* currentPeer;
	int state = getState(info);
	int pro = getCharstat(info);
	int statey = 0;
	if (info->cloth_hand == 6028) statey = 1024;
	if (info->cloth_hand == 6262) statey = 8192;
	if (info->haveGrowId == false) statey = 50000;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			PlayerMoving data;
			data.packetType = 0x14;
			data.characterState = statey;
			data.x = 1000;
			data.y = 100;
			data.punchX = 0;
			data.punchY = 0;
			data.XSpeed = 300;
			data.YSpeed = 600;
			data.netID = netID;
			data.plantingTree = state;
			BYTE* raw = packPlayerMoving(&data);
			int var = info->peffect; // punch effect
			memcpy(raw + 1, &var, 3);
			SendPacketRaw(4, raw, 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	// TODO
}
void sendClothes(ENetPeer* peer)
{
	ENetPeer* currentPeer;
	GamePacket p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), ((PlayerInfo*)(peer->data))->cloth_hair, ((PlayerInfo*)(peer->data))->cloth_shirt, ((PlayerInfo*)(peer->data))->cloth_pants), ((PlayerInfo*)(peer->data))->cloth_feet, ((PlayerInfo*)(peer->data))->cloth_face, ((PlayerInfo*)(peer->data))->cloth_hand), ((PlayerInfo*)(peer->data))->cloth_back, ((PlayerInfo*)(peer->data))->cloth_mask, ((PlayerInfo*)(peer->data))->cloth_necklace), ((PlayerInfo*)(peer->data))->skinColor), ((PlayerInfo*)(peer->data))->cloth_ances, 0.0f, 0.0f));
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer))
		{
			string text = "action|play_sfx\nfile|audio/change_clothes.wav\ndelayMS|0\n";
			BYTE* data = new BYTE[5 + text.length()];
			BYTE zero = 0;
			int type = 3;
			memcpy(data, &type, 4);
			memcpy(data + 4, text.c_str(), text.length());
			memcpy(data + 4 + text.length(), &zero, 1);

			ENetPacket* packet2 = enet_packet_create(data,
				5 + text.length(),
				ENET_PACKET_FLAG_RELIABLE);

			enet_peer_send(currentPeer, 0, packet2);
			delete data;


			//enet_host_flush(server);

			memcpy(p3.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4); // ffloor
			ENetPacket* packet3 = enet_packet_create(p3.data,
				p3.len,
				ENET_PACKET_FLAG_RELIABLE);

			enet_peer_send(currentPeer, 0, packet3);

		}
	}

	std::ifstream ifff("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");

	PlayerInfo* p = ((PlayerInfo*)(peer->data));

	string username = PlayerDB::getProperName(p->rawName);



	if (ifff.fail()) {
		ifff.close();


	}
	if (ifff.is_open()) {
	}
	json j;
	ifff >> j; //load

	int gems = p->gem;
	int rubble = p->ban;
	int wls = p->wls;
	int clothback = p->cloth_back;
	int clothhand = p->cloth_hand;
	int clothface = p->cloth_face;
	int clothhair = p->cloth_hair;
	int clothfeet = p->cloth_feet;
	int clothpants = p->cloth_pants;
	int clothneck = p->cloth_necklace;
	int clothshirt = p->cloth_shirt;
	int clothmask = p->cloth_mask;
	int clothances = p->cloth_ances;

	j["ClothBack"] = clothback;
	j["ClothHand"] = clothhand;
	j["ClothFace"] = clothface;
	j["ClothShirt"] = clothshirt;
	j["ClothPants"] = clothpants;
	j["ClothNeck"] = clothneck;
	j["ClothHair"] = clothhair;
	j["ClothFeet"] = clothfeet;
	j["ClothMask"] = clothmask;
	j["ClothAnces"] = clothances;
	j["puncheffect"] = p->peffect;
	j["gems"] = gems;
	j["ban"] = rubble;
	j["wls"] = wls;


	//j["friends"] = ((PlayerInfo*)(peer->data))->friendinfo;


	std::ofstream o("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json"); //save
	if (!o.is_open()) {
		cout << GetLastError() << endl;
		_getch();
	}

	o << j << std::endl;
}
bool replace(std::string& str, const std::string& from, const std::string& to) {
	size_t start_pos = str.find(from);
	if (start_pos == std::string::npos)
		return false;
	str.replace(start_pos, from.length(), to);
	return true;
}
int FixCountItem(int number)
{
	if (number == -128)
	{
		return 128;
	}
	else if (number == -127)
	{
		return 129;
	}
	else if (number == -126)
	{
		return 130;
	}
	else if (number == -125)
	{
		return 131;
	}
	else if (number == -124)
	{
		return 132;
	}
	else if (number == -123)
	{
		return 133;
	}
	else if (number == -122)
	{
		return 134;
	}
	else if (number == -121)
	{
		return 135;
	}
	else if (number == -120)
	{
		return 136;
	}
	else if (number == -119)
	{
		return 137;
	}
	else if (number == -118)
	{
		return 138;
	}
	else if (number == -117)
	{
		return 139;
	}
	else if (number == -116)
	{
		return 140;
	}
	else if (number == -115)
	{
		return 141;
	}
	else if (number == -114)
	{
		return 142;
	}
	else if (number == -113)
	{
		return 143;
	}
	else if (number == -112)
	{
		return 144;
	}
	else if (number == -111)
	{
		return 145;
	}
	else if (number == -110)
	{
		return 146;
	}
	else if (number == -109)
	{
		return 147;
	}
	else if (number == -108)
	{
		return 148;
	}
	else if (number == -107)
	{
		return 149;
	}
	else if (number == -106)
	{
		return 150;
	}
	else if (number == -105)
	{
		return 151;
	}
	else if (number == -104)
	{
		return 152;
	}
	else if (number == -103)
	{
		return 153;
	}
	else if (number == -102)
	{
		return 154;
	}
	else if (number == -101)
	{
		return 155;
	}
	else if (number == -100)
	{
		return 156;
	}
	else if (number == -99)
	{
		return 157;
	}
	else if (number == -98)
	{
		return 158;
	}
	else if (number == -97)
	{
		return 159;
	}
	else if (number == -96)
	{
		return 160;
	}
	else if (number == -95)
	{
		return 161;
	}
	else if (number == -94)
	{
		return 162;
	}
	else if (number == -93)
	{
		return 163;
	}
	else if (number == -92)
	{
		return 164;
	}
	else if (number == -91)
	{
		return 165;
	}
	else if (number == -90)
	{
		return 166;
	}
	else if (number == -89)
	{
		return 167;
	}
	else if (number == -88)
	{
		return 168;
	}
	else if (number == -87)
	{
		return 169;
	}
	else if (number == -86)
	{
		return 170;
	}
	else if (number == -85)
	{
		return 171;
	}
	else if (number == -84)
	{
		return 172;
	}
	else if (number == -83)
	{
		return 173;
	}
	else if (number == -82)
	{
		return 174;
	}
	else if (number == -81)
	{
		return 175;
	}
	else if (number == -80)
	{
		return 176;
	}
	else if (number == -79)
	{
		return 177;
	}
	else if (number == -78)
	{
		return 178;
	}
	else if (number == -77)
	{
		return 179;
	}
	else if (number == -76)
	{
		return 180;
	}
	else if (number == -75)
	{
		return 181;
	}
	else if (number == -74)
	{
		return 182;
	}
	else if (number == -73)
	{
		return 183;
	}
	else if (number == -72)
	{
		return 184;
	}
	else if (number == -71)
	{
		return 185;
	}
	else if (number == -70)
	{
		return 186;
	}
	else if (number == -69)
	{
		return 187;
	}
	else if (number == -68)
	{
		return 188;
	}
	else if (number == -67)
	{
		return 189;
	}
	else if (number == -66)
	{
		return 190;
	}
	else if (number == -65)
	{
		return 191;
	}
	else if (number == -64)
	{
		return 192;
	}
	else if (number == -63)
	{
		return 193;
	}
	else if (number == -62)
	{
		return 194;
	}
	else if (number == -61)
	{
		return 195;
	}
	else if (number == -60)
	{
		return 196;
	}
	else if (number == -59)
	{
		return 197;
	}
	else if (number == -58)
	{
		return 198;
	}
	else if (number == -57)
	{
		return 199;
	}
	else if (number == -56)
	{
		return 200;
	}
}
void PUTANGINA(ENetPeer* peer)
{
	try {
		if (((PlayerInfo*)(peer->data))->haveGrowId == true) {
			std::ifstream ifff("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");

			PlayerInfo* p5 = ((PlayerInfo*)(peer->data));

			string username = PlayerDB::getProperName(p5->rawName);



			if (ifff.fail()) {
				ifff.close();


			}
			if (ifff.is_open()) {
			}
			json j;
			ifff >> j; //load
			j["ClothBack"] = ((PlayerInfo*)(peer->data))->cloth_back;
			j["ClothHand"] = ((PlayerInfo*)(peer->data))->cloth_hand;
			j["ClothFace"] = ((PlayerInfo*)(peer->data))->cloth_face;
			j["ClothHair"] = ((PlayerInfo*)(peer->data))->cloth_hair;
			j["ClothFeet"] = ((PlayerInfo*)(peer->data))->cloth_feet;
			j["ClothPants"] = ((PlayerInfo*)(peer->data))->cloth_pants;
			j["ClothNeck"] = ((PlayerInfo*)(peer->data))->cloth_necklace;
			j["ClothShirt"] = ((PlayerInfo*)(peer->data))->cloth_shirt;
			j["ClothMask"] = ((PlayerInfo*)(peer->data))->cloth_mask;
			j["ClothAnces"] = ((PlayerInfo*)(peer->data))->cloth_ances;
			j["level"] = ((PlayerInfo*)(peer->data))->level;
			j["xp"] = ((PlayerInfo*)(peer->data))->xp;
			j["skinColor"] = ((PlayerInfo*)(peer->data))->skinColor;
			j["CanDoubleJump"] = ((PlayerInfo*)(peer->data))->canDoubleJump;
			j["gems"] = ((PlayerInfo*)(peer->data))->gem;
			j["notebook"] = ((PlayerInfo*)(peer->data))->notebook;

			std::ofstream o("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json"); //save
			if (!o.is_open()) {
				cout << GetLastError() << endl;
				_getch();
			}

			o << j << std::endl;
		}
	}
	catch (...) {
		player::disconnect(peer);
	}
}
void savejson(ENetPeer* peer)
{
	using namespace std::chrono;

	while (1)
	{
		Sleep(300); // each 1 minute check
		if (peer->data == NULL) break;
		if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;

		if (((PlayerInfo*)(peer->data))->isDuctaped == true)
		{
			long kiekDar = ((PlayerInfo*)(peer->data))->lastMuted - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			long min = kiekDar / 300;
			ofstream saveMuteTime("timemuted/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->rawName) + ".txt");
			saveMuteTime << min;
			saveMuteTime.close();
			if (((PlayerInfo*)(peer->data))->lastMuted < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
			{
				if (std::experimental::filesystem::exists("timemuted/" + ((PlayerInfo*)(peer->data))->rawName + ".txt"))
				{
					Player::OnTextOverlay(peer, "`^Your `4mute `^has expired, please don't break `4rules `^anymore!");
					Player::OnConsoleMessage(peer, "`^Your `4mute `^has expired, please don't break `4rules `^anymore!");
					((PlayerInfo*)(peer->data))->taped = false;
					((PlayerInfo*)(peer->data))->isDuctaped = false;
					sendState(peer);
					sendClothes(peer);
					remove(("timemuted/" + ((PlayerInfo*)(peer->data))->rawName + ".txt").c_str());
				}
			}
		}
		if (((PlayerInfo*)(peer->data))->cloth_face == 3774) {
			((PlayerInfo*)(peer->data))->noEyes = true;
			sendState(peer);
		}
		else {
			((PlayerInfo*)(peer->data))->noEyes = false;
			sendState(peer);
		}
		if (((PlayerInfo*)(peer->data))->cloth_hand == 7558) {
			((PlayerInfo*)(peer->data))->isShining = true;
			sendState(peer);
		}
		else {
			((PlayerInfo*)(peer->data))->isShining = false;
			sendState(peer);
		}
		if (((PlayerInfo*)(peer->data))->cloth_back != 0) {
			((PlayerInfo*)(peer->data))->canDoubleJump = true;
			sendState(peer);
		}

	}
}
void sendTileData(ENetPeer* peer, int x, int y, int visual, uint16_t fgblock, uint16_t bgblock, string tiledata) {
	PlayerMoving pmov;
	pmov.packetType = 5;
	pmov.characterState = 0;
	pmov.x = 0;
	pmov.y = 0;
	pmov.XSpeed = 0;
	pmov.YSpeed = 0;
	pmov.plantingTree = 0;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = 0;

	string packetstr;
	packetstr.resize(4);
	packetstr[0] = 4;
	packetstr += packPlayerMoving2(&pmov);
	packetstr[16] = 8;
	packetstr.resize(packetstr.size() + 4);
	STRINT(packetstr, 52 + 4) = tiledata.size() + 4;
	STR16(packetstr, 56 + 4) = fgblock;
	STR16(packetstr, 58 + 4) = bgblock;
	packetstr += tiledata;

	ENetPacket* packet = enet_packet_create(&packetstr[0],
		packetstr.length(),
		ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, packet);
}
#include "packet_initialize/display_block.h"

void UpdateDisplayVisuals(ENetPeer* peer, int foreground, int x, int y, int background, int itemid, bool sendPacketToEveryone = true)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = 0x56;
	sign.y = 0x15;
	sign.punchX = 0x56;
	sign.punchY = 0x15;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = 0x0b82;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	int plength = 73;
	BYTE* raw = new BYTE[plength];
	memset(raw, 0, plength);
	InitializePacketWithDisplayBlock(raw);

	memcpy(raw + 44, &x, sizeof(int));
	memcpy(raw + 48, &y, sizeof(int));
	memcpy(raw + 56, &foreground, sizeof(short));
	memcpy(raw + 58, &background, sizeof(short));
	memcpy(raw + 65, &itemid, sizeof(int));

	ENetPacket* p = enet_packet_create(0, plength + 4, ENET_PACKET_FLAG_RELIABLE);
	int four = 4;
	memcpy(p->data, &four, sizeof(int));
	memcpy((char*)p->data + 4, raw, plength);

	if (sendPacketToEveryone)
	{
		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				enet_peer_send(currentPeer, 0, p);
			}
		}
		delete raw;
	}
	else
	{
		enet_peer_send(peer, 0, p);
		delete raw;
	}
}

void UpdateUnlockedDoorVisuals(ENetPeer* peer, int foreground, int x, int y, int background, string text, bool sendPacketToEveryone = true, int visuals = 0)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = 0x56;
	sign.y = 0x15;
	sign.punchX = 0x56;
	sign.punchY = 0x15;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = 0x0b82;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	BYTE a = 0x00; // 0x08 for locked
	BYTE b = 0xeb; // 0x98 for locked
	uint32_t c = 0xfdfdfdfd;
	short textLen = (short)text.size();
	int plength = 73 + textLen;
	BYTE* raw = new BYTE[plength];
	memset(raw, 0, plength);
	InitializePacketWithUnlockedDoor(raw);
	memcpy(raw + 44, &x, sizeof(int));
	memcpy(raw + 48, &y, sizeof(int));
	memcpy(raw + 56, &foreground, sizeof(short));
	memcpy(raw + 58, &background, sizeof(short));
	memcpy(raw + 60, &visuals, sizeof(int));
	memcpy(raw + 65, &textLen, sizeof(short));
	memcpy(raw + 67, text.c_str(), textLen);
	memcpy(raw + 67 + textLen, &a, 1);
	memcpy(raw + 68 + textLen, &b, 1);
	memcpy(raw + 69 + textLen, &c, 4);

	ENetPacket* p = enet_packet_create(0, plength + 4, ENET_PACKET_FLAG_RELIABLE);
	int four = 4;
	memcpy(p->data, &four, sizeof(int));
	memcpy((char*)p->data + 4, raw, plength);

	if (sendPacketToEveryone)
	{
		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				enet_peer_send(currentPeer, 0, p);
			}
		}
		delete raw;
	}
	else
	{
		enet_peer_send(peer, 0, p);
		delete raw;
	}
}


void UpdateLockedDoorVisuals(ENetPeer* peer, int foreground, int x, int y, int background, string text, bool sendPacketToEveryone = true, int visuals = 0)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = 0x56;
	sign.y = 0x15;
	sign.punchX = 0x56;
	sign.punchY = 0x15;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = 0x0b82;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	BYTE a = 0x08; // 0x00 for unlocked
	BYTE b = 0x98; // 0xeb for unlocked
	uint32_t c = 0xfdfdfdfd;
	short textLen = (short)text.size();
	int plength = 73 + textLen;
	BYTE* raw = new BYTE[plength];
	memset(raw, 0, plength);
	InitializePacketWithUnlockedDoor(raw);
	memcpy(raw + 44, &x, sizeof(int));
	memcpy(raw + 48, &y, sizeof(int));
	memcpy(raw + 56, &foreground, sizeof(short));
	memcpy(raw + 58, &background, sizeof(short));
	memcpy(raw + 60, &visuals, sizeof(int));
	memcpy(raw + 65, &textLen, sizeof(short));
	memcpy(raw + 67, text.c_str(), textLen);
	memcpy(raw + 67 + textLen, &a, 1);
	memcpy(raw + 68 + textLen, &b, 1);
	memcpy(raw + 69 + textLen, &c, 4);

	ENetPacket* p = enet_packet_create(0, plength + 4, ENET_PACKET_FLAG_RELIABLE);
	int four = 4;
	memcpy(p->data, &four, sizeof(int));
	memcpy((char*)p->data + 4, raw, plength);

	if (sendPacketToEveryone)
	{
		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				enet_peer_send(currentPeer, 0, p);
			}
		}
		delete raw;
	}
	else
	{
		enet_peer_send(peer, 0, p);
		delete raw;
	}
}

void UpdateTreeVisuals(ENetPeer* peer, int foreground, int x, int y, int background, int fruitCount) {
	//int val = 1 + rand() % 4;
	string text = "tree";
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	int hmm = 8;
	int text_len = 4;
	int zero = 0;
	int packetType = 5;
	int yeh = hmm + 3 + 1;
	int idk = 15 + text_len;
	int blockState = 0;
	int bubble_type = 4;
	int ok = 52 + idk;
	int packetSize = ok + 4;
	int yup = ok - 8 - idk;
	int four = 4;
	int magic = 56;
	int wew = ok + 5 + 4;
	int wow = magic + 4 + 5;

	short a = (short)fruitCount;
	int treedata = 0x0002000a;

	BYTE* data = new BYTE[packetSize];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	memset(data, 0, packetSize);

	memcpy(data, &packetType, sizeof(int));
	memcpy(data + yeh, &hmm, sizeof(int));
	memcpy(data + yup, &x, sizeof(int));
	memcpy(data + yup + 4, &y, sizeof(int));
	memcpy(data + 4 + yup + 4, &idk, sizeof(int));
	memcpy(data + magic, &foreground, sizeof(short));
	memcpy(data + four + magic, &background, sizeof(int));
	memcpy(data + magic + 4 + four, &bubble_type, sizeof(byte));
	memcpy(data + wow, &text_len, sizeof(short));
	memcpy(data + 2 + wow, &treedata, text_len);
	memcpy(data + ok, &blockState, sizeof(int));
	memcpy(p->data, &four, four);

	memcpy((char*)p->data + four, data, packetSize);
	enet_peer_send(peer, 0, p);

	delete data;
}
void UpdateMessageVisuals(ENetPeer* peer, int foreground, int x, int y, string text, int background, int bubbleType_ = 2, bool sendPacketToEveryone = true, int blockState = 0)
{
	if (text.size() > 100) return;
	// setting tile packet
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	// hopefully the magic :/
	int hmm = 8, textLen = text.size(), PacketType = 5;
	int yeh = hmm + 3 + 1, idk = 15 + textLen, endMarker = -1, sizeofshort = 2;
	int bubbleType = bubbleType_;
	int ok = 52 + idk;
	int kek = ok + 4, yup = ok - 8 - idk;
	int sizeofint = 4, magic = 56, wew = ok + 5 + 4;
	int wow = magic + 4 + 5;
	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	//MEMCPY DESTINATION					SOURCE			SIZE
	memcpy(data, &PacketType, sizeof(int));
	memcpy(data + yeh, &hmm, sizeof(int));
	memcpy(data + yup, &x, sizeof(int));
	memcpy(data + yup + 4, &y, sizeof(int));
	memcpy(data + 4 + yup + 4, &idk, sizeof(int));
	memcpy(data + magic, &foreground, sizeof(short));
	memcpy(data + magic + 2, &background, sizeof(short));
	memcpy(data + sizeofint + magic, &blockState, sizeof(int));
	memcpy(data + magic + 4 + sizeofint, &bubbleType, sizeof(byte));
	memcpy(data + wow, &textLen, sizeof(short));
	memcpy(data + sizeofshort + wow, text.c_str(), textLen);
	memcpy(data + ok, &endMarker, sizeof(int));
	memcpy(p->data, &sizeofint, sizeof(int));
	memcpy((char*)p->data + sizeofint, data, kek);

	if (sendPacketToEveryone)
	{
		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				enet_peer_send(currentPeer, 0, p);
			}
		}
		delete data;
	}
	else
	{
		enet_peer_send(peer, 0, p);
		delete data;
	}
}
void UpdateVisualsForBlock(ENetPeer* peer, bool forEveryone, int x, int y, WorldInfo* worldInfo, bool useLockId = true)
{
	if (!worldInfo) return;

	int i = y * worldInfo->width + x;

	int blockStateFlags = 0;


	if (worldInfo->items[i].flipped)
		blockStateFlags |= 0x00200000;
	if (worldInfo->items[i].water)
		blockStateFlags |= 0x04000000;
	if (worldInfo->items[i].glue)
		blockStateFlags |= 0x08000000;
	if (worldInfo->items[i].fire)
		blockStateFlags |= 0x10000000;
	if (worldInfo->items[i].red)
		blockStateFlags |= 0x20000000;
	if (worldInfo->items[i].green)
		blockStateFlags |= 0x40000000;
	if (worldInfo->items[i].blue)
		blockStateFlags |= 0x80000000;




	else if (getItemDef(worldInfo->items[i].foreground).blockType == BlockTypes::MAIN_DOOR)
	{
		UpdateUnlockedDoorVisuals(peer, worldInfo->items[i].foreground, x, y, worldInfo->items[i].background, "EXIT", forEveryone, blockStateFlags);
	}

	else if (worldInfo->items[i].foreground == 2946)
	{

		UpdateDisplayVisuals(peer, worldInfo->items[i].foreground, x, y, worldInfo->items[i].background, worldInfo->items[i].intdata);
	}
	else if (worldInfo->items[i].foreground % 2 == 1)
	{
		UpdateTreeVisuals(peer, worldInfo->items[i].foreground, x, y, worldInfo->items[i].background, 3);
	}
	else if (blockStateFlags != 0)
	{
		UpdateMessageVisuals(peer, worldInfo->items[i].foreground, x, y, "", worldInfo->items[i].background, 0, forEveryone, blockStateFlags);
	}
}




void playerRespawn(ENetPeer* peer, bool isDeadByTile) {
	int netID = ((PlayerInfo*)(peer->data))->netID;
	if (isDeadByTile == false) {
		Player::OnKilled(peer, ((PlayerInfo*)(peer->data))->netID);
	}
	GamePacket p2x = packetEnd(appendInt(appendString(createPacket(), "OnSetFreezeState"), 0));
	memcpy(p2x.data + 8, &netID, 4);
	int respawnTimeout = 2000;
	int deathFlag = 0x19;
	memcpy(p2x.data + 24, &respawnTimeout, 4);
	memcpy(p2x.data + 56, &deathFlag, 4);
	ENetPacket* packet2x = enet_packet_create(p2x.data,
		p2x.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet2x);
	delete p2x.data;
	GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetFreezeState"), 2));
	memcpy(p5.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	ENetPacket* packet5 = enet_packet_create(p5.data,
		p5.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet5);
	GamePacket p2;
	WorldInfo* world = getPlyersWorld(peer);
	int x = 3040;
	int y = 736;

	if (!world) return;

	for (int i = 0; i < world->width * world->height; i++)
	{
		if (world->items[i].foreground == 6) {
			x = (i % world->width) * 32;
			y = (i / world->width) * 32;
		}
	}
	if (((PlayerInfo*)(peer->data))->ischeck == true) {
		p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), ((PlayerInfo*)(peer->data))->checkx, ((PlayerInfo*)(peer->data))->checky));
	}
	else {
		p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), x, y));
	}
	memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	respawnTimeout = 2000;
	memcpy(p2.data + 24, &respawnTimeout, 4);
	memcpy(p2.data + 56, &deathFlag, 4);
	ENetPacket* packet2 = enet_packet_create(p2.data,
		p2.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet2);
	delete p2.data;
	GamePacket p2a = packetEnd(appendString(appendString(createPacket(), "OnPlayPositioned"), "audio/teleport.wav"));
	memcpy(p2a.data + 8, &netID, 4);
	respawnTimeout = 2000;
	memcpy(p2a.data + 24, &respawnTimeout, 4);
	memcpy(p2a.data + 56, &deathFlag, 4);
	ENetPacket* packet2a = enet_packet_create(p2a.data,
		p2a.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet2a);
	delete p2a.data;
}
void InitializePacketWithMannequin(BYTE* raw)
{
	int i = 0;
	raw[i] = 0x05; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x08; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x09; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x17; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x22; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x8c; i++;
	raw[i] = 0x05; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x01; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x0e; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
	raw[i] = 0x00; i++;
}

struct TileExtra {
	int packetType;
	int characterState;
	float objectSpeedX;
	int punchX;
	int punchY;
	int charStat;
	int blockid;
	int visual;
	int signs;
	int backgroundid;
	int displayblock;
	int time;
	int netID;
	int weatherspeed;
	int bpm;
	int unused1;
	int unused2;
	int unused3;
	//int bpm;
};
BYTE* packBlockVisual222(TileExtra* dataStruct)
{

	BYTE* data = new BYTE[104]; // 96
	for (int i = 0; i < 100; i++)
	{
		data[i] = 0;
	}
	memcpy(data, &dataStruct->packetType, 4);
	memcpy(data + 8, &dataStruct->netID, 4);
	memcpy(data + 12, &dataStruct->characterState, 4);
	memcpy(data + 16, &dataStruct->objectSpeedX, 4);
	memcpy(data + 44, &dataStruct->punchX, 4);
	memcpy(data + 48, &dataStruct->punchY, 4);
	memcpy(data + 52, &dataStruct->charStat, 4);
	memcpy(data + 56, &dataStruct->blockid, 2);
	memcpy(data + 58, &dataStruct->backgroundid, 2);
	memcpy(data + 60, &dataStruct->visual, 4);
	memcpy(data + 64, &dataStruct->displayblock, 4);


	return data;
}
void UpdateBlockState(ENetPeer* peer, int x, int y, bool forEveryone, WorldInfo* worldInfo) {

	if (!worldInfo) return;
	WorldInfo* world = getPlyersWorld(peer);

	int i = y * worldInfo->width + x;

	int blockStateFlags = 0;


	if (worldInfo->items[i].flipped)
		blockStateFlags |= 0x00200000;
	if (worldInfo->items[i].water)
		blockStateFlags |= 0x04000000;
	if (worldInfo->items[i].glue)
		blockStateFlags |= 0x08000000;
	if (worldInfo->items[i].fire)
		blockStateFlags |= 0x10000000;
	if (worldInfo->items[i].red)
		blockStateFlags |= 0x20000000;
	if (worldInfo->items[i].green)
		blockStateFlags |= 0x40000000;
	if (worldInfo->items[i].blue)
		blockStateFlags |= 0x80000000;
	if (worldInfo->items[i].activated)
		blockStateFlags |= 0x00400000;

	if (blockStateFlags != 0)
	{
		TileExtra data;
		data.packetType = 0x5;
		data.characterState = 8;
		data.charStat = 8;
		data.blockid = worldInfo->items[i].foreground;
		data.backgroundid = worldInfo->items[i].background;
		data.visual = blockStateFlags;
		data.punchX = x;
		data.punchY = y;

		ENetPeer* currentPeer;

		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				SendPacketRaw2(192, packBlockVisual222(&data), 100, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
			}
		}

	}
	else {
		TileExtra data;
		data.packetType = 0x5;
		data.characterState = 8;
		data.charStat = 8;
		data.blockid = worldInfo->items[i].foreground;
		data.backgroundid = worldInfo->items[i].background;
		data.visual = blockStateFlags;
		data.punchX = x;
		data.punchY = y;

		ENetPeer* currentPeer;

		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				SendPacketRaw2(192, packBlockVisual222(&data), 100, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
			}
		}

	}
}
BYTE* packStuffVisual(TileExtra* dataStruct, int options, int gravity)
{
	BYTE* data = new BYTE[102];
	for (int i = 0; i < 102; i++)
	{
		data[i] = 0;
	}
	memcpy(data, &dataStruct->packetType, 4);
	memcpy(data + 8, &dataStruct->netID, 4);
	memcpy(data + 12, &dataStruct->characterState, 4);
	memcpy(data + 44, &dataStruct->punchX, 4);
	memcpy(data + 48, &dataStruct->punchY, 4);
	memcpy(data + 52, &dataStruct->charStat, 4);
	memcpy(data + 56, &dataStruct->blockid, 2);
	memcpy(data + 58, &dataStruct->backgroundid, 2);
	memcpy(data + 60, &dataStruct->visual, 4);
	memcpy(data + 64, &dataStruct->displayblock, 4);
	memcpy(data + 68, &gravity, 4);
	memcpy(data + 70, &options, 4);

	return data;
}

void updateMannequin(
	ENetPeer* peer, int foreground, int x, int y, int background, string text,
	int clothHair, int clothHead, int clothMask,
	int clothHand, int clothNeck, int clothShirt,
	int clothPants, int clothFeet, int clothBack, bool sendPacketToEveryone = true, int blockState = 0)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	short textLen = text.size();
	int plength = 95 + textLen;
	BYTE* raw = new BYTE[plength];
	memset(raw, 0, plength);
	InitializePacketWithMannequin(raw);
	int negativeOne = -1;
	int adjhasdjk = 0xfdfdfdfd;
	int visor = 138;

	memcpy(raw + 44, &x, sizeof(int));
	memcpy(raw + 48, &y, sizeof(int));
	memcpy(raw + 56, &foreground, sizeof(short));
	memcpy(raw + 58, &background, sizeof(short));
	memcpy(raw + 60, &blockState, sizeof(short));
	memcpy(raw + 65, &textLen, sizeof(short));
	memcpy(raw + 67, text.c_str(), textLen);
	memcpy(raw + 68 + textLen, &negativeOne, sizeof(int));
	memcpy(raw + 72 + textLen, &clothHead, sizeof(short));
	memcpy(raw + 74 + textLen, &clothShirt, sizeof(short));
	memcpy(raw + 76 + textLen, &clothPants, sizeof(short));
	memcpy(raw + 78 + textLen, &clothFeet, sizeof(short));
	memcpy(raw + 80 + textLen, &clothMask, sizeof(short));
	memcpy(raw + 82 + textLen, &clothHand, sizeof(short));
	memcpy(raw + 84 + textLen, &clothBack, sizeof(short));
	memcpy(raw + 86 + textLen, &clothHair, sizeof(short));
	memcpy(raw + 88 + textLen, &clothNeck, sizeof(short));
	memcpy(raw + 91 + textLen, &adjhasdjk, sizeof(short));

	ENetPacket* p = enet_packet_create(0, plength + 4, ENET_PACKET_FLAG_RELIABLE);
	int four = 4;
	memcpy(p->data, &four, sizeof(int));
	memcpy((char*)p->data + 4, raw, plength);

	if (sendPacketToEveryone)
	{
		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				enet_peer_send(currentPeer, 0, p);
			}
		}
		delete raw;
	}
	else
	{
		enet_peer_send(peer, 0, p);
		delete raw;
	}
}
void updateStuffWeather(ENetPeer* peer, int x, int y, int tile, int bg, int gravity, bool isInverted, bool isSpinning) {


	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {




			//cout << "[!] bruh" << endl;
			TileExtra data;
			data.packetType = 0x5;
			data.characterState = 8;
			data.punchX = x;
			data.punchY = y;
			data.charStat = 18; // 13
			data.blockid = 3832;
			data.backgroundid = bg; // 2946
								   //data.netID = ((PlayerInfo)(peer->data))->netID;
								   //dataxx.backgroundid = 65536;
			data.visual = 0; //0x00210000
										//world->items[x + (yworld->width)].displayblock = tile;
			int n = tile;
			string hex = "";
			{
				std::stringstream ss;
				ss << std::hex << n; // int decimal_value
				std::string res(ss.str());
				hex = res + "31";
			}
			int gravi = gravity;
			string hexg = "";
			{
				int temp = gravi;
				if (gravi < 0) temp = -gravi;
				std::stringstream ss;
				ss << std::hex << temp; // int decimal_value
				std::string res(ss.str());
				hexg = res + "00";
			}
			int xx = 0;
			std::stringstream ss;
			ss << std::hex << hex;
			if (!ss.fail()) {
				ss >> xx;
			}
			//cout << xx << endl;
			data.displayblock = xx;
			int xxs = 0;
			std::stringstream sss;
			sss << std::hex << hexg;
			if (!sss.fail()) {
				sss >> xxs;
			}
			if (gravi < 0) xxs = -xxs;
			//cout << to_string(xxs) << endl;
			if (gravi < 0) {
				SendPacketRaw(192, packStuffVisual(&data, 0x03FFFFFF, xxs), 102, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
			}
			else
			{
				SendPacketRaw(192, packStuffVisual(&data, 0x02000000, xxs), 102, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
			}
			GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), 29));
			ENetPacket* packet2 = enet_packet_create(p2.data,
				p2.len,
				ENET_PACKET_FLAG_RELIABLE);

			enet_peer_send(currentPeer, 0, packet2);
			delete p2.data;
		}
	}
}
void updateSign(ENetPeer* peer, int foreground, int x, int y, string text, int background)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	int hmm = 8, wot = text.length(), lol = 0, wut = 5;
	int yeh = hmm + 3 + 1, idk = 15 + wot, lmao = -1, yey = 2; //idk = text_len + 15, wut = type(?), wot = text_len, yey = len of text_len
	int ok = 52 + idk;
	int kek = ok + 4, yup = ok - 8 - idk;
	int thonk = 4, magic = 56, wew = ok + 5 + 4;
	int wow = magic + 4 + 5;
	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	memcpy(data, &wut, thonk);
	memcpy(data + yeh, &hmm, thonk); //read discord
	memcpy(data + yup, &x, 4);
	memcpy(data + yup + 4, &y, 4);
	memcpy(data + 4 + yup + 4, &idk, thonk);
	memcpy(data + magic, &foreground, yey);
	memcpy(data + magic + 2, &background, yey); //p100 fix by the one and only lapada
	memcpy(data + thonk + magic, &lol, thonk);
	memcpy(data + magic + 4 + thonk, &yey, 1);
	memcpy(data + wow, &wot, yey); //data + wow = text_len
	memcpy(data + yey + wow, text.c_str(), wot); //data + text_len_len + text_len_offs = text
	memcpy(data + ok, &lmao, thonk); //end ?
	memcpy(p->data, &thonk, thonk);
	memcpy((char*)p->data + thonk, data, kek); //kek = data_len
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, p);
		}
	}
	delete data;
}


void updateSignSound(ENetPeer* peer, int foreground, int x, int y, string text, int background)
{
	int hmm = 8, wot = text.length(), lol = 0, wut = 5;
	int yeh = hmm + 3 + 1, idk = 15 + wot, lmao = -1, yey = 2; //idk = text_len + 15, wut = type(?), wot = text_len, yey = len of text_len
	int ok = 52 + idk;
	int kek = ok + 4, yup = ok - 8 - idk;
	int thonk = 4, magic = 56, wew = ok + 5 + 4;
	int wow = magic + 4 + 5;
	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	memcpy(data, &wut, thonk);
	memcpy(data + yeh, &hmm, thonk); //read discord
	memcpy(data + yup, &x, 4);
	memcpy(data + yup + 4, &y, 4);
	memcpy(data + 4 + yup + 4, &idk, thonk);
	memcpy(data + magic, &foreground, yey);
	memcpy(data + magic + 2, &background, yey); //p100 fix by the one and only lapada
	memcpy(data + thonk + magic, &lol, thonk);
	memcpy(data + magic + 4 + thonk, &yey, 1);
	memcpy(data + wow, &wot, yey); //data + wow = text_len
	memcpy(data + yey + wow, text.c_str(), wot); //data + text_len_len + text_len_offs = text
	memcpy(data + ok, &lmao, thonk); //end ?
	memcpy(p->data, &thonk, thonk);
	memcpy((char*)p->data + thonk, data, kek); //kek = data_len
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, p);
		}
	}
	delete data;
}

void updateAllClothes(ENetPeer* peer)
{
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer))
		{
			GamePacket p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), ((PlayerInfo*)(peer->data))->cloth_hair, ((PlayerInfo*)(peer->data))->cloth_shirt, ((PlayerInfo*)(peer->data))->cloth_pants), ((PlayerInfo*)(peer->data))->cloth_feet, ((PlayerInfo*)(peer->data))->cloth_face, ((PlayerInfo*)(peer->data))->cloth_hand), ((PlayerInfo*)(peer->data))->cloth_back, ((PlayerInfo*)(peer->data))->cloth_mask, ((PlayerInfo*)(peer->data))->cloth_necklace), ((PlayerInfo*)(peer->data))->skinColor), ((PlayerInfo*)(peer->data))->cloth_ances, 0.0f, 0.0f));
			memcpy(p3.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4); // ffloor
			ENetPacket* packet3 = enet_packet_create(p3.data,
				p3.len,
				ENET_PACKET_FLAG_RELIABLE);

			enet_peer_send(currentPeer, 0, packet3);
			delete p3.data;
			//enet_host_flush(server);
			GamePacket p4 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), ((PlayerInfo*)(currentPeer->data))->cloth_hair, ((PlayerInfo*)(currentPeer->data))->cloth_shirt, ((PlayerInfo*)(currentPeer->data))->cloth_pants), ((PlayerInfo*)(currentPeer->data))->cloth_feet, ((PlayerInfo*)(currentPeer->data))->cloth_face, ((PlayerInfo*)(currentPeer->data))->cloth_hand), ((PlayerInfo*)(currentPeer->data))->cloth_back, ((PlayerInfo*)(currentPeer->data))->cloth_mask, ((PlayerInfo*)(currentPeer->data))->cloth_necklace), ((PlayerInfo*)(currentPeer->data))->skinColor), ((PlayerInfo*)(currentPeer->data))->cloth_ances, 0.0f, 0.0f));
			memcpy(p4.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4); // ffloor
			ENetPacket* packet4 = enet_packet_create(p4.data,
				p4.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet4);
			delete p4.data;
			//enet_host_flush(server);
		}
	}
}

void sendTime(ENetPeer* peer)
{
	time_t _tm = time(NULL);
	struct tm* curtime = localtime(&_tm);
	string test = asctime(curtime);
	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `2Current time is: " + test));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);

	//enet_host_flush(server);
	delete p.data;
}

void SendGamePacket(ENetPeer* peer, GamePacket* p)
{
	ENetPacket* packet1 = enet_packet_create(p->data,
		p->len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet1);
}
void sendmusic(ENetPeer* peer, string music) {
	string text = "action|play_sfx\nfile|audio/" + music + ".wav\ndelayMS|0\n";
	BYTE* data = new BYTE[5 + text.length()];
	BYTE zero = 0;
	int type = 3;
	memcpy(data, &type, 4);
	memcpy(data + 4, text.c_str(), text.length());
	memcpy(data + 4 + text.length(), &zero, 1);
	ENetPacket* packet2 = enet_packet_create(data,
		5 + text.length(),
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet2);
	delete[] data;
}
void sendSound(ENetPeer* peer, string sound)
{
	string text = "action|play_sfx\nfile|audio/" + sound + "\ndelayMS|0\n";
	BYTE* data = new BYTE[5 + text.length()];
	BYTE zero = 0;
	int type = 3;
	memcpy(data, &type, 4);
	memcpy(data + 4, text.c_str(), text.length());
	memcpy(data + 4 + text.length(), &zero, 1);

	ENetPacket* packet2 = enet_packet_create(data,
		5 + text.length(),
		ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, packet2);
	delete data;
}
void sendPData(ENetPeer* peer, PlayerMoving* data)
{
	ENetPeer* currentPeer;

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (peer != currentPeer)
		{
			if (isHere(peer, currentPeer))
			{
				data->netID = ((PlayerInfo*)(peer->data))->netID;

				SendPacketRaw(4, packPlayerMoving(data), 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
			}
		}
	}
}

int getPlayersCountInWorld(string name)
{
	int count = 0;
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (((PlayerInfo*)(currentPeer->data))->isinv == false)
		{
			if (((PlayerInfo*)(currentPeer->data))->currentWorld == name)
				count++;
		}
		return count;
	}
}


void sendRoulete(ENetPeer* peer)
{
	using namespace std::chrono;




	if (((PlayerInfo*)(peer->data))->lastSPIN + 1500 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
	{
		((PlayerInfo*)(peer->data))->lastSPIN = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
	}


	else {

		return;

	}
	ENetPeer* currentPeer;
	int val = rand() % 36;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer))
		{
			string name = ((PlayerInfo*)(peer->data))->displayName;
			/*
			if (((PlayerInfo*)(peer->data))->lastSpin + 1500 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
			{
			((PlayerInfo*)(peer->data))->lastSpin = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}


			else {
			GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4Please spin slow!"));
			ENetPacket * packet = enet_packet_create(po.data,
			po.len,
			ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete po.data;
			//enet_host_flush(server);
			continue;
			}*/

			if (val == 1 || val == 3 || val == 5 || val == 7 || val == 9 || val == 12 || val == 14 || val == 16 || val == 18 || val == 19 || val == 21 || val == 23 || val == 25 || val == 27 || val == 30 || val == 32 || val == 34 || val == 36) {
				if (((PlayerInfo*)(peer->data))->rawName == "cat") {
					GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`w[" + name + " `wspun the wheel and got `436`w!]"), 0));
					int respawnTimeout = 2000;
					int deathFlag = 0x19;
					memcpy(p2.data + 24, &respawnTimeout, 4);
					memcpy(p2.data + 56, &deathFlag, 4);
					ENetPacket* packet2 = enet_packet_create(p2.data,
						p2.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(currentPeer, 0, packet2);
					delete p2.data;
					GamePacket p2s = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `7[`w" + name + " `ospun the wheel and got `436`o!`7]"));

					memcpy(p2s.data + 24, &respawnTimeout, 4);
					memcpy(p2s.data + 56, &deathFlag, 4);
					ENetPacket* packet2s = enet_packet_create(p2s.data,
						p2s.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(currentPeer, 0, packet2s);
					delete p2s.data;
				}
				else {
					GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`w[" + name + " `wspun the wheel and got `4" + std::to_string(val) + "`w!]"), 0));
					int respawnTimeout = 2000;
					int deathFlag = 0x19;
					memcpy(p2.data + 24, &respawnTimeout, 4);
					memcpy(p2.data + 56, &deathFlag, 4);
					ENetPacket* packet2 = enet_packet_create(p2.data,
						p2.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(currentPeer, 0, packet2);
					delete p2.data;
					GamePacket p2s = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `7[`w" + name + " `ospun the wheel and got `4" + std::to_string(val) + "`o!`7]"));

					memcpy(p2s.data + 24, &respawnTimeout, 4);
					memcpy(p2s.data + 56, &deathFlag, 4);
					ENetPacket* packet2s = enet_packet_create(p2s.data,
						p2s.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(currentPeer, 0, packet2s);
					delete p2s.data;
				}
			}
			else if (val == 2 || val == 4 || val == 6 || val == 8 || val == 10 || val == 11 || val == 13 || val == 15 || val == 17 || val == 20 || val == 22 || val == 24 || val == 26 || val == 28 || val == 29 || val == 31 || val == 33 || val == 35) {
				if (((PlayerInfo*)(peer->data))->rawName == "mindpin") {
					GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`w[" + name + " `wspun the wheel and got `b35`w!]"), 0));
					int respawnTimeout = 2000;
					int deathFlag = 0x19;
					memcpy(p2.data + 24, &respawnTimeout, 4);
					memcpy(p2.data + 56, &deathFlag, 4);
					ENetPacket* packet2 = enet_packet_create(p2.data,
						p2.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(currentPeer, 0, packet2);

					delete p2.data;
					GamePacket p2s = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `7[`w" + name + " `ospun the wheel and got `b35`o!`7]"));

					memcpy(p2s.data + 24, &respawnTimeout, 4);
					memcpy(p2s.data + 56, &deathFlag, 4);
					ENetPacket* packet2s = enet_packet_create(p2s.data,
						p2s.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(currentPeer, 0, packet2s);
					delete p2s.data;
				}
				else {
					GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`w[" + name + " `wspun the wheel and got `b" + std::to_string(val) + "`w!]"), 0));
					int respawnTimeout = 2000;
					int deathFlag = 0x19;
					memcpy(p2.data + 24, &respawnTimeout, 4);
					memcpy(p2.data + 56, &deathFlag, 4);
					ENetPacket* packet2 = enet_packet_create(p2.data,
						p2.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(currentPeer, 0, packet2);

					delete p2.data;
					GamePacket p2s = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `7[`w" + name + " `ospun the wheel and got `b" + std::to_string(val) + "`o!`7]"));

					memcpy(p2s.data + 24, &respawnTimeout, 4);
					memcpy(p2s.data + 56, &deathFlag, 4);
					ENetPacket* packet2s = enet_packet_create(p2s.data,
						p2s.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(currentPeer, 0, packet2s);
					delete p2s.data;
				}

			}

			else if (val == 0 || val == 37) {

				GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`w[" + name + " `wspun the wheel and got `20`w!]"), 0));
				int respawnTimeout = 2000;
				int deathFlag = 0x19;
				memcpy(p2.data + 24, &respawnTimeout, 4);
				memcpy(p2.data + 56, &deathFlag, 4);
				ENetPacket* packet2 = enet_packet_create(p2.data,
					p2.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packet2);
				delete p2.data;
				GamePacket p2s = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `7[`w" + name + " `ospun the wheel and got `20`o!`7]"));

				memcpy(p2s.data + 24, &respawnTimeout, 4);
				memcpy(p2s.data + 56, &deathFlag, 4);
				ENetPacket* packet2s = enet_packet_create(p2s.data,
					p2s.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(currentPeer, 0, packet2s);
				delete p2s.data;
			}
		}

	}
}

void sendNothingHappened(ENetPeer* peer, int x, int y) {
	PlayerMoving data;
	data.netID = ((PlayerInfo*)(peer->data))->netID;
	data.packetType = 0x8;
	data.plantingTree = 0;
	data.netID = -1;
	data.x = x;
	data.y = y;
	data.punchX = x;
	data.punchY = y;
	SendPacketRaw(4, packPlayerMoving(&data), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
}
void SendTilePickup(ENetPeer* peer, int itemid, int netID, float x, float y, int itemcount, int itemamount) {
	PlayerMoving data;
	data.characterState = 0x0; // animation
	data.x = x * 32;
	data.y = y * 32;
	data.punchX = 0;
	data.punchY = 0;
	data.XSpeed = 0;
	data.YSpeed = 0;
	data.netID = -1;
	data.secondnetID = -1;
	data.plantingTree = itemid;
	data.packetType = 0xE;
	BYTE* raw = packPlayerMoving(&data);
	int netIdSrc = -1;
	int netIdDst = -1;
	int three = 3;
	int n1 = itemid;
	int one = 1;
	float count = itemamount;
	memcpy(raw + 3, &three, 1);
	memcpy(raw + 4, &netIdDst, 4);
	memcpy(raw + 8, &netIdSrc, 4);
	memcpy(raw + 16, &count, 4);
	memcpy(raw + 20, &n1, 4);

	((PlayerInfo*)(peer->data))->droppeditemcount++;
	SendPacketRaw(4, raw, 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

	PlayerMoving datax;
	datax.characterState = 0x0; // animation
	datax.x = x * 32;
	datax.y = y * 32;
	datax.punchX = 0;
	datax.punchY = 0;
	datax.XSpeed = 0;
	datax.YSpeed = 0;
	datax.netID = -1;
	datax.secondnetID = 0;
	datax.plantingTree = itemid;
	datax.packetType = 0xE;
	BYTE* raws = packPlayerMoving(&data);
	int lol = -1;


	memcpy(raws + 3, &three, 1);
	memcpy(raws + 4, &netID, 4);
	memcpy(raws + 8, &lol, 4);
	memcpy(raws + 20, &((PlayerInfo*)(peer->data))->droppeditemcount, 4);
	SendPacketRaw(4, raws, 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
}

void SendDisplayBlock(ENetPeer* peer, int16_t fg, int16_t bg, int32_t x, int32_t y, int32_t item) {

	int8_t* ExtendedData = new int8_t[13];
	int32_t extendedLen = 13;

	PlayerMoving pmov;
	pmov.packetType = 0x5;
	pmov.characterState = 0x8;
	pmov.punchX = x;
	pmov.punchY = y;

	int8_t* raw = new int8_t[69];

	memcpy(raw, packPlayerMoving(&pmov), 56);
	*(int32_t*)(raw + 52) = extendedLen;

	*(int16_t*)(ExtendedData + 0) = fg;
	*(int16_t*)(ExtendedData + 2) = bg;
	*(int32_t*)(ExtendedData + 4) = 0x0010000;
	ExtendedData[8] = 0x17;
	*(int32_t*)(ExtendedData + 9) = item;

	memcpy(raw + 56, ExtendedData, extendedLen);

	ENetPacket* p = enet_packet_create(0, 74, 1);
	*(int32_t*)(p->data) = 4;
	memcpy(p->data + 4, raw, 69);
	enet_peer_send(peer, 0, p);

}
void sendDShelf(ENetPeer* peer, int x, int y, int item1, int item2, int item3, int item4)
{
	PlayerMoving pmov;
	pmov.packetType = 5;
	pmov.characterState = 8;
	pmov.punchX = x;
	pmov.punchY = y;
	pmov.netID = -1;
	uint8_t* pmovpacked = packPlayerMoving(&pmov);
	*(uint32_t*)(pmovpacked + 52) = 8 + 16;
	uint8_t* packet = new uint8_t[4 + 56 + 8 + 16];
	memset(packet, 0, 4 + 56 + 8 + 16);
	packet[0] = 4;
	memcpy(packet + 4, pmovpacked, 56);
	*(uint16_t*)(packet + 4 + 56) = 3794; // display shelf id
	*(uint16_t*)(packet + 4 + 56 + 6) = 1;
	*(uint8_t*)(packet + 4 + 56 + 8) = 0x2B;
	*(int*)(packet + 4 + 56 + 9 + 0 * 4) = item1;
	*(int*)(packet + 4 + 56 + 9 + 1 * 4) = item2;
	*(int*)(packet + 4 + 56 + 9 + 2 * 4) = item3;
	*(int*)(packet + 4 + 56 + 9 + 3 * 4) = item4;
	ENetPacket* epacket = enet_packet_create(packet, 4 + 56 + 8 + 16, ENET_PACKET_FLAG_RELIABLE);

	enet_peer_send(peer, 0, epacket);

	delete pmovpacked;
	delete packet;
}
void updateVendMsg(ENetPeer* peer, int foreground, int x, int y, string text)
{
	PlayerMoving sign;
	sign.packetType = 0x3;
	sign.characterState = 0x0;
	sign.x = x;
	sign.y = y;
	sign.punchX = x;
	sign.punchY = y;
	sign.XSpeed = 0;
	sign.YSpeed = 0;
	sign.netID = -1;
	sign.plantingTree = foreground;
	SendPacketRaw(4, packPlayerMoving(&sign), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
	int hmm = 8;
	int text_len = text.length();
	int lol = 0;
	int wut = 5;
	int yeh = hmm + 3 + 1;
	int idk = 15 + text_len;
	int is_locked = 0;
	int bubble_type = 21;
	int ok = 52 + idk;
	int kek = ok + 4;
	int yup = ok - 8 - idk;
	int four = 4;
	int magic = 56;
	int wew = ok + 5 + 4;
	int wow = magic + 4 + 5;

	BYTE* data = new BYTE[kek];
	ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
	for (int i = 0; i < kek; i++) data[i] = 0;
	memcpy(data, &wut, four);
	memcpy(data + yeh, &hmm, four);
	memcpy(data + yup, &x, 4);
	memcpy(data + yup + 4, &y, 4);
	memcpy(data + 4 + yup + 4, &idk, four);
	memcpy(data + magic, &foreground, 2);
	memcpy(data + four + magic, &lol, four);
	memcpy(data + magic + 4 + four, &bubble_type, 1);
	memcpy(data + wow, &text_len, 2);
	memcpy(data + 2 + wow, text.c_str(), text_len);
	memcpy(data + ok, &is_locked, four);
	memcpy(p->data, &four, four);
	memcpy((char*)p->data + four, data, kek);
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			enet_peer_send(currentPeer, 0, p);
		}
	}
	delete data;
}
void UpdateVend(ENetPeer* peer, int x, int y, int id, bool locks, int price)
{
	bool isPer = false;
	WorldInfo* world = getPlyersWorld(peer);
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			TileExtra data;
			data.packetType = 0x5;
			data.characterState = 8;
			data.punchX = x;
			data.punchY = y;
			data.charStat = 13; // 13
			data.blockid = 2978; // 2946 3794 = display shelf
								 //data.netID = ((PlayerInfo*)(peer->data))->netID;
			data.backgroundid = 6864;
			data.visual = 0x00410000; //0x00210000
			if (locks == true) data.visual = 0x02410000;



			int n = id;
			string hex = "";
			{
				std::stringstream ss;
				ss << std::hex << n; // int decimal_value
				std::string res(ss.str());
				hex = res + "18";
			}

			int xx;
			std::stringstream ss;
			ss << std::hex << hex;
			ss >> xx;
			data.displayblock = xx;
			int xes;
			{
				int wl = price;
				string hex = "";
				{
					std::stringstream ss;
					ss << std::hex << wl; // int decimal_value
					std::string res(ss.str());
					hex = res + "00";
				}
				int x;
				std::stringstream ss;
				ss << std::hex << hex;
				ss >> x;

				xes = x;
			}
			BYTE* raw = NULL;
			if (isPer) {
				raw = packStuffVisual(&data, 16777215, -xes);
			}
			else
			{
				raw = packStuffVisual(&data, 0, xes);
			}
			SendPacketRaw2(192, raw, 102, 0, peer, ENET_PACKET_FLAG_RELIABLE);
			raw = NULL; // prevent memory leak
		}
	}
}
void SendPacketRaw3(int a1, void* packetData, size_t packetDataSize, void* a4, ENetPeer* peer, int packetFlag)
{
	try {
		ENetPacket* p;

		if (peer) // check if we have it setup
		{
			p = enet_packet_create(0, packetDataSize + 5, packetFlag);
			memcpy(p->data, &a1, 4);
			memcpy((char*)p->data + 4, packetData, packetDataSize);
			enet_peer_send(peer, 0, p);
		}
		delete (char*)packetData;
	}
	catch (...) {
		cout << "error in void sendpacketraw3";
	}
}
namespace visual {
	void SendDonateData(ENetPeer* peer, short fg, short bg, int x, int y, int item) {

		byte* ExtendedData = new byte[15];
		int state = 0x0010000;
		int zero = 0;
		int extendedLen = 15;
		int stt = 65;

		PlayerMoving pmov;
		pmov.packetType = 0x5;
		pmov.characterState = 0x8;
		pmov.punchX = x;
		pmov.punchY = y;

		byte* raw = new byte[56 + 15];
		memcpy(raw, packPlayerMoving(&pmov), 56);
		memcpy(raw + 52, &extendedLen, 4);

		memcpy(ExtendedData, &fg, 2);
		memcpy(ExtendedData + 2, &bg, 2);

		ExtendedData[4] = 0;
		ExtendedData[5] = 0;
		ExtendedData[6] = 65;
		ExtendedData[7] = 0;





		memcpy(raw + 56, ExtendedData, extendedLen);

		SendPacketRaw3(4, raw, 56 + 15, 0, peer, ENET_PACKET_FLAG_RELIABLE);
		delete[] ExtendedData; // fix memleak by playingo

	}
	void updateEntrance(ENetPeer* peer, int foreground, int x, int y, bool open, int bg) {
		BYTE* data = new BYTE[69];
		for (int i = 0; i < 69; i++) data[i] = 0;
		int four = 4; int five = 5; int eight = 8;
		int huhed = (65536 * bg) + foreground; int loled = 128;

		memcpy(data, &four, 4);
		memcpy(data + 4, &five, 4);
		memcpy(data + 16, &eight, 4);
		memcpy(data + 48, &x, 4);
		memcpy(data + 52, &y, 4);
		memcpy(data + 56, &eight, 4);
		memcpy(data + 60, &foreground, 4);
		memcpy(data + 62, &bg, 4);
		if (open) {
			int state = 0;
			memcpy(data + 66, &loled, 4);
			memcpy(data + 68, &state, 4);
		}
		else {
			int state = 100;
			int yeetus = 25600;
			memcpy(data + 67, &yeetus, 5);
			memcpy(data + 68, &state, 4);
		}
		ENetPacket* p = enet_packet_create(data, 69, ENET_PACKET_FLAG_RELIABLE);

		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				enet_peer_send(currentPeer, 0, p);
			}
		}
		delete[] data;
	}
	void updatetree(ENetPeer* peer, int foreground, int x, int y, int background, int fruitCount, int timeIntoGrowth, int blockStateFlags) {
		int hmm = 8;
		int zero = 0;
		int packetType = 5;
		int yeh = hmm + 3 + 1;
		int idk = 15 + 4;
		int blockState = blockStateFlags;
		int bubble_type = 4;
		int ok = 52 + idk;
		int packetSize = ok + 4;
		int yup = ok - 8 - idk;
		int four = 4;
		int magic = 56;
		int wew = ok + 5 + 4;
		int wow = magic + 4 + 5;

		short fc = 1;
		int time = 0;
		int text_len = 4;
		int treedata = 0x00020000;
		blockState |= 0x100000;

		BYTE* data = new BYTE[packetSize];
		ENetPacket* p = enet_packet_create(0, wew, ENET_PACKET_FLAG_RELIABLE);
		memset(data, 0, packetSize);
		memcpy(data, &packetType, sizeof(int));
		memcpy(data + yeh, &hmm, sizeof(int));
		memcpy(data + yup, &x, sizeof(int));
		memcpy(data + yup + 4, &y, sizeof(int));
		memcpy(data + 4 + yup + 4, &idk, sizeof(int));
		memcpy(data + magic, &foreground, sizeof(short));
		memcpy(data + magic + 2, &background, sizeof(short));
		memcpy(data + magic + 4, &blockState, sizeof(int));
		memcpy(data + magic + 8, &bubble_type, sizeof(byte));
		memcpy(data + magic + 9 + 0, &time, 4);
		memcpy(data + magic + 9 + 4, &fc, 1);
		memcpy(data + ok, &blockState, sizeof(int));
		memcpy(p->data, &four, four);
		memcpy((char*)p->data + four, data, packetSize);

		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				enet_peer_send(currentPeer, 0, p);
			}
		}
		delete[] data;
	}
}
void sendWorld(ENetPeer* peer, WorldInfo* worldInfo)
{
	if (!worldInfo) return;

	int zero = 0;
	((PlayerInfo*)(peer->data))->droppeditemcount = worldInfo->droppedCount;
#ifdef TOTAL_LOG
	cout << "Entering a world..." << endl;
#endif
	((PlayerInfo*)(peer->data))->joinClothesUpdated = false;
	string asdf = "0400000004A7379237BB2509E8E0EC04F8720B050000000000000000FBBB0000010000007D920100FDFDFDFD04000000040000000000000000000000070000000000"; // 0400000004A7379237BB2509E8E0EC04F8720B050000000000000000FBBB0000010000007D920100FDFDFDFD04000000040000000000000000000000080000000000000000000000000000000000000000000000000000000000000048133A0500000000BEBB0000070000000000
	string worldName = worldInfo->name;
	int xSize = worldInfo->width;
	int ySize = worldInfo->height;
	int square = xSize * ySize;
	__int16 nameLen = (__int16)worldName.length();
	int payloadLen = asdf.length() / 2;
	int dataLen = payloadLen + 2 + nameLen + 12 + (square * 8) + 4 + 100;
	int offsetData = dataLen - 100;
	int allocMem = payloadLen + 2 + nameLen + 12 + (square * 8) + 4 + 16000 + 100 + (worldInfo->droppedItems.size() * 20);
	BYTE* data = new BYTE[allocMem];
	memset(data, 0, allocMem);
	for (int i = 0; i < asdf.length(); i += 2)
	{
		char x = ch2n(asdf[i]);
		x = x << 4;
		x += ch2n(asdf[i + 1]);
		memcpy(data + (i / 2), &x, 1);
	}

	__int16 item = 0;
	int smth = 0;
	for (int i = 0; i < square * 8; i += 4) memcpy(data + payloadLen + i + 14 + nameLen, &zero, 4);
	for (int i = 0; i < square * 8; i += 8) memcpy(data + payloadLen + i + 14 + nameLen, &item, 2);
	memcpy(data + payloadLen, &nameLen, 2);
	memcpy(data + payloadLen + 2, worldName.c_str(), nameLen);
	memcpy(data + payloadLen + 2 + nameLen, &xSize, 4);
	memcpy(data + payloadLen + 6 + nameLen, &ySize, 4);
	memcpy(data + payloadLen + 10 + nameLen, &square, 4);
	BYTE* blockPtr = data + payloadLen + 14 + nameLen;

	int sizeofblockstruct = 8;


	for (int i = 0; i < square; i++) {

		int tile = worldInfo->items[i].foreground;
		int backg = worldInfo->items[i].background;
		sizeofblockstruct = 8;

		if (tile == 6) {
			int type = 0x00000000;

			// type 1 = locked
			if (worldInfo->items[i].activated)
				type |= 0x00200000;
			if (worldInfo->items[i].flipped)
				type |= 0x00400000;
			if (worldInfo->items[i].water)
				type |= 0x04000000;
			if (worldInfo->items[i].glue)
				type |= 0x08000000;
			if (worldInfo->items[i].fire)
				type |= 0x10000000;
			if (worldInfo->items[i].red)
				type |= 0x20000000;
			if (worldInfo->items[i].green)
				type |= 0x40000000;
			if (worldInfo->items[i].blue)
				type |= 0x80000000;
			memcpy(blockPtr, &tile, 2);
			memcpy(blockPtr + 4, &type, 4);
			BYTE btype = 1;
			memcpy(blockPtr + 8, &btype, 1);

			string doorText = "Bye";
			const char* doorTextChars = doorText.c_str();
			short length = (short)doorText.size();
			memcpy(blockPtr + 9, &length, 2);
			memcpy(blockPtr + 11, doorTextChars, length);
			sizeofblockstruct += 4 + length;
			dataLen += 4 + length; // it's already 8.

		}

		else if (getItemDef(tile).blockType == BlockTypes::SIGN || tile == 1420 || tile == 6124) {
			int type = 0x00000000;

			// type 1 = locked
			if (worldInfo->items[i].activated)
				type |= 0x00200000;
			if (worldInfo->items[i].flipped)
				type |= 0x00400000;
			if (worldInfo->items[i].water)
				type |= 0x04000000;
			if (worldInfo->items[i].glue)
				type |= 0x08000000;
			if (worldInfo->items[i].fire)
				type |= 0x10000000;
			if (worldInfo->items[i].red)
				type |= 0x20000000;
			if (worldInfo->items[i].green)
				type |= 0x40000000;
			if (worldInfo->items[i].blue)
				type |= 0x80000000;
			memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
			memcpy(blockPtr + 4, &type, 4);
			BYTE btype = 2;
			memcpy(blockPtr + 8, &btype, 1);
			string signText = worldInfo->items[i].sign;
			const char* signTextChars = signText.c_str();
			short length = (short)signText.size();
			memcpy(blockPtr + 9, &length, 2);
			memcpy(blockPtr + 11, signTextChars, length);
			int minus1 = -1;
			memcpy(blockPtr + 11 + length, &minus1, 4);
			sizeofblockstruct += 3 + length + 4;
			dataLen += 3 + length + 4; // it's already 8.
		}
		else if (tile == 2946) {
			int type = 0x00000000;

			// type 1 = locked
			if (worldInfo->items[i].activated)
				type |= 0x00200000;
			if (worldInfo->items[i].flipped)
				type |= 0x00400000;
			if (worldInfo->items[i].water)
				type |= 0x04000000;
			if (worldInfo->items[i].glue)
				type |= 0x08000000;
			if (worldInfo->items[i].fire)
				type |= 0x10000000;
			if (worldInfo->items[i].red)
				type |= 0x20000000;
			if (worldInfo->items[i].green)
				type |= 0x40000000;
			if (worldInfo->items[i].blue)
				type |= 0x80000000;
			memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
			memcpy(blockPtr + 4, &type, 4);
			BYTE btype = 0x17;
			memcpy(blockPtr + 8, &btype, 1);
			int item = worldInfo->items[i].intdata;
			memcpy(blockPtr + 9, &item, 4);
			sizeofblockstruct += 5;
			dataLen += 5;

		}

		else if (tile == 5000) {
			memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
			int type = 0x00000000;

			// type 1 = locked
			if (worldInfo->items[i].activated)
				type |= 0x00200000;
			if (worldInfo->items[i].flipped)
				type |= 0x00400000;
			if (worldInfo->items[i].water)
				type |= 0x04000000;
			if (worldInfo->items[i].glue)
				type |= 0x08000000;
			if (worldInfo->items[i].fire)
				type |= 0x10000000;
			if (worldInfo->items[i].red)
				type |= 0x20000000;
			if (worldInfo->items[i].green)
				type |= 0x40000000;
			if (worldInfo->items[i].blue)
				type |= 0x80000000;
			memcpy(blockPtr + 4, &type, 4);
			BYTE btype = 0x28;
			memcpy(blockPtr + 8, &btype, 1);
			int item = 0;
			int gravity = 0;
			short flags = 0;
			item = worldInfo->bgID;
			memcpy(blockPtr + 9, &item, 4);
			sizeofblockstruct += 5;
			dataLen += 5;
		}
		else if (getItemDef(tile).blockType == BlockTypes::DOOR || getItemDef(tile).blockType == BlockTypes::PORTAL) {
			int type = 0x00000000;

			// type 1 = locked
			if (worldInfo->items[i].activated)
				type |= 0x00200000;
			if (worldInfo->items[i].flipped)
				type |= 0x00400000;
			if (worldInfo->items[i].water)
				type |= 0x04000000;
			if (worldInfo->items[i].glue)
				type |= 0x08000000;
			if (worldInfo->items[i].fire)
				type |= 0x10000000;
			if (worldInfo->items[i].red)
				type |= 0x20000000;
			if (worldInfo->items[i].green)
				type |= 0x40000000;
			if (worldInfo->items[i].blue)
				type |= 0x80000000;
			memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
			memcpy(blockPtr + 4, &type, 4);
			BYTE btype = 1;
			memcpy(blockPtr + 8, &btype, 1);

			string doorText = worldInfo->items[i].sign;
			const char* doorTextChars = doorText.c_str();
			short length = (short)doorText.size();
			memcpy(blockPtr + 9, &length, 2);
			memcpy(blockPtr + 11, doorTextChars, length);
			int minus1 = -1;
			memcpy(blockPtr + 11 + length, &minus1, 4);
			sizeofblockstruct += 4 + length;
			dataLen += 4 + length; // it's already 8.
		}
		else if (worldInfo->items[i].foreground == 5638) {

			BYTE btype = 0x3E;
			if (blockPtr)
			{
				int type = 0x00000000;

				// type 1 = locked
				if (worldInfo->items[i].activated)
					type |= 0x00200000;
				if (worldInfo->items[i].flipped)
					type |= 0x00400000;
				if (worldInfo->items[i].water)
					type |= 0x04000000;
				if (worldInfo->items[i].glue)
					type |= 0x08000000;
				if (worldInfo->items[i].fire)
					type |= 0x10000000;
				if (worldInfo->items[i].red)
					type |= 0x20000000;
				if (worldInfo->items[i].green)
					type |= 0x40000000;
				if (worldInfo->items[i].blue)
					type |= 0x80000000;
				int item = 0;
				int itemCount = 0;
				short magnetEnabled = 0;
				int maxCapacity = 0;
				if (worldInfo->items[i].magitem != 0) {
					item = worldInfo->items[i].magitem;
					itemCount = worldInfo->items[i].magcount;
					magnetEnabled = 1;
					maxCapacity = 5000;
				}

				memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
				memcpy(blockPtr + 4, &type, 4);
				memcpy(blockPtr + 8, &btype, 1);
				memcpy(blockPtr + 9, &item, 4);
				memcpy(blockPtr + 13, &itemCount, 4);
				memcpy(blockPtr + 17, &magnetEnabled, 2);
				memcpy(blockPtr + 19, &maxCapacity, 4);
			}
			sizeofblockstruct += 15;
			dataLen += 15;
		}
		else if (getItemDef(tile).blockType == BlockTypes::LOCK && tile != 4994 && tile != 202 && tile != 204 && tile != 206)
		{

			if (worldInfo->items[i].foreground == 5814)
			{
				// Special Case #1 - Guild Lock
				int type = 0x00000000;

				// type 1 = locked
				if (worldInfo->items[i].activated)
					type |= 0x00200000;
				if (worldInfo->items[i].flipped)
					type |= 0x00400000;
				if (worldInfo->items[i].water)
					type |= 0x04000000;
				if (worldInfo->items[i].glue)
					type |= 0x08000000;
				if (worldInfo->items[i].fire)
					type |= 0x10000000;
				if (worldInfo->items[i].red)
					type |= 0x20000000;
				if (worldInfo->items[i].green)
					type |= 0x40000000;
				if (worldInfo->items[i].blue)
					type |= 0x80000000;
				int adminCount = 1;
				int ownerID = worldInfo->ownerID;// ((PlayerInfo*)peer->data)->userID;
				// int admins[...]
				int szExtra = 10 + adminCount * 4 + 16;
				memset(blockPtr + 8, 0, szExtra);
				BYTE btype = 0x3;
				BYTE o = 0x1;
				memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
				memcpy(blockPtr + 4, &type, 4);
				memcpy(blockPtr + 8, &btype, 1);
				memcpy(blockPtr + 8 + 2, &ownerID, 4);
				memcpy(blockPtr + 8 + 6, &adminCount, 1);
				memcpy(blockPtr + 8 + 10, &o, 1);
				short id1 = 14;
				short id2 = 1;
				memcpy(blockPtr + 8 + 12, &id1, 2);
				memcpy(blockPtr + 8 + 16, &id2, 2);
				sizeofblockstruct += szExtra;
				dataLen += szExtra;
			}
			else
			{
				int type = 0x00000000;

				// type 1 = locked
				if (worldInfo->items[i].activated)
					type |= 0x00200000;
				if (worldInfo->items[i].flipped)
					type |= 0x00400000;
				if (worldInfo->items[i].water)
					type |= 0x04000000;
				if (worldInfo->items[i].glue)
					type |= 0x08000000;
				if (worldInfo->items[i].fire)
					type |= 0x10000000;
				if (worldInfo->items[i].red)
					type |= 0x20000000;
				if (worldInfo->items[i].green)
					type |= 0x40000000;
				if (worldInfo->items[i].blue)
					type |= 0x80000000;
				int adminCount = 1;
				int ownerID = worldInfo->ownerID;// ((PlayerInfo*)peer->data)->userID;
				// int admins[...]
				int szExtra = 10 + adminCount * 4;
				memset(blockPtr + 8, 0, szExtra);
				BYTE btype = 0x3;
				BYTE o = 0x1;
				memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
				memcpy(blockPtr + 4, &type, 4);
				memcpy(blockPtr + 8, &btype, 1);
				memcpy(blockPtr + 8 + 2, &ownerID, 4);
				memcpy(blockPtr + 8 + 6, &adminCount, 1);
				memcpy(blockPtr + 8 + 10, &o, 1);
				sizeofblockstruct += szExtra;
				dataLen += szExtra;
			}

		}
		else if (worldInfo->items[i].foreground == 1008)
		{
			int type = 0x00000000;

			// type 1 = locked
			if (worldInfo->items[i].activated)
				type |= 0x00200000;
			if (worldInfo->items[i].flipped)
				type |= 0x00400000;
			if (worldInfo->items[i].water)
				type |= 0x04000000;
			if (worldInfo->items[i].glue)
				type |= 0x08000000;
			if (worldInfo->items[i].fire)
				type |= 0x10000000;
			if (worldInfo->items[i].red)
				type |= 0x20000000;
			if (worldInfo->items[i].green)
				type |= 0x40000000;
			if (worldInfo->items[i].blue)
				type |= 0x80000000;
			BYTE btype = 9;
			int timeIntoGrowth = 0;
			memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
			memcpy(blockPtr + 4, &type, 4);
			memcpy(blockPtr + 8, &btype, 1);
			memcpy(blockPtr + 9, &timeIntoGrowth, 4);
			sizeofblockstruct += 5;
			dataLen += 5;
		}
		else if (worldInfo->items[i].foreground == 6016)
		{
			int type = 0x00000000;

			// type 1 = locked
			if (worldInfo->items[i].activated)
				type |= 0x00200000;
			if (worldInfo->items[i].flipped)
				type |= 0x00400000;
			if (worldInfo->items[i].water)
				type |= 0x04000000;
			if (worldInfo->items[i].glue)
				type |= 0x08000000;
			if (worldInfo->items[i].fire)
				type |= 0x10000000;
			if (worldInfo->items[i].red)
				type |= 0x20000000;
			if (worldInfo->items[i].green)
				type |= 0x40000000;
			if (worldInfo->items[i].blue)
				type |= 0x80000000;
			BYTE btype = 9;
			memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
			memcpy(blockPtr + 4, &type, 4);
			memcpy(blockPtr + 8, &btype, 1);
			sizeofblockstruct += 5;
			dataLen += 5;
		}
		else if (worldInfo->items[i].foreground == 1452)
		{
		int type = 0x00000000;

		// type 1 = locked
		if (worldInfo->items[i].activated)
			type |= 0x00200000;
		if (worldInfo->items[i].flipped)
			type |= 0x00400000;
		if (worldInfo->items[i].water)
			type |= 0x04000000;
		if (worldInfo->items[i].glue)
			type |= 0x08000000;
		if (worldInfo->items[i].fire)
			type |= 0x10000000;
		if (worldInfo->items[i].red)
			type |= 0x20000000;
		if (worldInfo->items[i].green)
			type |= 0x40000000;
		if (worldInfo->items[i].blue)
			type |= 0x80000000;
		BYTE btype = 9;
		memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
		memcpy(blockPtr + 4, &type, 4);
		memcpy(blockPtr + 8, &btype, 1);
		sizeofblockstruct += 5;
		dataLen += 5;
		}
		else if (worldInfo->items[i].foreground == 2978)
		{
			int type = 0x00000000;

			// type 1 = locked
			if (worldInfo->items[i].activated)
				type |= 0x00200000;
			if (worldInfo->items[i].flipped)
				type |= 0x00400000;
			if (worldInfo->items[i].water)
				type |= 0x04000000;
			if (worldInfo->items[i].glue)
				type |= 0x08000000;
			if (worldInfo->items[i].fire)
				type |= 0x10000000;
			if (worldInfo->items[i].red)
				type |= 0x20000000;
			if (worldInfo->items[i].green)
				type |= 0x40000000;
			if (worldInfo->items[i].blue)
				type |= 0x80000000;



			int count = 0;
			int vend_id = 242;

			memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
			memcpy(blockPtr + 2, &worldInfo->items[i].background, 2);
			memcpy(blockPtr + 4, &type, 4);
			blockPtr[8] = 0x18;
			memcpy(blockPtr + 9, &vend_id, 4);
			memcpy(blockPtr + 13, &count, 4);
			sizeofblockstruct += 9;
			dataLen += 9;
		}



		else if ((worldInfo->items[i].foreground == 0) || (worldInfo->items[i].foreground == 2) || (worldInfo->items[i].foreground == 8) || (worldInfo->items[i].foreground == 100) || (worldInfo->items[i].foreground == 4) || (getItemDef(worldInfo->items[i].foreground).blockType == BlockTypes::FOREGROUND || getItemDef(worldInfo->items[i].foreground).blockType == BlockTypes::BACKGROUND || getItemDef(worldInfo->items[i].foreground).blockType == BlockTypes::TOGGLE_FOREGROUND || getItemDef(worldInfo->items[i].foreground).blockType == BlockTypes::CHEST || getItemDef(worldInfo->items[i].foreground).blockType == BlockTypes::SWITCH_BLOCK))
		{

			memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
			int type = 0;
			// type 1 = locked
			if (worldInfo->items[i].activated)
				type |= 0x00400000;
			if (worldInfo->items[i].flipped)
				type |= 0x00200000;
			if (worldInfo->items[i].water)
				type |= 0x04000000;
			if (worldInfo->items[i].glue)
				type |= 0x08000000;
			if (worldInfo->items[i].fire)
				type |= 0x10000000;
			if (worldInfo->items[i].red)
				type |= 0x20000000;
			if (worldInfo->items[i].green)
				type |= 0x40000000;
			if (worldInfo->items[i].blue)
				type |= 0x80000000;

			memcpy(blockPtr + 4, &type, 4);

			// int type = 0x04000000; = water
			// int type = 0x08000000 = glue
			// int type = 0x10000000; = fire
			// int type = 0x20000000; = red color
			// int type = 0x40000000; = green color
			// int type = 0x80000000; = blue color



			/*if (worldInfo->items[i].foreground % 2)
			{
				blockPtr += 6;
			}*/
		}
		else
		{
			memcpy(blockPtr, &zero, 2);
		}
		memcpy(blockPtr + 2, &worldInfo->items[i].background, 2);
		blockPtr += sizeofblockstruct;

	}

	dataLen += 8;
	int itemcount = worldInfo->droppedItems.size();
	int itemuid = worldInfo->droppedCount;
	memcpy(blockPtr, &itemcount, 4);
	memcpy(blockPtr + 4, &itemuid, 4);
	blockPtr += 8;

	int iteminfosize = 16;
	int itemSize = itemcount * iteminfosize;
	for (int i = 0; i < itemcount; i++)
	{
		int item = worldInfo->droppedItems[i].id;
		int count = worldInfo->droppedItems[i].count;
		int uid = worldInfo->droppedItems[i].uid + 1;
		float x = (float)worldInfo->droppedItems[i].x;
		float y = (float)worldInfo->droppedItems[i].y;
		memcpy(blockPtr, &item, 2);
		memcpy(blockPtr + 2, &x, 4);
		memcpy(blockPtr + 6, &y, 4);
		memcpy(blockPtr + 10, &count, 2);
		memcpy(blockPtr + 12, &uid, 4);
		blockPtr += iteminfosize;
		dataLen += iteminfosize;
	}
	dataLen += 100;
	blockPtr += 4;
	memcpy(blockPtr, &worldInfo->weather, 4);
	blockPtr += 4;


	offsetData = dataLen - 100;

	BYTE* data2 = new BYTE[101];
	memset(data2, 0, 101);
	memcpy(data2 + 0, &zero, 4);
	int weather = worldInfo->weather;
	memcpy(data2 + 4, &weather, 4);


	//cout << dataLen << " <- dataLen allocMem -> " << allocMem << endl;
	memcpy(data + dataLen - 4, &smth, 4);
	ENetPacket* packet2 = enet_packet_create(data,
		dataLen,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet2);
	((PlayerInfo*)(peer->data))->currentWorld = worldInfo->name;
	for (int i = 0; i < square; i++) {

		if ((worldInfo->items[i].foreground == 0) || (getItemDef(worldInfo->items[i].foreground).blockType) == BlockTypes::LOCK || (getItemDef(worldInfo->items[i].foreground).blockType == BlockTypes::FOREGROUND || getItemDef(worldInfo->items[i].foreground).blockType == BlockTypes::BACKGROUND || getItemDef(worldInfo->items[i].foreground).blockType == BlockTypes::CHEST || getItemDef(worldInfo->items[i].foreground).blockType == BlockTypes::SWITCH_BLOCK || getItemDef(worldInfo->items[i].foreground).blockType == BlockTypes::TOGGLE_FOREGROUND) || (worldInfo->items[i].foreground == 1008) || (worldInfo->items[i].foreground == 5000) || (getItemDef(worldInfo->items[i].foreground).blockType) == BlockTypes::SIGN || (getItemDef(worldInfo->items[i].foreground).blockType) == BlockTypes::DOOR || (getItemDef(worldInfo->items[i].foreground).blockType) == BlockTypes::PORTAL || worldInfo->items[i].foreground == 1420 || worldInfo->items[i].foreground == 6214 || (worldInfo->items[i].foreground == 3832) || (worldInfo->items[i].foreground == 2946) || (worldInfo->items[i].foreground == 6) || (worldInfo->items[i].foreground == 242) || (worldInfo->items[i].foreground == 1796) || (worldInfo->items[i].foreground == 4) || (worldInfo->items[i].foreground == 2) || (worldInfo->items[i].foreground == 8) || (worldInfo->items[i].foreground == 100))
			; // nothing
		else if (worldInfo->items[i].foreground == 3794)
		{
			int xx = i % xSize, yy = i / xSize;
			sendDShelf(peer, xx, yy, worldInfo->items[i].dshelf1, worldInfo->items[i].dshelf2, worldInfo->items[i].dshelf3, worldInfo->items[i].dshelf4);
		}
		else if (worldInfo->items[i].foreground == 5638)
		{
			int xx = i % xSize, yy = i / xSize;
			sendMag(peer, xx, yy, worldInfo->items[i].magitem, 1, worldInfo->items[i].magitem, worldInfo->items[i].magitem);
		}
		else if (worldInfo->items[i].foreground == 2978)
		{
			int x = i % xSize, y = i / xSize;
			if (worldInfo->items[i].intdata == 0 && worldInfo->items[i].price == 0) {

				updateVendMsg(peer, worldInfo->items[i].foreground, x, y, "`2Vending Machine\n`wOUT OF ORDER");
			}
			else if (worldInfo->items[i].intdata == 0 && worldInfo->items[i].peritem == true) {
				WorldInfo* world = getPlyersWorld(peer);
				PlayerInfo* pinfo = (PlayerInfo*)peer->data;
				int intvend = world->items[pinfo->wrenchedBlockLocation].intdata;
				string itemname = getItemDef(intvend).name;
				string sids = std::to_string(intvend);
				updateVendMsg(peer, worldInfo->items[i].foreground, x, y, "`2" + itemname + " Vending Machine\n`w" + sids + "  per World Locks");
			}
			else if (worldInfo->items[i].sold == true) {

				UpdateVend(peer, x, y, 0, true, 0);
			}
			else {
				UpdateVend(peer, x, y, worldInfo->items[i].intdata, false, worldInfo->items[i].price);
			}
		}
		else
		{
			PlayerMoving data;
			//data.packetType = 0x14=
			data.packetType = 0x3;
			/*   else if (IsGivingTree(worldInfo->blocks[i].foreground))
	{
		int adminCount = 0;
		int ownerID = worldInfo->owner;// ((PlayerInfo*)peer->data)->userID;
		// int admins[...]
		int szExtra = 7;
		if (blockPtr) memset(blockPtr + 8, 0, szExtra);
		BYTE btype = 0x1C;
		BYTE o = 0x1;
		int b = GetTimeIntoGrowth(worldInfo, i);
		byte c = worldInfo->blocks[i].intdata, a = 0;
		if (blockPtr) memcpy(blockPtr, &worldInfo->blocks[i].foreground, 2);
		if (blockPtr) memcpy(blockPtr + 4, &type, 4);
		if (blockPtr) memcpy(blockPtr + 8, &btype, 1);
		if (blockPtr) memcpy(blockPtr + 8 + 1, &a, 1);
		if (blockPtr) memcpy(blockPtr + 8 + 2, &b, 4);
		if (blockPtr) memcpy(blockPtr + 8 + 6, &c, 1);
		sizeofblockstruct += szExtra;
		dataLen += szExtra;
	}*/
	//data.characterState = 0x924; // animation
			data.characterState = 0x0; // animation
			data.x = i % worldInfo->width;
			data.y = i / worldInfo->height;
			data.punchX = i % worldInfo->width;
			data.punchY = i / worldInfo->width;
			data.XSpeed = 0;
			data.YSpeed = 0;
			data.netID = -1;
			data.plantingTree = worldInfo->items[i].foreground;
			SendPacketRaw(4, packPlayerMoving(&data), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);

			//int x = i % xSize, y = i / xSize;
			//UpdateVisualsForBlock(peer, false, x, y, worldInfo);
		}
	}
	for (int i = 0; i < xSize; i++) {
		for (int j = 0; j < ySize; j++) {
			int squaresign = i + (j * 100);
			if (worldInfo->items[squaresign].foreground == 6214 || worldInfo->items[squaresign].foreground == 1420 || worldInfo->items[squaresign].foreground == 10072 || worldInfo->items[squaresign].foreground == 10074 || worldInfo->items[squaresign].foreground == 10076 || worldInfo->items[squaresign].foreground == 10078)
			{
				int x = squaresign % worldInfo->width;
				int y = squaresign / worldInfo->width;
				updateMannequin(peer, worldInfo->items[squaresign].foreground, x, y, worldInfo->items[squaresign].background, worldInfo->items[squaresign].sign,
					worldInfo->items[squaresign].clothHair, worldInfo->items[squaresign].clothHead,
					worldInfo->items[squaresign].clothMask, worldInfo->items[squaresign].clothHand, worldInfo->items[squaresign].clothNeck,
					worldInfo->items[squaresign].clothShirt, worldInfo->items[squaresign].clothPants, worldInfo->items[squaresign].clothFeet,
					worldInfo->items[squaresign].clothBack, true, 0);
			}
		}
	}//donenek
	for (int i = 0; i < xSize; i++) {
		for (int j = 0; j < ySize; j++) {
			int squaresign = i + (j * 100);
			if (worldInfo->items[squaresign].foreground == 1452)
			{
				int x = squaresign % worldInfo->width;
				int y = squaresign / worldInfo->width;
				if (worldInfo->items[squaresign].donate1 != 0) {
					visual::SendDonateData(peer, worldInfo->items[squaresign].foreground, worldInfo->items[squaresign].background, x, y, 1);
				}
			}
		}
	}
	// seed tangina
	for (int i = 0; i < xSize; i++) {
		for (int j = 0; j < ySize; j++) {
			int squaresign = i + (j * 100);
			if (getItemDef(worldInfo->items[squaresign].foreground).blockType == BlockTypes::SEED)
			{
				int x = squaresign % worldInfo->width;
				int y = squaresign / worldInfo->width;
				int val = rand() % 8;
				visual::updatetree(peer, worldInfo->items[squaresign].foreground, x, y, worldInfo->items[squaresign].background, val, 0, 0x00000000);
			}
		}
	}
	for (int i = 0; i < xSize; i++) {
		for (int j = 0; j < ySize; j++) {
			int squaresign = i + (j * 100);
			if (getItemDef(worldInfo->items[squaresign].foreground).blockType == BlockTypes::GATEWAY)
			{
				int x = squaresign % worldInfo->width;
				int y = squaresign / worldInfo->width;
				int fg = worldInfo->items[squaresign].foreground;
				int bg = worldInfo->items[squaresign].background;
				WorldInfo* world = getPlyersWorld(peer);
				if (worldInfo->items[squaresign].isopen) {
					if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 20 || ((PlayerInfo*)(peer->data))->rawName == "zeyrox") {
						visual::updateEntrance(peer, fg, x, y, true, bg);
					}
					else {
						visual::updateEntrance(peer, fg, x, y, true, bg);
					}
				}
				else {
					if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 20 || ((PlayerInfo*)(peer->data))->rawName == "zeyrox") {
						visual::updateEntrance(peer, fg, x, y, true, bg);
					}
					else {
						visual::updateEntrance(peer, fg, x, y, false, bg);
					}
				}
			}
		}
	}
	for (int i = 0; i < xSize; i++) {
		for (int j = 0; j < ySize; j++) {
			int squaresign = i + (j * 100);
			if (worldInfo->items[squaresign].foreground == 2946)
			{
				if (worldInfo->items[squaresign].display != 0) {
					int x = squaresign % worldInfo->width;
					int y = squaresign / worldInfo->width;
					SendDisplayBlock(peer, worldInfo->items[squaresign].foreground, worldInfo->items[squaresign].background, x, y, worldInfo->items[squaresign].display);
				}
			}
		}
	}
	for (int i = 0; i < xSize; i++) {
		if ((worldInfo->items[i].foreground == 0) || (getItemDef(worldInfo->items[i].foreground).blockType) == BlockTypes::SIGN || worldInfo->items[i].foreground == 6016 || worldInfo->items[i].foreground == 1420 || worldInfo->items[i].foreground == 6214 || (worldInfo->items[i].foreground == 3832) || (worldInfo->items[i].foreground == 2946) || (worldInfo->items[i].foreground == 6) || (worldInfo->items[i].foreground == 4) || (worldInfo->items[i].foreground == 2) || (worldInfo->items[i].foreground == 8) || (worldInfo->items[i].foreground == 100))
			;
		else
		{
			PlayerMoving data;
			//data.packetType = 0x14;
			data.packetType = 0x3;

			//data.characterState = 0x924; // animation
			data.characterState = 0x0; // animation
			data.x = i % worldInfo->width;
			data.y = i / worldInfo->height;
			data.punchX = i % worldInfo->width;
			data.punchY = i / worldInfo->width;
			data.XSpeed = 0;
			data.YSpeed = 0;
			data.netID = -1;
			data.plantingTree = worldInfo->items[i].foreground;
			SendPacketRaw(4, packPlayerMoving(&data), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
			int x = i % xSize, y = i / xSize;
			UpdateBlockState(peer, x, y, true, worldInfo);
		}
	}

	int otherpeople = 0;
	int count = 0;
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		count++;
		if (isHere(peer, currentPeer))
			otherpeople++;
	}


	string act = ((PlayerInfo*)(peer->data))->currentWorld;
	sendState(peer);
	if (worldInfo->weather == 29) {
		updateStuffWeather(peer, 0, 0, worldInfo->rainitem, 0, worldInfo->stuffgrav, false, false);
	}
	else {
		GamePacket p7 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), worldInfo->weather));
		ENetPacket* packet7 = enet_packet_create(p7.data,
			p7.len,
			ENET_PACKET_FLAG_RELIABLE);

		enet_peer_send(peer, 0, packet7);
		delete p7.data;
	}
	string nameworld = worldInfo->name;
	string ownerworld = worldInfo->owner;
	string accessname = "";
	for (std::vector<string>::const_iterator i = worldInfo->acclist.begin(); i != worldInfo->acclist.end(); ++i) {
		accessname = *i;
	}
	if (worldInfo->owner == ((PlayerInfo*)(peer->data))->rawName)
	{

		GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `5[`0" + nameworld + " `$World Locked `oby " + ownerworld + " ``(`2ACCESS GRANTED``)`5]"));
		ENetPacket* packet3 = enet_packet_create(p3.data,
			p3.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet3);
		delete p3.data;





	}
	else if (((PlayerInfo*)(peer->data))->rawName == accessname)
	{

		GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `5[`0" + nameworld + " `$World Locked `oby " + ownerworld + " ``(`2ACCESS GRANTED``)`5]"));
		ENetPacket* packet3 = enet_packet_create(p3.data,
			p3.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet3);
		delete p3.data;





	}
	else if (((PlayerInfo*)(peer->data))->adminLevel == 1337)
	{
		if (ownerworld != "") {
			GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `5[`0" + nameworld + " `$World Locked `oby " + ownerworld + " ``(`2ACCESS GRANTED``)`5]"));
			ENetPacket* packet3 = enet_packet_create(p3.data,
				p3.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet3);
			delete p3.data;

		}





	}

	else
	{

		if (ownerworld != "") {
			GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `5[`0" + nameworld + " `$World Locked `oby " + ownerworld + "`5]"));
			ENetPacket* packet3 = enet_packet_create(p3.data,
				p3.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet3);
			delete p3.data;
		}
	}

	delete data;
}
void joinWorld(ENetPeer* peer, string act, int x2, int y2)
{
	try {
		WorldInfo info = worldDB.get(act);
		sendWorld(peer, &info);


		int x = 3040;
		int y = 736;

		for (int j = 0; j < info.width * info.height; j++)
		{
			if (info.items[j].foreground == 6) {
				x = (j % info.width) * 32;
				y = (j / info.width) * 32;
			}
		}
		if (x2 != 0 && y2 != 0)
		{
			x = x2;
			y = y2;
		}
		int id = 244;
		int uid = ((PlayerInfo*)(peer->data))->userID;
		if (((PlayerInfo*)(peer->data))->adminLevel >= 19)
		{

			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + std::to_string(cId) + "\nuserID|" + std::to_string(uid) + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(x) + "|" + std::to_string(y) + "\nname|``" + ((PlayerInfo*)(peer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(peer->data))->country + "|" + std::to_string(id) + "\ninvis|0\nmstate|0\nsmstate|1\ntype|local\n"));
			//GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + std::to_string(cId) + "\nuserID|" + std::to_string(cId) + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(x) + "|" + std::to_string(y) + "\nname|``" + ((PlayerInfo*)(peer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(peer->data))->country + "\ninvis|0\nmstate|0\nsmstate|0\ntype|local\n"));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;
		}
		else
		{

			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + std::to_string(cId) + "\nuserID|" + std::to_string(uid) + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(x) + "|" + std::to_string(y) + "\nname|``" + ((PlayerInfo*)(peer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(peer->data))->country + "|" + std::to_string(id) + "\ninvis|0\nmstate|0\nsmstate|0\ntype|local\n"));
			//GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + std::to_string(cId) + "\nuserID|" + std::to_string(cId) + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(x) + "|" + std::to_string(y) + "\nname|``" + ((PlayerInfo*)(peer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(peer->data))->country + "\ninvis|0\nmstate|0\nsmstate|0\ntype|local\n"));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);

			delete p.data;
		}


		((PlayerInfo*)(peer->data))->netID = cId;
		onPeerConnect(peer);
		cId++;
		sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);


		WorldInfo* world = getPlyersWorld(peer);
		string nameworld = world->name;
		string ownerworld = world->owner;
		int count = 0;
		ENetPeer* currentPeer;
		string name = "";
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			count++;
		}


		{
			ENetPeer* currentPeer;

			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
					continue;
				if (isHere(peer, currentPeer))
				{


					GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
					ENetPacket* packet2 = enet_packet_create(p2.data,
						p2.len,
						ENET_PACKET_FLAG_RELIABLE);

					enet_peer_send(currentPeer, 0, packet2);
					delete p2.data;
					continue;
				}
			}
		}


		int otherpeople = 0;

		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer))
				otherpeople++;
		}
		int otherpeoples = otherpeople - 1;

		GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oWorld `0" + nameworld + " `oentered. There are `0" + std::to_string(otherpeoples) + " `oother people here`7, `0" + std::to_string(count) + " `oonline."));
		ENetPacket* packet2 = enet_packet_create(p2.data,
			p2.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet2);
		delete p2.data;

		GamePacket p22 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `5<`w" + ((PlayerInfo*)(peer->data))->displayName + "`` `5entered, `w" + std::to_string(otherpeoples) + "`` others here>``"));

		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				{

					ENetPacket* packet2 = enet_packet_create(p22.data,
						p22.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(currentPeer, 0, packet2);
					sendSound(currentPeer, "door_open.wav");
				}
			}
		}
	}
	catch (int e) {
		if (e == 1) {
			((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oYou have exited the world."));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;
			//enet_host_flush(server);
		}
		else if (e == 2) {
			((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oYou have entered bad characters in the world name!"));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;
			//enet_host_flush(server);
		}
		else if (e == 3) {
			((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oExit from what? Click back if you're done playing."));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;
			//enet_host_flush(server);
		}
		else {
			((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oI know this menu is magical and all, but it has its limitations! You can't visit this world!"));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;
			//enet_host_flush(server);
		}
	}
}
void autosave()
{
	bool exist = std::experimental::filesystem::exists("save.txt");
	if (!exist)
	{
		ofstream save("save.txt");
		save << 0;
		save.close();
	}
	std::ifstream ok("save.txt");
	std::string limits((std::istreambuf_iterator<char>(ok)),
		(std::istreambuf_iterator<char>()));
	int a = atoi(limits.c_str());
	if (a == 0)
	{
		ofstream ok;
		ok.open("save.txt");
		ok << 50;
		ok.close();
		worldDB.saveAll();
		cout << "[!]Auto Saving Worlds" << endl;
	}
	else
	{
		int aa = a - 1;
		ofstream ss;
		ss.open("save.txt");
		ss << aa;
		ss.close();
		if (aa == 0)
		{
			ofstream ok;
			ok.open("save.txt");
			ok << 50;
			ok.close();
			worldDB.saveAll();
			cout << "[!]Auto Saving Worlds" << endl;
		}
	}
}
void doublejump(ENetPeer* peer)
{
	if (((PlayerInfo*)(peer->data))->cloth_back != 0) {
		((PlayerInfo*)(peer->data))->canDoubleJump = true;
	}
}
void updateInvis(ENetPeer* peer)
{
	ENetPeer* currentPeer;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer))
		{
			autosave();
			GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnInvis"), ((PlayerInfo*)(peer->data))->isInvisible));

			memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
			ENetPacket* packet2 = enet_packet_create(p2.data,
				p2.len,
				ENET_PACKET_FLAG_RELIABLE);

			enet_peer_send(currentPeer, 0, packet2);
			delete p2.data;

			GamePacket p3 = packetEnd(appendInt(appendString(createPacket(), "OnInvis"), ((PlayerInfo*)(currentPeer->data))->isInvisible));

			memcpy(p3.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
			ENetPacket* packet3 = enet_packet_create(p3.data,
				p3.len,
				ENET_PACKET_FLAG_RELIABLE);

			enet_peer_send(peer, 0, packet3);
			delete p3.data;


			GamePacket p2ww = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), ((PlayerInfo*)(peer->data))->country + "|showGuild"));
			memcpy(p2ww.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
			ENetPacket* packet2ww = enet_packet_create(p2ww.data,
				p2ww.len,
				ENET_PACKET_FLAG_RELIABLE);

			enet_peer_send(currentPeer, 0, packet2ww);
			delete p2ww.data;
			GamePacket p2wwee = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), ((PlayerInfo*)(currentPeer->data))->country + "|showGuild"));
			memcpy(p2wwee.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
			ENetPacket* packet2wwee = enet_packet_create(p2wwee.data,
				p2wwee.len,
				ENET_PACKET_FLAG_RELIABLE);

			enet_peer_send(peer, 0, packet2wwee);
			delete p2wwee.data;

			int flag1 = (65536 * ((PlayerInfo*)(peer->data))->guildBg) + ((PlayerInfo*)(peer->data))->guildFg;
			GamePacket p2gg = packetEnd(appendIntx(appendIntx(appendIntx(appendIntx(appendString(createPacket(), "OnGuildDataChanged"), 41179607), 41179607), flag1), 0));

			memcpy(p2gg.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
			ENetPacket* packet2gg = enet_packet_create(p2gg.data,
				p2gg.len,
				ENET_PACKET_FLAG_RELIABLE);

			enet_peer_send(currentPeer, 0, packet2gg);
			delete p2gg.data;
			int flag2 = (65536 * ((PlayerInfo*)(currentPeer->data))->guildBg) + ((PlayerInfo*)(currentPeer->data))->guildFg;
			GamePacket p2xd = packetEnd(appendIntx(appendIntx(appendIntx(appendIntx(appendString(createPacket(), "OnGuildDataChanged"), 41179607), 41179607), flag2), 0));

			memcpy(p2xd.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
			ENetPacket* packet2xd = enet_packet_create(p2xd.data,
				p2xd.len,
				ENET_PACKET_FLAG_RELIABLE);

			enet_peer_send(peer, 0, packet2xd);
			delete p2xd.data;
		}
		doublejump(peer);
	}
}

void sendPlayerLeave(ENetPeer* peer, PlayerInfo* player)
{
	//((PlayerInfo*)(peer->data))->cpX = 3040;
	//((PlayerInfo*)(peer->data))->cpY = 736;
	try {
		ENetPeer* currentPeer;
		((PlayerInfo*)(peer->data))->ischeck = false;
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnRemove"), "netID|" + std::to_string(player->netID) + "\n")); // ((PlayerInfo*)(server->peers[i].data))->tankIDName
		GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5<`w" + ((PlayerInfo*)(peer->data))->displayName + "`` `5left, `w" + std::to_string(getPlayersCountInWorld(player->currentWorld) - 1) + "`` `5others here>```w"));
		string name = ((PlayerInfo*)(peer->data))->displayName;
		string text = "action|play_sfx\nfile|audio/door_shut.wav\ndelayMS|0\n";
		BYTE* data = new BYTE[5 + text.length()];
		BYTE zero = 0;
		int type = 3;
		memcpy(data, &type, 4);
		memcpy(data + 4, text.c_str(), text.length());
		memcpy(data + 4 + text.length(), &zero, 1);
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (((PlayerInfo*)(currentPeer->data))->currentWorld == "EXIT")
				continue;
			if (((PlayerInfo*)(currentPeer->data))->isIn == false)
				continue;
			if (isHere(peer, currentPeer)) {
				{
					ENetPacket* packet = enet_packet_create(p.data,
						p.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packet);
					{
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(currentPeer, 0, packet);
						ENetPacket* packet3 = enet_packet_create(data,
							5 + text.length(),
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(currentPeer, 0, packet3);
					}
					if (((PlayerInfo*)(peer->data))->isinv == false)
					{
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(currentPeer, 0, packet2);
						GamePacket p4 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`5<`w" + ((PlayerInfo*)(peer->data))->displayName + "`` `5left, `w" + std::to_string(getPlayersCountInWorld(player->currentWorld) - 1) + "`` `5others here>```w"));
						ENetPacket* packet4 = enet_packet_create(p4.data,
							p4.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(currentPeer, 0, packet4);
						delete p4.data;
					}
				}
				{
				}
			}
		}
		delete p.data;
		delete p2.data;
		delete[] data;
	}
	catch (...) {
		cout << "error in void sendplayerleave";
		enet_peer_disconnect(peer, 0);
		return;
	}
}
void sendPlayerToPlayer(ENetPeer* peer, ENetPeer* otherpeer)
{
	try {
		{
			sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
		}
		WorldInfo info = worldDB.get(((PlayerInfo*)(otherpeer->data))->currentWorld);
		sendWorld(peer, &info);


		int x = ((PlayerInfo*)(otherpeer->data))->x;
		int y = ((PlayerInfo*)(otherpeer->data))->y;


		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + std::to_string(cId) + "\nuserID|" + std::to_string(((PlayerInfo*)(peer->data))->userID) + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(x) + "|" + std::to_string(y) + "\nname|``" + ((PlayerInfo*)(peer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(peer->data))->country + "\ninvis|0\nmstate|0\nsmstate|0\ntype|local\n"));


		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);


		delete p.data;
		((PlayerInfo*)(peer->data))->netID = cId;
		onPeerConnect(peer);
		cId++;


		sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
	}
	catch (...) {
		cout << "error in void sendplayertoplayer";
		enet_peer_disconnect(peer, 0);
		return;
	}
}

string timegt() {
#pragma warning(disable: 4996)
	time_t currentTime;
	struct tm* localTime;
	char buffer[80];

	time(&currentTime); // Get the current time
	localTime = localtime(&currentTime); // Convert the current time to the local time

	int yer = localTime->tm_year + 1900;
	int Mon = localTime->tm_mon + 1;
	int Day = localTime->tm_mday;
	int Hour = localTime->tm_hour;
	int Min = localTime->tm_min;
	int Sec = localTime->tm_sec;

	strftime(buffer, sizeof(buffer), "%d/%m/%Y", localTime);
	std::string str(buffer);

	return str;
}
bool hasPassed1(string dw) {
	string ee = timegt();
	bool result = false;
	vector<string> ex1 = explode("/", ee);
	int d1 = stoi(ex1[0]);
	int m1 = stoi(ex1[1]);
	int y1 = stoi(ex1[2]);

	vector<string> ex = explode("/", dw);
	int d = stoi(ex[0]);
	int m = stoi(ex[1]);
	int y = stoi(ex[2]);

	if (y1 >= y) {
		if (m1 >= m) {
			if (d1 > d) {
				result = true;
			}
		}
	}
	return result;
}
string getExpire3(string name) {
	string result = "";
	std::ifstream ads("atm.txt");
	for (std::string line; getline(ads, line);)
	{
		std::transform(name.begin(), name.end(), name.begin(), ::tolower);
		std::transform(line.begin(), line.end(), line.begin(), ::tolower);
		vector<string> ex = explode("|", line);
		if (ex[0] == name) {
			if (ex[1] == "perma") {
				result = "69/420/1337";
			}
			else {
				result = ex[1];
			}
		}
	}
	return result;
}
int checkatm(string name) {
	std::ifstream ads("atm.txt");
	int result = 0;
	for (std::string line; getline(ads, line);)
	{
		std::transform(name.begin(), name.end(), name.begin(), ::tolower);
		std::transform(line.begin(), line.end(), line.begin(), ::tolower);
		vector<string> ex = explode("|", line);
		if (ex[0] == name) {
			if (ex[1] == "perma") {
				return 2;
			}
			else {
				if (hasPassed1(ex[1]))
					result = 1;
				else
					result = 2;
			}

		}
	}
	printf(to_string(result).c_str());
	return result;
}
bool hasPassed2(string dw) {
	string ee = timegt();
	bool result = false;
	vector<string> ex1 = explode("/", ee);
	int d1 = stoi(ex1[0]);
	int m1 = stoi(ex1[1]);
	int y1 = stoi(ex1[2]);

	vector<string> ex = explode("/", dw);
	int d = stoi(ex[0]);
	int m = stoi(ex[1]);
	int y = stoi(ex[2]);

	if (y1 >= y) {
		if (m1 >= m) {
			if (d1 > d) {
				result = true;
			}
		}
	}
	return result;
}
string getExpire4(string name) {
	string result = "";
	std::ifstream ads("cow.txt");
	for (std::string line; getline(ads, line);)
	{
		std::transform(name.begin(), name.end(), name.begin(), ::tolower);
		std::transform(line.begin(), line.end(), line.begin(), ::tolower);
		vector<string> ex = explode("|", line);
		if (ex[0] == name) {
			if (ex[1] == "perma") {
				result = "69/420/1337";
			}
			else {
				result = ex[1];
			}
		}
	}
	return result;
}
int checkcow(string name) {
	std::ifstream ads("cow.txt");
	int result = 0;
	for (std::string line; getline(ads, line);)
	{
		std::transform(name.begin(), name.end(), name.begin(), ::tolower);
		std::transform(line.begin(), line.end(), line.begin(), ::tolower);
		vector<string> ex = explode("|", line);
		if (ex[0] == name) {
			if (ex[1] == "perma") {
				return 2;
			}
			else {
				if (hasPassed2(ex[1]))
					result = 1;
				else
					result = 2;
			}

		}
	}
	printf(to_string(result).c_str());
	return result;
}
bool hasPassed(string dw) {
	string ee = timegt();
	bool result = false;
	vector<string> ex1 = explode("/", ee);
	int d1 = stoi(ex1[0]);
	int m1 = stoi(ex1[1]);
	int y1 = stoi(ex1[2]);

	vector<string> ex = explode("/", dw);
	int d = stoi(ex[0]);
	int m = stoi(ex[1]);
	int y = stoi(ex[2]);

	if (y1 >= y) {
		if (m1 >= m) {
			if (d1 > d) {
				result = true;
			}
		}
	}
	return result;
}
string getExpire2(string name) {
	string result = "";
	std::ifstream ads("event.txt");
	for (std::string line; getline(ads, line);)
	{
		std::transform(name.begin(), name.end(), name.begin(), ::tolower);
		std::transform(line.begin(), line.end(), line.begin(), ::tolower);
		vector<string> ex = explode("|", line);
		if (ex[0] == name) {
			if (ex[1] == "perma") {
				result = "69/420/1337";
			}
			else {
				result = ex[1];
			}
		}
	}
	return result;
}
int checkmute(string name) {
	std::ifstream ads("event.txt");
	int result = 0;
	for (std::string line; getline(ads, line);)
	{
		std::transform(name.begin(), name.end(), name.begin(), ::tolower);
		std::transform(line.begin(), line.end(), line.begin(), ::tolower);
		vector<string> ex = explode("|", line);
		if (ex[0] == name) {
			if (ex[1] == "perma") {
				return 2;
			}
			else {
				if (hasPassed(ex[1]))
					result = 1;
				else
					result = 2;
			}

		}
	}
	printf(to_string(result).c_str());
	return result;
}
void sendPlayerToWorldss(ENetPeer* peer, PlayerInfo* player, string wrldname, int x_ = -1, int y_ = -1)
{




	toUpperCase(wrldname);
	if (wrldname == "CON" || wrldname == "NUL" || wrldname == "PRN" || wrldname == "AUX" || wrldname == "CLOCK$" || wrldname == "COM0" || wrldname == "COM1" || wrldname == "COM2" || wrldname == "COM3" || wrldname == "COM4" || wrldname == "COM5" || wrldname == "COM6" || wrldname == "COM7" || wrldname == "COM8" || wrldname == "COM9" || wrldname == "LPT0" || wrldname == "LPT1" || wrldname == "LPT2" || wrldname == "LPT3" || wrldname == "LPT4" || wrldname == "LPT5" || wrldname == "LPT6" || wrldname == "LPT7" || wrldname == "LPT8" || wrldname == "LPT9")
	{
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `eWhoops! `wThis `oworld`w can't be warped to, as it is used by `4System`w.``"));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);

		delete p.data;
	}
	else
	{
		{
			sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
		}

		WorldInfo info = worldDB.get(wrldname);
		sendWorld(peer, &info);



		int x = 3040;
		int y = 736;

		if (x_ != -1 && y_ != -1) { x = x_ * 32; y = y_ * 32; }
		int uid = ((PlayerInfo*)(peer->data))->userID;
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + std::to_string(cId) + "\nuserID|" + std::to_string(uid) + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(x) + "|" + std::to_string(y) + "\nname|``" + ((PlayerInfo*)(peer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(peer->data))->country + "\ninvis|0\nmstate|0\nsmstate|0\ntype|local\n"));


		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);


		delete p.data;
		((PlayerInfo*)(peer->data))->netID = cId;
		onPeerConnect(peer);
		cId++;


		sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);




	}
}


void SendParticleEffect(ENetPeer* peer, int particle, float x, float y)
{
	try {
		gamepacket_t p;
		p.Insert("OnParticleEffect");
		p.Insert(particle);
		p.Insert(x, y);
		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				p.CreatePacket(currentPeer);
			}
		}
	}
	catch (...) {
		cout << "error in void sendparticleeffect";
		enet_peer_disconnect(peer, 0);
		return;
	}
}

bool isSeed(int block)
{
	return block % 2 == 1;
}
void treeModify(ENetPeer* peer, int x, int y, int causedBy) {

	PlayerMoving data_;
	data_.packetType = 0xC;
	data_.x = 0;
	data_.y = 0;
	data_.punchX = x;
	data_.punchY = y;
	data_.XSpeed = 0;
	data_.YSpeed = 0;
	data_.netID = causedBy;
	data_.plantingTree = 0;
	BYTE* raw = packPlayerMoving(&data_);
	raw[8] = 0xff; raw[9] = 0xff; raw[10] = 0xff; raw[11] = 0xff;
	SendPacketRaw(4, raw, 102, 0, peer, ENET_PACKET_FLAG_RELIABLE);
}
int getGemCount(int item) {
	int count = 0;
	try {
		int rarity = getItemDef(item).rarity;
		if (rarity == 0) return 0;
		if (rarity > 13) {
			count = rarity / 13;
		}
		else {
			int ran = rand() % 2;
			switch (ran) {
			case 1:
				count = 1;
				break;
			case 2:
				count = 2;
				break;
			default:
				count = 0;
				break;
			}
		}
	}
	catch (...) {
		return 0;
	}
	return count;
}
void processTakeServer(ENetPeer* peer, int itemIdx)
{
	PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
	WorldInfo* world = getPlyersWorld(peer);
	if (!world) return;
	bool legit = true;
	int atik = -1;
	int errcode = 1;
	for (int i = 0; i < world->droppedItems.size(); i++)
	{
		if (world->droppedItems.at(i).uid == itemIdx)
		{
			atik = i;
			break;
		}
	}
	legit = atik != -1;
	if (legit) {
		try {
			DroppedItem droppedItem = world->droppedItems.at(atik);
			world->droppedItems.erase(world->droppedItems.begin() + atik);
			if (droppedItem.id != 112) {
				if (CheckItemMaxed(peer, droppedItem.id, droppedItem.count))
				{
					Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`1(Item maxed)", 0, true);
					return;
				}
				if (CheckItemExists(peer, droppedItem.id) == false)
				{
					if (((PlayerInfo*)(peer->data))->inventory.items.size() == ((PlayerInfo*)(peer->data))->currentInventorySize) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`1(Inventory is full)", 0, true);
						return;
					}
				}
				bool success = true;
				SaveShopsItemMoreTimes(droppedItem.id, droppedItem.count, peer, success);
				int rarity = getItemDef(droppedItem.id).rarity;
				if (rarity <= 998) {
					SendConsoleMsg(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o. Rarity: `w" + to_string(getItemDef(droppedItem.id).rarity) + "`o.");
				}
				else {
					Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o.``");
				}
			}
			else {
				pinfo->gem += droppedItem.count;
				GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
				int respawnTimeout = 1000;
				int deathFlag = 0x19;
				memcpy(pp.data + 24, &respawnTimeout, 4);
				memcpy(pp.data + 56, &deathFlag, 4);
				ENetPacket* packetpp = enet_packet_create(pp.data,
					pp.len,
					ENET_PACKET_FLAG_RELIABLE);

				enet_peer_send(peer, 0, packetpp);
				delete pp.data;
			}

		}
		catch (...) {
			return;
		}
	}
}
int DropItem(ENetPeer* peer, int netID, int x, int y, int item, int count, BYTE specialEffect)
{
	WorldInfo* world = getPlyersWorld(peer);
	if (!world) return -1;
	if (item < 0)  return -1;
	if (x == 0 || y == 0)  return -1;
	int blockX = x / 32;
	int blockY = y / 32;

	if (blockX<0 || blockY<0 || blockX>world->width || blockY>world->height) return -1;
	try {
		int blockX = x / 32;
		int blockY = y / 32;
		bool e = false;
		if (item == 112)
		{
			if (world->maggemc == true) {
				world->maggems += count;
				return -1;
			}
			else {
				if (count == 1) world->items[blockX + (blockY * world->width)].yellowGems++;
				if (count == 5) world->items[blockX + (blockY * world->width)].blueGems++;
				if (count == 10) world->items[blockX + (blockY * world->width)].redGems++;
				if (count == 50) world->items[blockX + (blockY * world->width)].greenGems++;
				if (count == 100) world->items[blockX + (blockY * world->width)].purpleGems++;
				vector<int> idstoremove;


				if (world->items[blockX + (blockY * world->width)].yellowGems > 4)
				{
					for (int i = 0; i < world->droppedItems.size(); i++) {
						if (blockX == (int)(world->droppedItems.at(i).x / 32) && blockY == (int)(world->droppedItems.at(i).y / 32)) {
							if (world->droppedItems.at(i).count == 1) {

								RemoveDroppedItem(peer, world->droppedItems.at(i).uid, world);
								idstoremove.push_back(world->droppedItems.at(i).uid);

							}
						}
					}
					world->items[blockX + (blockY * world->width)].yellowGems = 0;
					world->items[blockX + (blockY * world->width)].blueGems++;
					count = 5;
					e = true;
				}
				if (world->items[blockX + (blockY * world->width)].blueGems > 1) {
					for (int i = 0; i < world->droppedItems.size(); i++) {
						if (blockX == (int)(world->droppedItems.at(i).x / 32) && blockY == (int)(world->droppedItems.at(i).y / 32)) {
							if (world->droppedItems.at(i).count == 5) {

								RemoveDroppedItem(peer, world->droppedItems.at(i).uid, world);
								idstoremove.push_back(world->droppedItems.at(i).uid);

							}
						}
					}
					world->items[blockX + (blockY * world->width)].blueGems = 0;
					world->items[blockX + (blockY * world->width)].redGems++;
					count = 10;
					e = true;
				}
				if (world->items[blockX + (blockY * world->width)].redGems > 4) {
					for (int i = 0; i < world->droppedItems.size(); i++) {
						if (blockX == (int)(world->droppedItems.at(i).x / 32) && blockY == (int)(world->droppedItems.at(i).y / 32)) {
							if (world->droppedItems.at(i).count == 10) {

								RemoveDroppedItem(peer, world->droppedItems.at(i).uid, world);
								idstoremove.push_back(world->droppedItems.at(i).uid);

							}
						}
					}
					world->items[blockX + (blockY * world->width)].redGems = 0;
					world->items[blockX + (blockY * world->width)].greenGems++;
					count = 50;
					e = true;
				}
				if (world->items[blockX + (blockY * world->width)].greenGems > 1) {
					for (int i = 0; i < world->droppedItems.size(); i++) {
						if (blockX == (int)(world->droppedItems.at(i).x / 32) && blockY == (int)(world->droppedItems.at(i).y / 32)) {
							if (world->droppedItems.at(i).count == 50) {

								RemoveDroppedItem(peer, world->droppedItems.at(i).uid, world);
								idstoremove.push_back(world->droppedItems.at(i).uid);

							}
						}
					}
					world->items[blockX + (blockY * world->width)].greenGems = 0;
					world->items[blockX + (blockY * world->width)].purpleGems++;
					count = 100;
					e = true;

				}
				for (int i = 0; i < idstoremove.size(); i++) processTakeServer(peer, idstoremove.at(i));
			}
		}
		for (int i = 0; i < world->width * world->height; i++)
		{
			if (world->items[i].foreground == 5638) {
				if (item == world->items[i].magitem && world->items[i].magcollect == true) {
					ENetPeer* currentPeer;
					for (currentPeer = server->peers;
						currentPeer < &server->peers[server->peerCount];
						++currentPeer)
					{
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
							continue;
						if (isHere(peer, currentPeer)) {
							SendThrowEffect(currentPeer, item, netID, -1, 150, 5, world->items[i].magX * 32 + 16, world->items[i].magY * 32 + 16);
						}
					}
					world->items[i].magcount += count;
					return -1;
				}
			}
		}
		DroppedItem itemDropped;
		itemDropped.id = item;
		itemDropped.count = count;
		itemDropped.x = x;
		itemDropped.y = y;
		itemDropped.uid = world->droppedCount++;
		world->droppedItems.push_back(itemDropped);
		sendDrop(peer, netID, x, y, item, count, specialEffect);
		return world->droppedCount - 1;
	}
	catch (...) {
		return 1;
	}
}
void sendTileUpdate(int x, int y, int tile, int causedBy, ENetPeer* peer)
{
	bool isLock = false;
	bool ismonitor = false;
	bool ismag = false;
	bool isTree = false;
	PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
	PlayerMoving data;
	data.packetType = 0x3;
	data.characterState = 0x0;
	data.x = x;
	data.y = y;
	data.punchX = x;
	data.punchY = y;
	data.XSpeed = 0;
	data.YSpeed = 0;
	data.netID = causedBy;
	data.plantingTree = tile;
	WorldInfo* world = getPlyersWorld(peer);
	int netID = ((PlayerInfo*)(peer->data))->netID;
	int uid = ((PlayerInfo*)(peer->data))->userID;
	if (world == NULL) return;
	if (x < 0 || y < 0 || x >= 100 || y >= 60) return;
	int block = world->items[x + (y * world->width)].foreground;
	if (GetItemDef(tile).blockType == BlockTypes::SEED) {

		if (world->items[x + (y * world->width)].foreground != 0) {
			return;
		}
		else {
			isTree = true;

		}
	}
	int fg = world->items[x + (y * world->width)].foreground;
	int bg = world->items[x + (y * world->width)].background;
	/*if (world->items[x + (y * world->width)].foreground != 0) {
		if (!(world->items[x + (y * world->width)].foreground % 2 == 0)) {
			int idx = -1;
			for (int i = 0; i < supply.size(); i++) {
				if (supply[i].one == world->items[x + (y * world->width)].foreground && tile == supply[i].two || supply[i].two == world->items[x + (y * world->width)].foreground && tile == supply[i].one) idx = i;
			}
			if (idx != -1) {//to do add sounds
				int will = supply[idx].will + 1;
				world->items[x + (y * world->width)].foreground = will;
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`w" + getItemDef(supply[idx].one).name + " and The " + getItemDef(supply[idx].two).name + " have been spliced to make a `5" + getItemDef(will - 1).name + " Tree`w!", 0, true);
				sendmusic(peer, "success");
			}
			else return;
		}
		else return;
	}*/
	if (tile == 6336) {
		packet::dialog(peer, "\nadd_label_with_icon|big|Growtopia Royal (c) v3.47|left|6336|\nadd_spacer|small|\nadd_smalltext|`wCustom Items `2Updates :|left|\nadd_label_with_icon|small|`wAdded, MAGPLANT 5000 new texture! Working like real gt|left|5638|\nadd_label_with_icon|small|`wAdded, MAGPLANT Remote new texture! Working like real gt|left|5640|\nadd_label_with_icon|small|`wAdded, Royal Black! Our first farmable!|left|10358|\nadd_label_with_icon|small|`wAdded, Royal Pink! Our second farmable!|left|10384|\nadd_label_with_icon|small|`wAdded, Royal Sky! Our third farmable!|left|10380|\nadd_label_with_icon|small|`wAdded, Growyalpedia! This is what u are using now!|left|6336|\nadd_label_with_icon|small|`wAdded, Basker wings! Custom item from `6@Baskerville|left|5136|\nadd_label_with_icon|small|`wAdded, Golden Rayman's Fist! Have 8 far break!|left|7558|\nadd_spacer|small|\nend_dialog||Close|");
		return;
	}
	if (isSeed(world->items[x + (y * world->width)].foreground)) {
		if (((PlayerInfo*)(peer->data))->rawName != world->owner && ((PlayerInfo*)(peer->data))->adminLevel <= 0) {
			return;
		}
		if (tile == 18) {
			ENetPeer* currentPeer;
			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
					continue;
				if (isHere(peer, currentPeer)) {
					treeModify(currentPeer, x, y, netID);
					int chance = (rand() % 100) + 1;
					int numb = (rand() % 8) + 1;
					if (chance < 30) {



						DropItem(
							peer, -1,
							x * 32 + (rand() % 16),
							y * 32 + (rand() % 16),
							112,
							1, 0);

					}
					if (chance < 50) {
						Player::OnTalkBubble(peer, netID, "A " + GetItemDef(world->items[x + (y * world->width)].foreground).name + " seed falls out!", 0, false);
						DropItem(
							peer, -1,
							x * 32 - (rand() % 8),
							y * 32 + (rand() % 8),
							world->items[x + (y * world->width)].foreground,
							1, 0);
					}

					DropItem(
						peer, -1,
						x * 32 + (rand() % 16),
						y * 32 + (rand() % 16),
						world->items[x + (y * world->width)].foreground - 1,
						numb, 0);


					break;
				}
			}
		}
		world->items[x + (y * world->width)].foreground = 0;
		return;
	}
	if (tile == 5640)
	{
		try {
			PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
			if (world->items[x + (y * world->width)].foreground != 0 || world->items[x + (y * world->width)].background != 0) {
				return;
			}
			int xx = pinfo->wrenchedBlockLocation % world->width;
			int yy = pinfo->wrenchedBlockLocation / world->width;
			if (world->items[xx + (yy * world->width)].magcollect != true) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(((PlayerInfo*)(peer->data))->netID);
				p.Insert("`wThe `5MAGPLANT 5000 `wis disabled!");
				p.Insert(0);
				p.Insert(1);
				p.CreatePacket(peer);
				return;
			}
			else if (getItemDef(world->items[xx + (yy * world->width)].magitem).blockType != BlockTypes::CLOTHING || getItemDef(world->items[xx + (yy * world->width)].magitem).blockType != BlockTypes::CONSUMABLE) {
				if (world->items[xx + (yy * world->width)].magcount != 0) {
					ItemDefinition itemDef = getItemDef(world->items[xx + (yy * world->width)].magitem);
					if (itemDef.properties & Property_Untradable)
					{
						return;
					}
					else if (world->items[xx + (yy * world->width)].magitem == 18 || world->items[xx + (yy * world->width)].magitem == 32 || world->items[xx + (yy * world->width)].magitem == 112 || world->items[xx + (yy * world->width)].magitem == 242 || world->items[xx + (yy * world->width)].magitem == 1796 || world->items[xx + (yy * world->width)].magitem == 7188) {
						return;
					}
					world->items[xx + (yy * world->width)].magcount = world->items[xx + (yy * world->width)].magcount - 1;

					ENetPeer* currentPeer;

					for (currentPeer = server->peers;
						currentPeer < &server->peers[server->peerCount];
						++currentPeer)
					{
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
							continue;
						if (isHere(peer, currentPeer)) {
							PlayerMoving data;
							data.packetType = 0x3;
							data.characterState = 0x0;
							data.x = x;
							data.y = y;
							data.punchX = x;
							data.punchY = y;
							data.XSpeed = 0;
							data.YSpeed = 0;
							data.netID = -1;
							data.plantingTree = world->items[xx + (yy * world->width)].magitem;
							for (int i = 0; i < world->width * world->height; i++)
							{
								world->items[x + (y * world->width)].foreground = world->items[xx + (yy * world->width)].magitem;
							}
							SendPacketRaw(4, packPlayerMoving(&data), 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
						}
						continue;
					}
				}
				else {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(((PlayerInfo*)(peer->data))->netID);
					p.Insert("`wThe `5MAGPLANT 5000 `wis empty!");
					p.Insert(0);
					p.Insert(1);
					p.CreatePacket(peer);
					((PlayerInfo*)(peer->data))->wrenchedMagLocation = -1;
					bool iscontainsss12 = false;
					SearchInventoryItem(peer, 5640, 1, iscontainsss12);
					if (iscontainsss12)
					{
						int id = 5640;
						short int currentItemCount = 0;
						for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
						{
							if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == id)
							{
								currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
							}
						}
						RemoveInventoryItem(id, currentItemCount, peer);
					}
				}
			}
			else {
				return;
			}
		}
		catch (std::invalid_argument& e) {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(((PlayerInfo*)(peer->data))->netID);
			p.Insert("`wcrash witwtiwitwi");
			p.Insert(0);
			p.Insert(1);
			p.CreatePacket(peer);
			return;
		}
		catch (const std::out_of_range& e) {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(((PlayerInfo*)(peer->data))->netID);
			p.Insert("`wcrash witwtiwitwi");
			p.Insert(0);
			p.Insert(1);
			p.CreatePacket(peer);
			return;
		}
		catch (...) {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(((PlayerInfo*)(peer->data))->netID);
			p.Insert("`wcrash witwtiwitwi");
			p.Insert(0);
			p.Insert(1);
			p.CreatePacket(peer);
			return;
		}

		return;
	}
	if (world->items[x + (y * world->width)].foreground == 2978 && tile == 32) {
		PlayerInfo* pinfo = (PlayerInfo*)peer->data;
		if (x == pinfo->x / 32 && y == pinfo->y / 32) {
			pinfo->wrenchedBlockLocation = x + (y * world->width);
			if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->rawName == "baskerville" || ((PlayerInfo*)(peer->data))->rawName == "baskerville") {

				if (world->items[x + (y * world->width)].intdata != 0) {
					if (tile == 18) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(((PlayerInfo*)(peer->data))->netID);
						p.Insert("`wEmpty the item first!");
						p.Insert(0);
						p.Insert(1);
						p.CreatePacket(peer);
						return;
					}
					else {
						string pricee = std::to_string(world->items[x + (y * world->width)].price);
						string sid = std::to_string(world->items[x + (y * world->width)].intdata);
						string sname = getItemDef(world->items[x + (y * world->width)].intdata).name;
						string initial = "set_default_color|`o\n\nadd_label_with_icon|big|`wVending Machine``|left|2978|\nadd_spacer|small|\nadd_label_with_icon|small|`oThe machine contains 1 `2" + sname + "|left|" + sid + "|\nadd_spacer|small|\nadd_label|small|For a cost of:|\nadd_label_with_icon|small|" + pricee + " x `8World Locks|right|242|\nadd_spacer|small|\nadd_label|small|You will get:|\nadd_label_with_icon|small|1 x `2" + sname + "|right|" + sid + "|\nadd_spacer|small|\nadd_button|emptyvending123|Empty the machine|\nadd_smalltext|`5(Vending Machine will not function when price is set to 0)|\nadd_text_input|addprice|Price |" + pricee + "|6|\nadd_quick_exit|\nend_dialog|vendds|Close|Update";
						packet::dialog(peer, initial);
					}
				}
				else if (world->items[pinfo->wrenchedBlockLocation].intdata == 1785) {
					string empty = "set_default_color|`o\n\nadd_label_with_icon|big|`wVending Machine``|left|2978|\nadd_spacer|small|\nadd_label|small|`oThis machine is locked.|nadd_quick_exit|\nend_dialog|orderout|Close|";
					packet::dialog(peer, empty);
					return;
				}
				else if (world->items[x + (y * world->width)].sold == true) {
					if (tile == 18) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(((PlayerInfo*)(peer->data))->netID);
						p.Insert("`wEmpty the World Locks First!");
						p.Insert(0);
						p.Insert(1);
						p.CreatePacket(peer);
						return;
					}
					else {
						string pricee = std::to_string(world->items[x + (y * world->width)].price);
						string sid = std::to_string(world->items[x + (y * world->width)].intdata);
						string sname = getItemDef(world->items[x + (y * world->width)].intdata).name;
						string dialog = "set_default_color|`o\n\nadd_label_with_icon|big|`wVending Machine``|left|2978|\nadd_spacer|small|\nadd_label|small|`oYou have sold your item! Congrats|left|\nadd_spacer|small|\nadd_label|small|`oThis machine contains `2" + pricee + " `oWorld Locks.|\nadd_button|collectwls|Collect World Locks||nadd_quick_exit|\nend_dialog|emptyvends|Close|";
						packet::dialog(peer, dialog);
					}
				}
				else {
					string dialog = "set_default_color|`o\n\nadd_label_with_icon|big|`wVending Machine``|left|2978|\nadd_spacer|small|\nadd_label|small|`oThis machine is empty.|\nadd_item_picker|venditem|`wPut an item in|Choose an item you want to put in the machine!|nadd_quick_exit|\nend_dialog|emptyvends|Close|";
					packet::dialog(peer, dialog);

				}
			}
			else {
				if (world->items[x + (y * world->width)].price == 0) {
					string empty = "set_default_color|`o\n\nadd_label_with_icon|big|`wVending Machine``|left|2978|\nadd_spacer|small|\nadd_label|small|`oThis machine is out of order.|nadd_quick_exit|\nend_dialog|orderout|Close|";
					packet::dialog(peer, empty);
				}
				int pricez = world->items[x + (y * world->width)].price;
				if (world->items[x + (y * world->width)].intdata != 0) {
					string sid = std::to_string(world->items[x + (y * world->width)].intdata);
					string pricee = std::to_string(world->items[x + (y * world->width)].price);

					string sname = getItemDef(world->items[x + (y * world->width)].intdata).name;
					string buy = "set_default_color|`o\n\nadd_label_with_icon|big|`wVending Machine``|left|2978|\nadd_spacer|small|\nadd_label_with_icon|small|`oThe machine contains 1 `2" + sname + "|left|" + sid + "|\nadd_spacer|small|\nadd_label|small|For a cost of:|\nadd_label_with_icon|small|" + pricee + " x `8World Locks|right|242|\nadd_spacer|small|\nadd_label|small|You will get:|\nadd_label_with_icon|small|1 x `2" + sname + "|right|" + sid + "|\nadd_spacer|small|\nadd_text_input|buymanyhow|How many would you like to buy?||3||\nadd_quick_exit|\nend_dialog|buyvend|Close|Buy|";
					packet::dialog(peer, buy);

				}
				else if (world->items[x + (y * world->width)].intdata != 0 || world->items[x + (y * world->width)].peritem) {
					string sid = std::to_string(world->items[x + (y * world->width)].intdata);
					string pricee = std::to_string(world->items[x + (y * world->width)].price);

					string sname = getItemDef(world->items[x + (y * world->width)].intdata).name;
					string buy = "set_default_color|`o\n\nadd_label_with_icon|big|`wVending Machine``|left|2978|\nadd_spacer|small|\nadd_label_with_icon|small|`oThe machine contains 1 `2" + sname + "|left|" + sid + "|\nadd_spacer|small|\nadd_label|small|For a cost of:|\nadd_label_with_icon|small|1 x `8World Locks|right|242|\nadd_spacer|small|\nadd_label|small|You will get:|\nadd_label_with_icon|small|" + pricee + " x `2" + sname + "|right|" + sid + "|\nadd_spacer|small|\nadd_text_input|buymanyhow|How many would you like to buy?||3||\nadd_quick_exit|\nend_dialog|buyvend|Close|Buy|";
					packet::dialog(peer, buy);
				}
				else if (pricez == 0 || world->items[x + (y * world->width)].sold) {
					string empty = "set_default_color|`o\n\nadd_label_with_icon|big|`wVending Machine``|left|2978|\nadd_spacer|small|\nadd_label|small|`oThis machine is out of order.|nadd_quick_exit|\nend_dialog|orderout|Close|";
					packet::dialog(peer, empty);
				}

				else {
					string empty = "set_default_color|`o\n\nadd_label_with_icon|big|`wVending Machine``|left|2978|\nadd_spacer|small|\nadd_label|small|`oThis machine is empty.|nadd_quick_exit|\nend_dialog|venddsempty|Close|";
					packet::dialog(peer, empty);
				}
			}
		}
		else {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(((PlayerInfo*)(peer->data))->netID);
			p.Insert("Get closer!");
			p.Insert(0);
			p.CreatePacket(peer);
			return;
		}
	}
	if (world->items[x + (y * world->width)].foreground == 3794 && tile != 32) {
		bool iscontains = false;
		SearchInventoryItem(peer, tile, 1, iscontains);
		if (!iscontains)
		{
			enet_peer_disconnect(peer, 0);
			return;
		}
		if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1) {
			if (tile == 5480) {
				return;
			}
			if (tile == 18) {
				return;
			}
			if (world->items[x + (y * world->width)].dshelf1 == 0 && world->items[x + (y * world->width)].dshelf2 == 0 && world->items[x + (y * world->width)].dshelf3 == 0 && world->items[x + (y * world->width)].dshelf4 == 0) {

				world->items[x + (y * world->width)].dshelf1 = tile;
				RemoveInventoryItem(tile, 1, peer);
			}
			else if (world->items[x + (y * world->width)].dshelf1 != 0 && world->items[x + (y * world->width)].dshelf2 == 0 && world->items[x + (y * world->width)].dshelf3 == 0 && world->items[x + (y * world->width)].dshelf4 == 0) {

				world->items[x + (y * world->width)].dshelf2 = tile;
				RemoveInventoryItem(tile, 1, peer);
			}
			else if (world->items[x + (y * world->width)].dshelf1 != 0 && world->items[x + (y * world->width)].dshelf2 != 0 && world->items[x + (y * world->width)].dshelf3 == 0 && world->items[x + (y * world->width)].dshelf4 == 0) {

				world->items[x + (y * world->width)].dshelf3 = tile;
				RemoveInventoryItem(tile, 1, peer);
			}
			else if (world->items[x + (y * world->width)].dshelf1 != 0 && world->items[x + (y * world->width)].dshelf2 != 0 && world->items[x + (y * world->width)].dshelf3 != 0 && world->items[x + (y * world->width)].dshelf4 == 0) {

				world->items[x + (y * world->width)].dshelf4 = tile;
				RemoveInventoryItem(tile, 1, peer);
			}
			else {
				return;
			}

			ENetPeer* currentPeer;

			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
					continue;
				if (isHere(peer, currentPeer))
				{
					SendThrowEffect(currentPeer, tile, netID, -1, 150, 0, x * 32 + 16, y * 32 + 16);
					sendDShelf(currentPeer, x, y, world->items[x + (y * world->width)].dshelf1, world->items[x + (y * world->width)].dshelf2, world->items[x + (y * world->width)].dshelf3, world->items[x + (y * world->width)].dshelf4);
				}
			}
		}
	}
	if (world->items[x + (y * world->width)].foreground == 3794) {
		if (tile == 32) {
			if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 18) {
				pinfo->wrenchedBlockLocation = x + (y * world->width);
				string dshelf1;
				string dshelf2;
				string dshelf3;
				string dshelf4;
				if (world->items[x + (y * world->width)].dshelf1 != 0) {
					dshelf1 = "`4" + getItemDef(world->items[x + (y * world->width)].dshelf1).name + "";
				}
				else {
					dshelf1 = "`4EMPTY";
				}
				if (world->items[x + (y * world->width)].dshelf2 != 0) {
					dshelf2 = "`4" + getItemDef(world->items[x + (y * world->width)].dshelf2).name + "";
				}
				else {
					dshelf2 = "`4EMPTY";
				}
				if (world->items[x + (y * world->width)].dshelf3 != 0) {
					dshelf3 = "`4" + getItemDef(world->items[x + (y * world->width)].dshelf3).name + "";
				}
				else {
					dshelf3 = "`4EMPTY";
				}
				if (world->items[x + (y * world->width)].dshelf4 != 0) {
					dshelf4 = "`4" + getItemDef(world->items[x + (y * world->width)].dshelf4).name + "";
				}
				else {
					dshelf4 = "`4EMPTY";
				}
				string gscan = "set_default_color|`o\nadd_label_with_icon|big|`wDisplay Shelf``|left|3794|\nadd_spacer|small|\nadd_button|dshelf1|`2Shelf 1 : " + dshelf1 + "|left|\nadd_button|dshelf2|`2Shelf 2 : " + dshelf2 + "|left|\nadd_button|dshelf3|`2Shelf 3 : " + dshelf3 + "|left|\nadd_button|dshelf4|`2Shelf 4 : " + dshelf4 + "|left|\nadd_spacer|small|\nend_dialog||Close|";
				GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), gscan));
				ENetPacket* packet = enet_packet_create(p.data,
					p.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet);
				delete p.data;
			}
		}
		return;
	}
	if (world->items[x + (y * world->width)].foreground == 1452 && tile != 18 && tile != 32 && tile > 0) {//giatay
		if (world->items[x + (y * world->width)].counts1 == 10) {
			Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Donation box is `5full`w!", 0, true);
			return;
		}
		if (tile == world->items[x + (y * world->width)].donate1 && world->items[x + (y * world->width)].donate2 && world->items[x + (y * world->width)].donate3 && world->items[x + (y * world->width)].donate4 && world->items[x + (y * world->width)].donate5 && world->items[x + (y * world->width)].donate6 && world->items[x + (y * world->width)].donate7 && world->items[x + (y * world->width)].donate8 && world->items[x + (y * world->width)].donate9 && world->items[x + (y * world->width)].donate10) {
			Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wThe donation box already `4contains `wthis item!", 0, true);
			return;
		}
		pinfo->wrenchedBlockLocation = x + (y * world->width);
		string itename = getItemDef(tile).name;
		string sids = std::to_string(tile);
		WorldInfo* world = getPlyersWorld(peer);
		ItemDefinition itemDef = getItemDef(tile);
		pinfo->lastdonateitem = tile;
		short int currentItemCount = 0;
		for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
		{
			if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == pinfo->lastdonateitem)
			{
				currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
				if (currentItemCount < 0)
				{
					currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
				}
			}
		}
		packet::dialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|" + itename + "|left|" + sids + "|\nadd_label|small|`oHow many to put on donation box as a gift? (Note : You will `4LOSE `othe items you will give!)|left|\nadd_text_input|donate|Count:|" + to_string(currentItemCount) + "|7|\nend_dialog|senddonate|Cancel|`4Give the item(s)|left|");
	}
	if (world->items[x + (y * world->width)].foreground == 2946 && tile != 18 && tile != 32 && tile > 0) {
		if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->rawName == "baskerville") {
			int n = tile;
			if (n == 18 || n == 32 || n == 112) {
				{
					if (((PlayerInfo*)(peer->data))->adminLevel < 10) {
						Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Sorry, that wasn't possible.", 0, true);
						return;
					}
					else {

					}
				}
			}
			else if (getItemDef(n).blockType == BlockTypes::LOCK || n == 2946)
			{
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wSorry, no lock or display block.", 0, true);
				return;
			}
			else if (world->items[x + (y * world->width)].display == 0) {
				world->items[x + (y * world->width)].display = tile;
				int hi = data.punchX;
				int hi2 = data.punchY;
				short dfg = world->items[x + (y * world->width)].foreground;
				short dbg = world->items[x + (y * world->width)].background;
				ENetPeer* currentPeer;
				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer)) {
						SendThrowEffect(currentPeer, tile, netID, -1, 150, 0, x * 32 + 16, y * 32 + 16);
						SendDisplayBlock(currentPeer, dfg, dbg, hi, hi2, tile);
					}
				}
				RemoveInventoryItem(tile, 1, peer);
				return;
			}
			else {
				Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Remove what's in there first!", 0, true);
			}
		}
	}
	if (getItemDef(block).blockType == BlockTypes::GATEWAY && tile == 32) {
		int noclap = 0;
		bool casin = world->items[x + (y * world->width)].isopen;
		if (casin == true) {
			noclap = 1;
		}
		else {
			noclap = 0;
		}
		pinfo->wrenchedBlockLocation = x + (y * world->width);
		((PlayerInfo*)(peer->data))->wrenchx = x;
		((PlayerInfo*)(peer->data))->wrenchy = y;
		packet::dialog(peer, "add_label_with_icon|big|`wEdit " + itemDefs.at(world->items[x + (y * world->width)].foreground).name + "``|left|" + to_string(world->items[x + (y * world->width)].foreground) + "|\nadd_spacer|small|\nadd_checkbox|entrancepublic|`oPublic?|" + to_string(noclap) + "|\nend_dialog|editentranceo|Cancel|`wUpdate|\nadd_quick_exit|\n");
	}
	if (world->items[x + (y * world->width)].foreground == 6016 && tile == 32) {
		int noclap = 0;
		bool casin = world->gscanpublic;
		if (casin == true) {
			noclap = 1;
		}
		else {
			noclap = 0;
		}
		if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->rawName == "baskerville") {
			string gscan = "set_default_color|`o\nadd_label_with_icon|big|`wWorld Stats``|left|6016|\nadd_spacer|small|\nadd_textbox|`wThis amazing block can show the stats for the whole world!|\nadd_spacer|small|\nadd_textbox|`wWhich stats would you like to view?|\nadd_button|floatingitems|`oFloating Items|\nadd_spacer|small|\nadd_checkbox|tae1|`oFloating items is usable by public|" + to_string(noclap) + "|\nadd_space|small|\nend_dialog|gazettes|Cancel|Apply|";
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), gscan));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;
		}
		else if (world->gscanpublic == true) {
			string gscan = "set_default_color|`o\nadd_label_with_icon|big|`wWorld Stats``|left|6016|\nadd_spacer|small|\nadd_textbox|`wThis amazing block can show the stats for the whole world!|\nadd_spacer|small|\nadd_textbox|`wWhich stats would you like to view?|\nadd_button|floatingitems|`oFloating Items|\nadd_spacer|small|\nadd_smalltext|This growscan 9000 is publicly use by owner|left|\nadd_spacer|small|\nend_dialog|gazettes|Cancel|Apply|";
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), gscan));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;
		}

	}
	if (world->items[x + (y * world->width)].foreground == 2946 && tile == 32) {
		if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->rawName == "baskerville") {
			pinfo->wrenchedBlockLocation = x + (y * world->width);
			if (world->items[x + (y * world->width)].display == 0) {
				packet::dialog(peer, "add_label_with_icon|big|`wDisplay Block|left|2946|\nadd_spacer|small||\nadd_label|small|`oThe Display Block is empty. Use an item on it to display the item!|\nend_dialog||Close||\n");
			}
			else {
				packet::dialog(peer, "add_label_with_icon|big|`wDisplay Block|left|2946|\nadd_spacer|small||\nadd_label|small|`oA " + getItemDef(world->items[x + (y * world->width)].display).name + " is on display here.|\nadd_button|pickupdisplayitem|Pick it up|0|0|\nadd_quick_exit|\n");
			}
		}
		return;
	}
	if (world->items[x + (y * world->width)].foreground == 7562 && tile == 32) {
		string wtfs;
		if (world->maggems != 0) {
			wtfs += "\nadd_label|small|`oThis machine contains `w" + to_string(world->maggems) + " `6gems|left|\nadd_button|retgems|`wRetrieve `o" + to_string(world->maggems) + " `wgems!|left|";
		}
		else {
			wtfs += "\nadd_label|small|`oThe machine is currently empty|left|";
		}
		string wtfss;
		if (world->maggemc != true) {
			wtfss += "`5DISABLED";
		}
		else {
			wtfss += "`2ACTIVE";
		}
		int noclap = 0;
		bool casin = world->maggemc;
		if (casin == true) {
			noclap = 1;
		}
		else {
			noclap = 0;
		}
		if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 20 || ((PlayerInfo*)(peer->data))->rawName == "baskerville") {
			string dialog = "set_default_color|`o\n\nadd_label_with_icon|big|`wGEMPLANT UNLIMITED``|left|7562|\nadd_spacer|small|\nadd_label_with_icon|small|`2Gems|left|112|\nadd_smalltext|`oBuilding mode : " + wtfss + "|left|\nadd_spacer|small|\nadd_checkbox|gemplant|Activated?|" + std::to_string(noclap) + "|" + wtfs + "|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog||Cancel|Update|";
			packet::dialog(peer, dialog);
		}
	}
	if (world->items[x + (y * world->width)].foreground == 5638 && tile == 32) {
		if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 20 || ((PlayerInfo*)(peer->data))->rawName == "baskerville") {
			pinfo->wrenchedBlockLocation = x + (y * world->width);
			if (pinfo->wrenchedMagLocation != x + (y * world->width)) {
				pinfo->wrenchedMagLocation = x + (y * world->width);
			}
			((PlayerInfo*)(peer->data))->lastPunchX = x;
			((PlayerInfo*)(peer->data))->lastPunchY = y;
			string wtf;
			if (world->items[x + (y * world->width)].magcollect == true) {
				wtf += "`2Active";
			}
			else {
				wtf += "`5Disabled";
			}
			string wtfs;
			if (world->items[x + (y * world->width)].magcollect == true) {
				wtfs += "`oDisable";
			}
			else {
				wtfs += "`oEnable";
			}
			int noclap = 0;
			bool casin = world->items[x + (y * world->width)].magcollect;
			if (casin == true) {
				noclap = 1;
			}
			else {
				noclap = 0;
			}
			string jumlah = std::to_string(world->items[x + (y * world->width)].magcount);
			string type = std::to_string(world->items[x + (y * world->width)].magitem);
			string jenisitem = getItemDef(world->items[x + (y * world->width)].magitem).name;
			string sup;
			string jus;
			bool iscontains = false;
			SearchInventoryItem(peer, 5640, 1, iscontains);
			if (!iscontains) {
				sup += "\nadd_button|getremote1|Get remote|left|";
			}
			else {
				sup += "";
			}
			bool iscontainss = false;
			SearchInventoryItem(peer, world->items[x + (y * world->width)].magitem, 1, iscontainss);
			if (iscontainss) {
				int id = world->items[x + (y * world->width)].magitem;
				short int currentItemCount = 0;
				for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
				{
					if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == id)
					{
						currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
					}
				}
				jus += "\nadd_smalltext|Your inventory containts `2" + to_string(currentItemCount) + " `w" + jenisitem + "|left|\nadd_button|add1|Add them to the machine|left|\nadd_spacer|small|";
			}
			else {
				jus += "";
			}
			if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 20 || ((PlayerInfo*)(peer->data))->rawName == "baskerville") {
				if (world->items[x + (y * world->width)].magitem == 0 && world->items[x + (y * world->width)].magcount == 0) {
					string dialog = "set_default_color|`o\n\nadd_label_with_icon|big|`wMagplant 5000``|left|5638|\nadd_spacer|small|\nadd_smalltext|`6This machine is currently collecting `5Nothing|left|\nadd_item_picker|magplantitem|`wPut an item in|Choose an item you want to put in the machine!|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog||Cancel|Update|";
					packet::dialog(peer, dialog);
				}
				else if (world->items[x + (y * world->width)].magitem != 0 && world->items[x + (y * world->width)].magcount == 0) {
					string dialog = "set_default_color|`o\n\nadd_label_with_icon|big|`wMagplant 5000``|left|5638|\nadd_spacer|small|\nadd_label_with_icon|small|`2" + jenisitem + "|left|" + type + "|\nadd_smalltext|`oBuilding mode: " + wtf + "|left|\nadd_spacer|small|" + jus + "\nadd_checkbox|magplant1|" + wtfs + " Machine|" + std::to_string(noclap) + "|\nadd_label|small|`6This machine is currently `5EMPTY|left|\nadd_item_picker|magplantitem|`wChange item|Choose an item you want to put in the machine!|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog||Cancel|Update|";
					packet::dialog(peer, dialog);
				}
				else if (world->items[x + (y * world->width)].magitem != 0 && world->items[x + (y * world->width)].magcount >= 1) {
					string dialog = "set_default_color|`o\n\nadd_label_with_icon|big|`wMagplant 5000``|left|5638|\nadd_spacer|small|\nadd_label_with_icon|small|`2" + jenisitem + "|left|" + type + "|\nadd_smalltext|`oBuilding mode: " + wtf + "|left|\nadd_spacer|small|" + jus + "\nadd_checkbox|magplant1|" + wtfs + " Machine|" + std::to_string(noclap) + "|\nadd_label|small|`6This machine contains `5" + jumlah + " `2`2" + jenisitem + "|left|" + sup + "\nadd_button|claimdumb|Retrieve items|left|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog||Cancel|Update|";
					packet::dialog(peer, dialog);
				}

				string dialog = "set_default_color|`o\n\nadd_label_with_icon|big|`wMagplant 5000``|left|5638|\nadd_spacer|small|\nadd_label|small|`oCurrent Magplant Item: " + jenisitem + "|\nadd_smalltext|`5Building mode: " + wtf + "|left|\nadd_button|mag1|" + wtfs + " the machine|left|\nadd_spacer|small|" + jus + "\nadd_spacer|small|\nadd_label|small|`oThis machine contains : " + jumlah + " " + jenisitem + "|left|\nadd_button|claimdumb|`oRetrieve items|left|" + sup + "\nadd_spacer|small|\nadd_item_picker|magplantitem|`wPut an item in|Choose an item you want to put in the machine!|\nadd_quick_exit|\nend_dialog||Cancel|Update|";
				packet::dialog(peer, dialog);

			}
		}
		else {
			return;
		}
	}
	if (tile == 276) {
		bool succ = false;
		int netIDE = -1;
		int xo = -1;
		int yo = -1;
		RemoveInventoryItem(276, 1, peer);
		ENetPeer* currentPeer;
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				if (((PlayerInfo*)(currentPeer->data))->x > 0 && ((PlayerInfo*)(currentPeer->data))->y > 0) {
					int xVal = (int)((PlayerInfo*)(currentPeer->data))->x / 32;
					int yVal = (int)((PlayerInfo*)(currentPeer->data))->y / 32;
					if (xVal == x && yVal == y) {
						xo = ((PlayerInfo*)(currentPeer->data))->x;
						yo = ((PlayerInfo*)(currentPeer->data))->y;
						playerRespawn(currentPeer, false);
						netIDE = ((PlayerInfo*)(currentPeer->data))->netID;
						succ = true;
						break;
					}
				}
			}
		}
		if (succ) {
			if (netIDE != -1 && xo != -1 && yo != -1) {
				ENetPeer* currentPeer;
				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer)) {
						SendTradeEffect(currentPeer, 276, ((PlayerInfo*)(peer->data))->netID, netIDE, 0);
					}
				}
			}
		}
		return;
	}
	if (tile == 32)
	{
		if (world->items[x + (y * world->width)].foreground == 6952) {
			if (((PlayerInfo*)(peer->data))->haveGrowId && ((PlayerInfo*)(peer->data))->rawName == getPlyersWorld(peer)->owner) {
				if (((PlayerInfo*)(peer->data))->level < 10)
				{
					GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), " `oSorry, but you must be level `410 `obefore using machine!"));
					ENetPacket* packet = enet_packet_create(p.data,
						p.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packet);
					delete p.data;

				}
				else {
					GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wMagic Machine``|left|6952|0|0|\n\nadd_spacer|small|\nadd_textbox|`oDo you want to convert `2farmable `oblocks to gems? From this machine, you can get different gems. Click start to convert the blocks|\n\nadd_spacer|small|\nadd_button|magicmachine|`oStart|0|0|\nadd_quick_exit|"));
					ENetPacket* packet2 = enet_packet_create(p2.data,
						p2.len,
						ENET_PACKET_FLAG_RELIABLE);

					enet_peer_send(peer, 0, packet2);
					delete p2.data;
				}
			}
			else {

				GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`oSorry, but you must `2owner `oof the worlds!"));
				ENetPacket* packet2 = enet_packet_create(p2.data,
					p2.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet2);
				delete p2.data;

			}


		}
	}


	if (((PlayerInfo*)(peer->data))->adminLevel < 19) {
		if (world->items[x + (y * world->width)].foreground == 6 || world->items[x + (y * world->width)].foreground == 8 || world->items[x + (y * world->width)].foreground == 7372 || world->items[x + (y * world->width)].foreground == 3760 || world->items[x + (y * world->width)].foreground == 1792) {

			GamePacket p2 = packetEnd(appendIntx(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`wIt's too strong to break."), 0), 1));
			ENetPacket* packet2 = enet_packet_create(p2.data,
				p2.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet2);
			delete p2.data;
			return;
		}
		if (tile == 6 || tile == 8 || tile == 3760 || tile == 1000 || tile == 7372 || tile == 2398 || tile == 1792 || tile == 1790 || tile == 2398 || tile == 4358)
		{
			GamePacket p2 = packetEnd(appendIntx(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`wIt's too heavy to place."), 0), 1));
			ENetPacket* packet2 = enet_packet_create(p2.data,
				p2.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet2);
			delete p2.data;
			return;
		}

	}

	if (tile == 3764) {
		if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 0 || ((PlayerInfo*)(peer->data))->rawName == "admin") {
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`4Use atomic fireball on this world? Warning! This will delete all blocks placed in your world!``|left|3764|\nadd_spacer|\nadd_button|nukeyes|`4YES!|\nadd_button|`2Cancel|cancel|\nadd_quick_exit|"));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;

		}
	}
	if (tile == 764) {
		bool isZombie = true;
		return;

	}

	if (tile == 2482) {
		GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`w\n\nadd_label_with_icon|big|`wSuper Megaphone|left|2482|\nadd_spacer|small|\nadd_label_with_icon|small|`oThis will broadcast to all players in the server + button that automatically going to your world!|left|486|\nadd_spacer|small|\nadd_text_input|ssbtext|||50|\nend_dialog|sendssb|Cancel|Broadcast!|\n"));
		ENetPacket* packet2 = enet_packet_create(p2.data,
			p2.len,
			ENET_PACKET_FLAG_RELIABLE);

		enet_peer_send(peer, 0, packet2);
		delete p2.data;
		return;
	}
	if (tile == 1136) {
		GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`w\n\nadd_label_with_icon|big|`wMMars Blast|left|1136|\nadd_spacer|small|\nadd_label_with_icon|small|`oThis will create you an Mars world! (World name)|left|486|\nadd_spacer|small|\nadd_text_input|marstext|||50|\nend_dialog|sendmb|Cancel|Create!|\n"));
		ENetPacket* packet2 = enet_packet_create(p2.data,
			p2.len,
			ENET_PACKET_FLAG_RELIABLE);

		enet_peer_send(peer, 0, packet2);
		delete p2.data;
		return;
	}
	if (tile == 1280) {

		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wChange your GrowID|left|1280|\nadd_label|small|`oThis will change your GrowID `4permanently`o.``|left|4|\nadd_label|small|`oYou will pay `220,000 $ `oif you click on `5Change it`o.``|left|4|\nadd_textbox|`oEnter your new name: |\nadd_text_input|newname|||20|\nend_dialog|cnamedialog|Cancel|Change it!|\n"));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);

		//enet_host_flush(server);
		delete p.data;
		return;
	}
	if (tile == 822) {
		if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1336) {
			if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK)
			{

				return;
			}
			world->items[x + (y * world->width)].water = !world->items[x + (y * world->width)].water;
			UpdateVisualsForBlock(peer, true, x, y, world);
			SendThrowEffect(peer, tile, netID, -1, 100, 0, x * 32 + 16, y * 32 + 16);
			RemoveInventoryItem(822, 1, peer);
			//cout << "[!] xd" << endl;

			return;
		}
	}

	if (tile == 3062)
	{
		if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1336) {
			if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK)
			{

				return;
			}
			world->items[x + (y * world->width)].fire = !world->items[x + (y * world->width)].fire;
			SendThrowEffect(peer, tile, netID, -1, 100, 0, x * 32 + 16, y * 32 + 16);
			UpdateVisualsForBlock(peer, true, x, y, world);
			return;
		}
	}
	if (tile == 18) {
		if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1336) {
			if (world->items[x + (y * world->width)].foreground == 456)
			{
				ENetPeer* currentPeer;
				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						if (((PlayerInfo*)(currentPeer->data))->rawName != world->owner)
						{
							UpdateBlockState(peer, x, y, true, world);
						}
					}
				}

			}
		}
	}

	if (tile == 1866)
	{
		if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1336) {
			if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK)
			{
				cout << "[!] Tried paint wl!";
				return;
			}
			world->items[x + (y * world->width)].glue = !world->items[x + (y * world->width)].glue;
			SendThrowEffect(peer, tile, netID, -1, 100, 0, x * 32 + 16, y * 32 + 16);
			UpdateVisualsForBlock(peer, true, x, y, world);
			return;
		}
	}
	if (tile == 540) {
		int netid = ((PlayerInfo*)(peer->data))->netID;
		RemoveInventoryItem(540, 1, peer);
		GamePacket p3 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`2BURRRPPP...!"), 0));
		ENetPacket* packet3 = enet_packet_create(p3.data,
			p3.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet3);
		delete p3.data;
		return;
	}
	if (pinfo->cloth_hand == 3494) // paint buckets
	{
		if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1336) {
			//if (world->items[x + (y * world->width)].foreground == 242 && world->items[x + (y * world->width)].foreground == 1796 && world->items[x + (y * world->width)].foreground == 2408 && world->items[x + (y * world->width)].foreground == 7188 && world->items[x + (y * world->width)].foreground == 4802) return;

			switch (tile)
			{
			case 3478:
				if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK)
				{

					return;
				}
				world->items[x + (y * world->width)].red = true;
				world->items[x + (y * world->width)].green = false;
				world->items[x + (y * world->width)].blue = false;
				UpdateVisualsForBlock(peer, true, x, y, world);
				return;
			case 3480:
				if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK)
				{

					return;
				}
				world->items[x + (y * world->width)].red = true;
				world->items[x + (y * world->width)].green = true;
				world->items[x + (y * world->width)].blue = false;
				UpdateVisualsForBlock(peer, true, x, y, world);
				return;
			case 3482:
				if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK)
				{
					return;
				}
				world->items[x + (y * world->width)].red = false;
				world->items[x + (y * world->width)].green = true;
				world->items[x + (y * world->width)].blue = false;
				UpdateVisualsForBlock(peer, true, x, y, world);
				return;
			case 3484:
				if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 2946)
				{

					return;
				}
				world->items[x + (y * world->width)].red = false;
				world->items[x + (y * world->width)].green = true;
				world->items[x + (y * world->width)].blue = true;
				UpdateVisualsForBlock(peer, true, x, y, world);
				return;
			case 3486:
				if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 2946)
				{

					return;
				}
				world->items[x + (y * world->width)].red = false;
				world->items[x + (y * world->width)].green = false;
				world->items[x + (y * world->width)].blue = true;
				UpdateVisualsForBlock(peer, true, x, y, world);
				return;
			case 3488:
				if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 2946)
				{

					return;
				}
				world->items[x + (y * world->width)].red = true;
				world->items[x + (y * world->width)].green = false;
				world->items[x + (y * world->width)].blue = true;
				UpdateVisualsForBlock(peer, true, x, y, world);
				return;
			case 3490:
				if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 2946)
				{

					return;
				}
				world->items[x + (y * world->width)].red = true;
				world->items[x + (y * world->width)].green = true;
				world->items[x + (y * world->width)].blue = true;
				UpdateVisualsForBlock(peer, true, x, y, world);
				return;
			case 3492:
				if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::LOCK || world->items[x + (y * world->width)].foreground == 2946)
				{

					return;
				}
				world->items[x + (y * world->width)].red = false;
				world->items[x + (y * world->width)].green = false;
				world->items[x + (y * world->width)].blue = false;
				UpdateVisualsForBlock(peer, true, x, y, world);
				return;
			default: break;
			}
		}
	}

	if (tile == 18)
	{
		if (world->items[x + (y * world->width)].foreground == 758)
		{
			sendRoulete(peer);
		}
	}
	if (world->name == "ADMIN" && !getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass))
	{
		return;
	}
	if (tile == 18) {
		if (world->items[x + (y * world->width)].background == 3734) {
			sendRoulete(peer);
		}
	}


	if (world->items[x + (y * world->width)].foreground == 1420 || world->items[x + (y * world->width)].foreground == 10078 || world->items[x + (y * world->width)].foreground == 10076 || world->items[x + (y * world->width)].foreground == 10074 || world->items[x + (y * world->width)].foreground == 10072 || world->items[x + (y * world->width)].foreground == 6214 && tile != 18) {
		if (world->owner != "") {
			int c = getItemDef(tile).clothType;
			if (c == 0) {
				world->items[x + (y * world->width)].clothHead = tile;
			}
			else if (c == 7) {
				world->items[x + (y * world->width)].clothHair = tile;
			}
			else if (c == 4) {
				world->items[x + (y * world->width)].clothMask = tile;
			}
			else if (c == 8) {
				world->items[x + (y * world->width)].clothNeck = tile;
			}
			else if (c == 6) {
				world->items[x + (y * world->width)].clothBack = tile;
			}
			else if (c == 1) {
				world->items[x + (y * world->width)].clothShirt = tile;
			}
			else if (c == 2) {
				world->items[x + (y * world->width)].clothPants = tile;
			}
			else if (c == 3) {
				world->items[x + (y * world->width)].clothFeet = tile;
			}
			else if (c == 5) {
				world->items[x + (y * world->width)].clothHand = tile;
			}

			if (c != 10) {
				updateMannequin(peer, world->items[x + (y * world->width)].foreground, x, y, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].signn,
					world->items[x + (y * world->width)].clothHair, world->items[x + (y * world->width)].clothHead,
					world->items[x + (y * world->width)].clothMask, world->items[x + (y * world->width)].clothHand, world->items[x + (y * world->width)].clothNeck,
					world->items[x + (y * world->width)].clothShirt, world->items[x + (y * world->width)].clothPants, world->items[x + (y * world->width)].clothFeet,
					world->items[x + (y * world->width)].clothBack, true, 0);
			}
		}
	}
	if (tile == 32)
	{
		if (world->items[x + (y * world->width)].foreground == 3898) {
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wTelephone|left|3898|\nadd_textbox|`oDial a number to call somebody in Growtopia. Phone numbers have 5digits, like 12345 (try it - you'd be crazy not to!). Most numbers are not in service!|\nadd_spacer|small|\nadd_text_input|dialnumber|`oPhone #||5|\nend_dialog|dialbro|Hang Up|Dial|"));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;
		}
	}
	if (tile == 32)
	{
		if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 20 || ((PlayerInfo*)(peer->data))->rawName == "baskerville") {
			string donate1;
			if (world->items[x + (y * world->width)].mdonate1 != "") {
				donate1 = "\nadd_label_with_icon|small|" + world->items[x + (y * world->width)].mdonate1 + "|left|" + to_string(world->items[x + (y * world->width)].donate1) + "|\nadd_spacer|small|\nadd_spacdsaer|small|";
			}
			string donate2;
			if (world->items[x + (y * world->width)].mdonate2 != "") {
				donate2 = "\nadd_label_with_icon|small|" + world->items[x + (y * world->width)].mdonate2 + "|left|" + to_string(world->items[x + (y * world->width)].donate2) + "|\nadd_spacer|small|\nadd_spadsacer|small|";
			}
			string donate3;
			if (world->items[x + (y * world->width)].mdonate3 != "") {
				donate3 = "\nadd_label_with_icon|small|" + world->items[x + (y * world->width)].mdonate3 + "|left|" + to_string(world->items[x + (y * world->width)].donate3) + "|\nadd_spacer|small|\nadd_spasdacer|small|";
			}
			string donate4;
			if (world->items[x + (y * world->width)].mdonate4 != "") {
				donate4 = "\nadd_label_with_icon|small|" + world->items[x + (y * world->width)].mdonate4 + "|left|" + to_string(world->items[x + (y * world->width)].donate4) + "|\nadd_spacer|small|\nadd_spacdaser|small|";
			}
			string donate5;
			if (world->items[x + (y * world->width)].mdonate5 != "") {
				donate5 = "\nadd_label_with_icon|small|" + world->items[x + (y * world->width)].mdonate5 + "|left|" + to_string(world->items[x + (y * world->width)].donate5) + "|\nadd_spacer|small|\nadd_spacedasr|small|";
			}
			string donate6;
			if (world->items[x + (y * world->width)].mdonate6 != "") {
				donate6 = "\nadd_label_with_icon|small|" + world->items[x + (y * world->width)].mdonate6 + "|left|" + to_string(world->items[x + (y * world->width)].donate6) + "|\nadd_spacer|small|\nadd_spacdaser|small|";
			}
			string donate7;
			if (world->items[x + (y * world->width)].mdonate7 != "") {
				donate7 = "\nadd_label_with_icon|small|" + world->items[x + (y * world->width)].mdonate7 + "|left|" + to_string(world->items[x + (y * world->width)].donate7) + "|\nadd_spacer|small|\nadd_spdasacer|small|";
			}
			string donate8;
			if (world->items[x + (y * world->width)].mdonate8 != "") {
				donate8 = "\nadd_label_with_icon|small|" + world->items[x + (y * world->width)].mdonate8 + "|left|" + to_string(world->items[x + (y * world->width)].donate8) + "|\nadd_spacer|small|\nadd_spadascer|small|";
			}
			string donate9;
			if (world->items[x + (y * world->width)].mdonate9 != "") {
				donate9 = "\nadd_label_with_icon|small|" + world->items[x + (y * world->width)].mdonate9 + "|left|" + to_string(world->items[x + (y * world->width)].donate9) + "|\nadd_spacer|small|\nadd_spacdsaer|small|";
			}
			string donate10;
			if (world->items[x + (y * world->width)].mdonate10 != "") {
				donate10 = "\nadd_label_with_icon|small|" + world->items[x + (y * world->width)].mdonate10 + "|left|" + to_string(world->items[x + (y * world->width)].donate10) + "|\nadd_spacer|small|\nadd_spdsaacer|small|";
			}
			string keke;
			if (world->items[x + (y * world->width)].counts1 != 0) {
				keke = "\nadd_spacer|small|";
			}
			string empty;
			if (world->items[x + (y * world->width)].counts1 != 0) {
				empty = "\nadd_textbox|`oThe box contains `w" + to_string(world->items[x + (y * world->width)].counts1) + " `odonations|left|\nadd_spacer|small|";
			}
			else {
				empty = "\nadd_textbox|`oThe box is currently empty.|\nadd_spacer|small|";
			}
			string ret;
			if (world->items[x + (y * world->width)].counts1 != 0) {
				ret = "\nadd_button|retret|`4Retrieve all gifts|left|";
			}
			pinfo->wrenchedBlockLocation = x + (y * world->width);
			if (world->items[x + (y * world->width)].foreground == 1452) {
				GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wDonation Box|left|1452|" + empty + "" + donate1 + "" + donate2 + "" + donate3 + "" + donate4 + "" + donate5 + "" + donate6 + "" + donate7 + "" + donate8 + "" + donate9 + "" + donate10 + "" + keke + "" + ret + "\nadd_item_picker|donateitem|`wGive Gift `o(Min rarity: `52`o)|Choose an item you want to put in the machine!|\nend_dialog|nevermind|Nevermind|"));
				ENetPacket* packet = enet_packet_create(p.data,
					p.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet);
				delete p.data;
			}
		}
		else {
			string empty;
			if (world->items[x + (y * world->width)].counts1 != 0) {
				empty = "\nadd_textbox|`oThe box contains `w" + to_string(world->items[x + (y * world->width)].counts1) + " `odonations|left|\nadd_spacer|small|";
			}
			else {
				empty = "\nadd_textbox|`oThe box is currently empty.|\nadd_spacer|small|";
			}
			if (world->items[x + (y * world->width)].foreground == 1452) {
				GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wDonation Box|left|1452|" + empty + "\nadd_item_picker|donateitem|`wGive Gift `o(Min rarity: `52`o)|Choose an item you want to put in the machine!|\nend_dialog|nevermind|Nevermind|"));
				ENetPacket* packet = enet_packet_create(p.data,
					p.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet);
				delete p.data;
			}
		}
	}
	if (tile == 32)
	{
		if (world->items[x + (y * world->width)].foreground == 2978) {
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wVending Machine|left|2978|\nadd_textbox|`oAn Item is on display here.!|\nadd_spacer|small|\nend_dialog|dialbro|Pick it up|Leave it|"));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;
		}
	}
	else if (world->items[x + (y * world->width)].foreground == 2398)
	{
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wLocke the Salesman|left|2398|\nadd_textbox|`oHo there, friend! Locke's my name, and locks are my game. I love 'em all, Diamond, Huge... even Small!! If you can part with some locks, i'll give you something special in return. Whaddya say?|\nadd_spacer|small|\nadd_button|lockebuymega|`oBuy Megaphone for 10 World Locks|\nadd_button|lockebuytoken|`oBuy Growtoken for 2 World Locks|\nadd_button|lockebuyeyes|`oBuy Burning Eyes for 35 World Locks|\nadd_spacer|small|\nend_dialog|nevermind|Nevermind|"));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}
	else if (world->items[x + (y * world->width)].foreground == 4358)
	{
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wLmited Man|left|4358|\nadd_textbox|`oSelling things that aren't in store yet!.|\nadd_spacer|small|\nadd_button|lockebuymag|`oBuy Magplant for 50k Gems|\nadd_button|lockebuyray|`oBuy Rayman Fist for 50k Gems|\nadd_button|lockebuychand|`oBuy Chandelier for 3k Gems|\nadd_spacer|small|\nend_dialog|nevermind|Nevermind|"));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);
		delete p.data;
	}

	if (world->name == "Dailyreward") {
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 3682)
			{
				if (checkmute(((PlayerInfo*)(peer->data))->rawName) == 2) {
					GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `4Sorry You cant take your daily reward until `5(" + getExpire2(((PlayerInfo*)(peer->data))->rawName) + ")"));
					ENetPacket* packet = enet_packet_create(p3.data,
						p3.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packet);
					delete p3.data;
				}
				else if (((PlayerInfo*)(peer->data))->haveGrowId == false) { // fix growid
					sendConsoleMsg(peer, "Create a growid first!");
				}
				else {
					string ownername = world->owner;

					GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`9Login`|left|3682|\nadd_label|small|`oGreetings, traveler! I am the Log in handler. Click the claim button to claim your reward!``|left|4|\n\nadd_spacer|small|\nadd_button|claim|`9Claim my daily prize!``|0|0|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|noty|Later||gazette||"));
					ENetPacket* packet = enet_packet_create(p.data,
						p.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packet);

					//enet_host_flush(server);
					delete p.data;
				}

			}
		}
	}
	if (tile == 7484) {
		if (checkmute(((PlayerInfo*)(peer->data))->rawName) == 2) {
			GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `4Sorry You cant take your daily reward until `5(" + getExpire2(((PlayerInfo*)(peer->data))->rawName) + ")"));
			ENetPacket* packet = enet_packet_create(p3.data,
				p3.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p3.data;
		}
		else {
			GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`oAre You Sure You Want To Open `1Winter chest`9?``|left|6200|\nadd_spacer|\nadd_button|openwinter|`2Open!|\nadd_quick_exit|"));
			ENetPacket* packet = enet_packet_create(p.data,
				p.len,
				ENET_PACKET_FLAG_RELIABLE);
			enet_peer_send(peer, 0, packet);
			delete p.data;
			return;
		}
	}
	if (world->items[x + (y * world->width)].foreground == 1900) {

		if (tile == 18) {
			if (((PlayerInfo*)(peer->data))->haveGrowId == false) { // fix growid
				sendConsoleMsg(peer, "Create a growid first!");
			}
			else {
				string ownername = world->owner;

				GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`9The Ringmaster!`|left|1900|\nadd_label|small|`oGreetings, traveler! I am the Ringmaster. Should you wish to embark on a Ring, simply choose one below.``|left|4|\n\nadd_spacer|small|\nadd_button|ringforce|`9Ring Of Force``|0|0|\nadd_button|ringwinds|`9Ring Of Winds``|0|0|\nadd_button|ringone|`9The One Ring``|0|0|\nadd_button|ringwisdom|`9Ring of Wisdom ``|0|0|\nadd_button|ringwater|`9Ring Of Water``|0|0|\nadd_button|ringsaving|`9Ring Of Savings``|0|0|\nadd_button|ringsmithing|`9Ring Of Smithing``|0|0|\nadd_button|ringshrinking|`9Ring Of Shrinking``|0|0|\nadd_button|ringnature|`9Ring of Nature``|0|0|\nadd_button|geminiring|`9Gemini Ring``|0|0|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|noty|No Thanks||gazette||"));
				ENetPacket* packet = enet_packet_create(p.data,
					p.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet);

				//enet_host_flush(server);
				delete p.data;

				return;
			}
		}

	}
	string gay = world->items[x + (y * world->width)].text;
	int gay2 = world->items[x + (y * world->width)].foreground;
	if (world != NULL) {
		if (world->name != "ADMIN") {
			if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SIGN || world->items[x + (y * world->width)].foreground == 1420 || world->items[x + (y * world->width)].foreground == 10078 || world->items[x + (y * world->width)].foreground == 10076 || world->items[x + (y * world->width)].foreground == 10074 || world->items[x + (y * world->width)].foreground == 10072 || world->items[x + (y * world->width)].foreground == 6214)
			{
				if (tile == 32) {

					if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1) {

						string signtext = world->items[x + (y * world->width)].sign;

						packet::dialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wEdit " + getItemDef(world->items[x + (y * world->width)].foreground).name + "``|left|" + to_string(world->items[x + (y * world->width)].foreground) + "|\n\nadd_smalltext|What would you like to write in sign?|left|\nadd_text_input|signtext||" + signtext + "|200|\nend_dialog|editsign|Cancel|OK|");
						((PlayerInfo*)(peer->data))->wrenchedBlockLocation = x + (y * world->width);

					}
				}
			}
		}
	}
	if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::DOOR)
	{
		if (world->owner != "") {
			if (((PlayerInfo*)(peer->data))->rawName == world->owner) {
				if (tile == 32) {
					((PlayerInfo*)(peer->data))->wrenchsession = x + (y * world->width);
					WorldItem item = world->items[x + (y * world->width)];
					string a = item.destWorld + ":" + item.destId;
					if (a == ":") a = "";
					if (item.foreground == 762 || item.foreground == 4190)
					{
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wEdit Password Door``|left|" + to_string(item.foreground) + "|\n\nadd_text_input|dest|`oTarget World|" + a + "|100|\nadd_text_input|label|Display Label (optional)|" + item.label + "|100|\nadd_text_input|doorpw|Password|" + item.password + "|35|\nend_dialog|editpdoor|Cancel|OK|"));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
					else {
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wEdit Door``|left|" + to_string(item.foreground) + "|\|\n\nadd_text_input|dest|`oTarget World|" + a + "|100|\nadd_text_input|label|Display Label (optional)|" + item.label + "|100|\nadd_text_input|doorid|ID (optional)|" + item.currId + "|35|\nend_dialog|editdoor|Cancel|OK|"));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
				}
			}
		}
	}
	string name = getItemDef(world->items[x + (y * world->width)].foreground).name;
	int id = getItemDef(world->items[x + (y * world->width)].foreground).id;
	if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::GATEWAY) {
		if (tile == 32) {
			if (((PlayerInfo*)(peer->data))->rawName == world->owner) {

				((PlayerInfo*)(peer->data))->wrenchx = x;
				((PlayerInfo*)(peer->data))->wrenchy = y;
				if (world->items[x + (y * world->width)].isOpened == false) {
					packet::OnDialogRequest(peer, "add_label_with_icon|big|" + name + "|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_checkbox|opentopublic|`ois Open to Public?|0|\nend_dialog|entrance||OK|\n");
				}
				else {
					packet::OnDialogRequest(peer, "add_label_with_icon|big|" + name + "|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_checkbox|opentopublic|`ois Open to Public?|1|\nend_dialog|entrance||OK|\n");
				}
			}
		}
	}
	if (world->name != "ADMIN") {
		if (world->owner != "") {

			string name = ((PlayerInfo*)(peer->data))->rawName;
			if (((PlayerInfo*)(peer->data))->rawName == world->owner || (find(world->acclist.begin(), world->acclist.end(), name) != world->acclist.end() || ((PlayerInfo*)(peer->data))->adminLevel == 1337)) {
				if (((PlayerInfo*)(peer->data))->rawName == "") return;
				// WE ARE GOOD TO GO

				if (world->items[x + (y * world->width)].foreground == 242 && (find(world->acclist.begin(), world->acclist.end(), name) != world->acclist.end()) || world->items[x + (y * world->width)].foreground == 1796 && (find(world->acclist.begin(), world->acclist.end(), name) != world->acclist.end()) || world->items[x + (y * world->width)].foreground == 4428 && (find(world->acclist.begin(), world->acclist.end(), name) != world->acclist.end()) || world->items[x + (y * world->width)].foreground == 2408 && (find(world->acclist.begin(), world->acclist.end(), name) != world->acclist.end()) || world->items[x + (y * world->width)].foreground == 7188 && (find(world->acclist.begin(), world->acclist.end(), name) != world->acclist.end()) || world->items[x + (y * world->width)].foreground == 5980 && (find(world->acclist.begin(), world->acclist.end(), name) != world->acclist.end()) || world->items[x + (y * world->width)].foreground == 2950 && (find(world->acclist.begin(), world->acclist.end(), name) != world->acclist.end()) || world->items[x + (y * world->width)].foreground == 5638 && (find(world->acclist.begin(), world->acclist.end(), name) != world->acclist.end()))
				{
					return;
				}

				if (tile == 32 && (find(world->acclist.begin(), world->acclist.end(), name) != world->acclist.end())) {
					return;
				}
				string offlinelist = "";
				string offname = "";
				int ischecked;
				int ischecked1;
				int ischecked2;
				for (std::vector<string>::const_iterator i = world->acclist.begin(); i != world->acclist.end(); ++i) {
					offname = *i;
					offlinelist += "\nadd_checkbox|isAccessed|" + offname + "|0|\n";

				}


				if (world->isPublic == true) {
					ischecked = 1;
				}
				else {
					ischecked = 0;
				}
				int noclap = 0;
				bool casin = world->isCasino;
				if (casin == true) {
					noclap = 1;
				}
				else {
					noclap = 0;
				}
				if (tile == 32) {
					if (world->items[x + (y * world->width)].foreground == 3832) { // stuff weather dialog
						if (x != 0)
						{
							((PlayerInfo*)(peer->data))->lastPunchX = x;
						}
						if (y != 0)
						{
							((PlayerInfo*)(peer->data))->lastPunchY = y;
						}
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wStuff Weather Machine``|left|3832|\nadd_item_picker|stuffitem|Edit Item|Choose any item you want to pick|\nadd_spacer|small|\nadd_text_input|gravity|Gravity Value||4|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|stuff|Nevermind||"));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
				}
				if (tile == 32) {
					if (world->items[x + (y * world->width)].foreground == 242 || world->items[x + (y * world->width)].foreground == 5814 || world->items[x + (y * world->width)].foreground == 2408 || world->items[x + (y * world->width)].foreground == 1796 || world->items[x + (y * world->width)].foreground == 4428 || world->items[x + (y * world->width)].foreground == 7188) {

						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wEdit " + GetItemDef(world->items[x + (y * world->width)].foreground).name + "``|left|" + to_string(world->items[x + (y * world->width)].foreground) + "|\nadd_textbox|`wAccess list:|left|\nadd_spacer|small|" + offlinelist + "add_spacer|small|\nadd_player_picker|netid|`wAdd|\nadd_spacer|small|\nadd_checkbox|isWorldPublic|Allow anyone to build|" + std::to_string(ischecked) + "|\nadd_checkbox|allowNoclip|Disable noclip|" + std::to_string(noclap) + "|\nend_dialog|wlmenu|Cancel|OK|"));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
				}
			}
			else if (find(world->acclist.begin(), world->acclist.end(), ((PlayerInfo*)(peer->data))->rawName) != world->acclist.end())
			{
				if (world->items[x + (y * world->width)].foreground == 242 || world->items[x + (y * world->width)].foreground == 5814 || world->items[x + (y * world->width)].foreground == 2408 || world->items[x + (y * world->width)].foreground == 1796 || world->items[x + (y * world->width)].foreground == 4428 || world->items[x + (y * world->width)].foreground == 7188)
				{


					string ownername = world->owner;
					GamePacket p2 = packetEnd(appendIntx(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`0" + ownername + "'s `$World Lock`0. (`2Access Granted`w)"), 0), 1));


					ENetPacket* packet2 = enet_packet_create(p2.data,
						p2.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packet2);
					delete p2.data;
					string text = "action|play_sfx\nfile|audio/punch_locked.wav\ndelayMS|0\n";
					BYTE* data = new BYTE[5 + text.length()];
					BYTE zero = 0;
					int type = 3;
					memcpy(data, &type, 4);
					memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
					memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

					ENetPacket* packetsou = enet_packet_create(data,
						5 + text.length(),
						ENET_PACKET_FLAG_RELIABLE);

					enet_peer_send(peer, 0, packetsou);


					return;
				}

			}
			else if (world->isPublic)
			{
				if (world->items[x + (y * world->width)].foreground == 242 || world->items[x + (y * world->width)].foreground == 5814 || world->items[x + (y * world->width)].foreground == 2408 || world->items[x + (y * world->width)].foreground == 1796 || world->items[x + (y * world->width)].foreground == 4428 || world->items[x + (y * world->width)].foreground == 7188)
				{
					string ownername = world->owner;
					GamePacket p2 = packetEnd(appendIntx(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`0" + ownername + "'s `$World Lock`0. (`2Access Granted`w)"), 0), 1));


					ENetPacket* packet2 = enet_packet_create(p2.data,
						p2.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packet2);
					delete p2.data;
					string text = "action|play_sfx\nfile|audio/punch_locked.wav\ndelayMS|0\n";
					BYTE* data = new BYTE[5 + text.length()];
					BYTE zero = 0;
					int type = 3;
					memcpy(data, &type, 4);
					memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
					memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

					ENetPacket* packetsou = enet_packet_create(data,
						5 + text.length(),
						ENET_PACKET_FLAG_RELIABLE);

					enet_peer_send(peer, 0, packetsou);


					return;
				}

			}
			else {
				ItemDefinition pro;
				pro = getItemDef(world->items[x + (y * world->width)].foreground);
				if (world->items[x + (y * world->width)].foreground == 242 || world->items[x + (y * world->width)].foreground == 5814 || world->items[x + (y * world->width)].foreground == 2408 || world->items[x + (y * world->width)].foreground == 1796 || world->items[x + (y * world->width)].foreground == 4428 || world->items[x + (y * world->width)].foreground == 7188) {
					string ownername = world->owner;
					GamePacket p2 = packetEnd(appendIntx(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`0" + ownername + "'s `$World Lock`0. (`4No access`w)"), 0), 1));


					ENetPacket* packet2 = enet_packet_create(p2.data,
						p2.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packet2);
					delete p2.data;
					string text = "action|play_sfx\nfile|audio/punch_locked.wav\ndelayMS|0\n";
					BYTE* data = new BYTE[5 + text.length()];
					BYTE zero = 0;
					int type = 3;
					memcpy(data, &type, 4);
					memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
					memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

					ENetPacket* packetsou = enet_packet_create(data,
						5 + text.length(),
						ENET_PACKET_FLAG_RELIABLE);

					enet_peer_send(peer, 0, packetsou);


					return;
				}
				else
				{
					string text = "action|play_sfx\nfile|audio/punch_locked.wav\ndelayMS|0\n";
					BYTE* data = new BYTE[5 + text.length()];
					BYTE zero = 0;
					int type = 3;
					memcpy(data, &type, 4);
					memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
					memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

					ENetPacket* packetsou = enet_packet_create(data,
						5 + text.length(),
						ENET_PACKET_FLAG_RELIABLE);

					enet_peer_send(peer, 0, packetsou);


					return;
				}

			} /*lockeds*/
			if (tile == 242 || tile == 2408 || tile == 1796 || tile == 4428 || tile == 7188) {



				GamePacket p3 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`0Only one `$World Lock`0 can be placed in a world!"), 0));


				ENetPacket* packet3 = enet_packet_create(p3.data,
					p3.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet3);
				delete p3.data;
				return;
			}
		}
	}
	if (tile == 18)
	{
		if (world->items[x + (y * world->width)].foreground == 1490)
		{
			world->weather = 10;
			ENetPeer* currentPeer;

			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
					continue;
				if (isHere(peer, currentPeer))
				{
					GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
					ENetPacket* packet2 = enet_packet_create(p2.data,
						p2.len,
						ENET_PACKET_FLAG_RELIABLE);

					enet_peer_send(currentPeer, 0, packet2);
					delete p2.data;
					continue;
				}
			}
		}
	}
	// WE ARE GOOD TO GO
	if (tile == 18)
	{
		if (world->items[x + (y * world->width)].foreground == 934)
		{
			world->weather = 2;
			ENetPeer* currentPeer;

			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
					continue;
				if (isHere(peer, currentPeer))
				{
					GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
					ENetPacket* packet2 = enet_packet_create(p2.data,
						p2.len,
						ENET_PACKET_FLAG_RELIABLE);

					enet_peer_send(currentPeer, 0, packet2);
					delete p2.data;
					continue;
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 946)
			{
				world->weather = 3;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 1490)
			{
				world->weather = 10;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 932)
			{
				world->weather = 4;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 984)
			{
				world->weather = 5;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 1210)
			{
				world->weather = 8;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 1364)
			{
				world->weather = 11;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 1750)
			{
				world->weather = 15;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 2046)
			{
				world->weather = 17;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 2284)
			{
				world->weather = 18;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 2744)
			{
				world->weather = 19;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 3252)
			{
				world->weather = 20;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 3446)
			{
				world->weather = 21;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 3534)
			{
				world->weather = 22;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 3694)
			{
				world->weather = 25;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 1490)
			{
				world->weather = 10;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 4242)
			{
				world->weather = 30;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 4486)
			{
				world->weather = 31;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 4776)
			{
				world->weather = 32;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 4892)
			{
				world->weather = 33;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 5000)
			{
				world->weather = 34;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 5112)
			{
				world->weather = 35;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 5654)
			{
				world->weather = 36;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 5716)
			{
				world->weather = 37;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 5958)
			{
				world->weather = 38;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 6854)
			{
				world->weather = 42;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	{
		// WE ARE GOOD TO GO
		if (tile == 18)
		{
			if (world->items[x + (y * world->width)].foreground == 7644)
			{
				world->weather = 44;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packet2);
						delete p2.data;
						continue;
					}
				}
			}
		}
	}
	if (tile == 1404) {
		//world->items[x + (y*world->width)].water = !world->items[x + (y*world->width)].water;
		//if (isSuperAdmin(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass)) {

		if (((PlayerInfo*)(peer->data))->rawName == world->owner || isSuperAdmin(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass)) {
			if (world->items[x + (y * world->width)].foreground != 0) {
				GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 Here is no space for the main door!"));


				ENetPacket* packet2 = enet_packet_create(p2.data,
					p2.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet2);
				delete p2.data;

			}
			else if (world->items[x + (y * world->width) + 100].foreground != 0) {
				GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 Here is no space for the main door!"));


				ENetPacket* packet2 = enet_packet_create(p2.data,
					p2.len,
					ENET_PACKET_FLAG_RELIABLE);
				enet_peer_send(peer, 0, packet2);
				delete p2.data;

			}
			else

			{
				//	showDoormover(peer);
				RemoveInventoryItem(1404, 100, peer);
				for (int i = 0; i < world->width * world->height; i++)
				{
					if (i >= 5400) {
						world->items[i].foreground = 8;
					}
					else if (world->items[i].foreground == 6) {

						world->items[i].foreground = 0;
						world->items[i + 100].foreground = 0;

					}

					else if (world->items[i].foreground != 6) {
						world->items[x + (y * world->width)].foreground = 6;
						world->items[x + (y * world->width) + 100].foreground = 8;
					}


				}

				WorldInfo* wrld = getPlyersWorld(peer);
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer))
					{
						string act = ((PlayerInfo*)(peer->data))->currentWorld;
						//WorldInfo info = worldDB.get(act);
						// sendWorld(currentPeer, &info);


						sendPlayerLeave(currentPeer, (PlayerInfo*)(currentPeer->data));
						joinWorld(currentPeer, act, 0, 0);
						GamePacket p8 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You used door mover!"));
						ENetPacket* packet8 = enet_packet_create(p8.data,
							p8.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet8);

					}

				}
			}
			return;
		}
	}

	if (tile != 18)
	{
		if (world->items[x + (y * world->width)].foreground != 0) {
			return;
		}
	}
	if (tile == 32) {
		// TODO
		return;
	}
	if (tile == 1866)
	{
		world->items[x + (y * world->width)].glue = !world->items[x + (y * world->width)].glue;
		return;
	}
	ItemDefinition def;
	ItemDefinition proy;
	if (world->items[x + (y * world->width)].foreground == 0) {
		proy = getItemDef(world->items[x + (y * world->width)].background);
	}
	else {
		proy = getItemDef(world->items[x + (y * world->width)].foreground);
	}
	try {
		def = getItemDef(tile);
		if (def.clothType != ClothTypes::NONE) return;
	}
	catch (int e) {
		def.breakHits = 4;
		def.blockType = BlockTypes::UNKNOWN;
#ifdef TOTAL_LOG
		cout << "[!] Ugh, unsupported item " << tile << endl;
#endif
	}
	bool iscontains = false;
	SearchInventoryItem(peer, tile, 1, iscontains);
	if (!iscontains)
	{
		return;
	}
	iscontains = false;

	if (tile == 544 || tile == 546 || tile == 4520 || tile == 382 || tile == 3116 || tile == 4520 || tile == 0 || tile == 5666 || tile == 2994 || tile == 4368) return;
	if (tile == 5708 || tile == 5709 || tile == 5780 || tile == 5781 || tile == 5782 || tile == 5783 || tile == 5784 || tile == 5785 || tile == 5710 || tile == 5711 || tile == 5786 || tile == 5787 || tile == 5788 || tile == 5789 || tile == 5790 || tile == 5791 || tile == 6146 || tile == 6147 || tile == 6148 || tile == 6149 || tile == 6150 || tile == 6151 || tile == 6152 || tile == 6153 || tile == 5670 || tile == 5671 || tile == 5798 || tile == 5799 || tile == 5800 || tile == 5801 || tile == 5802 || tile == 5803 || tile == 5668 || tile == 5669 || tile == 5792 || tile == 5793 || tile == 5794 || tile == 5795 || tile == 5796 || tile == 5797 || tile == 544 || tile == 546 || tile == 4520 || tile == 382 || tile == 3116 || tile == 0 || tile == 5666 || tile == 2994 || tile == 4368) return;
	if (tile == 1902 || tile == 1508 || tile == 428 || tile == 9496 || tile == 9499) return;
	if (tile == 18) {
		ItemDefinition brak;
		brak = getItemDef(world->items[x + (y * world->width)].foreground);
		if (world->items[x + (y * world->width)].background == 6864 && world->items[x + (y * world->width)].foreground == 0) return;
		if (world->items[x + (y * world->width)].background == 0 && world->items[x + (y * world->width)].foreground == 0) return;
		//data.netID = -1;
		data.packetType = 0x8;
		data.plantingTree = 4;
		using namespace std::chrono;
		//if (world->items[x + (y*world->width)].foreground == 0) return;
		
		if ((duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count() - world->items[x + (y * world->width)].breakTime >= 5000)
		{
			world->items[x + (y * world->width)].breakTime = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			world->items[x + (y * world->width)].breakLevel = 5; // TODO
		}
		else
			if (y < world->height && world->items[x + (y * world->width)].breakLevel + 4 >= brak.breakHits * 4) { // TODO
				data.packetType = 0x3;// 0xC; // 0xF // World::HandlePacketTileChangeRequest
				data.netID = causedBy;
				data.plantingTree = 18;
				int brokentile = world->items[x + (y * world->width)].foreground;
				int hi = data.punchX * 32;
				int hi2 = data.punchY * 32;
				if (world->magplant == true) {
					GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 186), hi, hi2));
					ENetPacket* packetd = enet_packet_create(psp.data,
						psp.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packetd);
				}
				if (((PlayerInfo*)(peer->data))->currentWorld != "EXIT") {
					if (brokentile == 242 || brokentile == 2408 || brokentile == 1796 || brokentile == 4428 || brokentile == 7188) {
						if (adminlevel(((PlayerInfo*)(peer->data))->rawName) > 111) {
							Player::OnNameChanged(peer, ((PlayerInfo*)(peer->data))->netID, "`0`0" + ((PlayerInfo*)(peer->data))->displayName);
						}
						bool success = true;
						SaveShopsItemMoreTimes(brokentile, 1, peer, success);
						ENetPeer* currentPeer;

						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
								continue;
							if (isHere(peer, currentPeer)) {
								Player::OnConsoleMessage(currentPeer, "`5[`w" + world->name + " `ohas had its `$World Lock `oremoved!`5]");
							}

							world->owner = "";
							world->isPublic = false;
							world->ownerID = 0;
							world->stuffID = 0;
							world->gravity = 0;
							world->acclist.clear();
						}
					}
				}


				//Player::SendTileAnimation(peer, x, y, causedBy, world->items[x + (y*world->width)].foreground);

				world->items[x + (y * world->width)].breakLevel = 0;
				if (brokentile != 0)
				{
					if (brokentile == 410 || brokentile == 1832 || brokentile == 1770) {
						int x1 = 0;
						int y1 = 0;
						for (int i = 0; i < world->width * world->height; i++)
						{
							if (world->items[i].foreground == 6) {
								x1 = (i % world->width) * 32;
								y1 = (i / world->width) * 32;
								//world->items[i].foreground = 8;
							}
						}
						ENetPeer* currentPeer;

						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
								continue;
							if (isHere(peer, currentPeer)) {
								bool success = true;
								Player::SaveShopsItemMoreTimes(1792, 1, peer, success);
							}
						}
					}



					
					world->items[x + (y * world->width)].foreground = 0;

					if (brokentile == 2)
					{
						std::vector<int> list{ 1, 1, 1, 5, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1, 1, 1 };
						int index = rand() % list.size(); // pick a random index
						int values = list[index];

						if (values == 1)
						{
							std::vector<int> list{ 1, 5, 10 };
							int index = rand() % list.size(); // pick a random index
							int value = list[index];
							bool success = true;
							for (int i = 0; i < rand() % 1; i++) DropItem(peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, value, 0);
							for (int i = 0; i < rand() % 3; i++) DropItem(peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, value, 0);
						}
						if (values == 1)
						{
							std::vector<int> list{ 1, 5, 10 };
							int index = rand() % list.size(); // pick a random index
							int value = list[index];
							bool success = true;
							for (int i = 0; i < rand() % 1; i++) DropItem(peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, value, 0);
							for (int i = 0; i < rand() % 3; i++) DropItem(peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, value, 0);
						}
						if (values == 1)
						{
							std::vector<int> list{ 1, 5 };
							int index = rand() % list.size(); // pick a random index
							int value = list[index];
							bool success = true;
							for (int i = 0; i < rand() % 1; i++) DropItem(peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, value, 0);
							for (int i = 0; i < rand() % 3; i++) DropItem(peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, value, 0);
						}
					}
					if (brokentile == 2946) {
						if (world->items[x + (y * world->width)].display != 0) {
							bool success = true;
							SaveShopsItemMoreTimes(world->items[x + (y * world->width)].display, 1, peer, success);
							Player::OnTalkBubble(peer, netID, "`wPicked up `5" + getItemDef(world->items[x + (y * world->width)].display).name + "`w from display block!", 0, true);
							world->items[x + (y * world->width)].display = 0;
						}
						else {
						}
					}

					if (brokentile == 10358) {
						DropItem(
							peer, -1,
							x * 32 + (rand() % 16),
							y * 32 + (rand() % 16),
							112,
							100, 0);
						std::vector<int> list{ 1, 5, 10 };
						int index = rand() % list.size(); // pick a random index
						int value = list[index];
						DropItem(
							peer, -1,
							x * 32 + (rand() % 16),
							y * 32 + (rand() % 16),
							112,
							value, 0);
					}
					if (brokentile == 10384) {
						DropItem(
							peer, -1,
							x * 32 + (rand() % 16),
							y * 32 + (rand() % 16),
							112,
							100, 0);
						DropItem(
							peer, -1,
							x * 32 + (rand() % 16),
							y * 32 + (rand() % 16),
							112,
							100, 0);
						std::vector<int> list{ 1, 5, 10 };
						int index = rand() % list.size(); // pick a random index
						int value = list[index];
						DropItem(
							peer, -1,
							x * 32 + (rand() % 16),
							y * 32 + (rand() % 16),
							112,
							value, 0);
						DropItem(
							peer, -1,
							x * 32 + (rand() % 16),
							y * 32 + (rand() % 16),
							112,
							value, 0);
					}
					if (brokentile >= 1) {
						if (getItemDef(fg).rarity != 999 && getItemDef(bg).rarity != 999 && getItemDef(block).blockType != BlockTypes::SEED && getItemDef(block).blockType != BlockTypes::LOCK && getItemDef(block).blockType != BlockTypes::WEATHER && block != 1008 && block != 1240 && block != 8878) {
							int b = getGemCount(fg) + rand() % 1;
							while (b > 0)
							{
								if (b >= 100)
								{
									DropItem(
										peer, -1,
										x * 32 + (rand() % 16),
										y * 32 + (rand() % 16),
										112,
										100, 0);
									b -= 100;
									for (int i = 0; i < rand() % 1; i++) DropItem(peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, 10, 0);
									for (int i = 0; i < rand() % 4; i++) DropItem(peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, 1, 0);
									continue;
								}
								if (b >= 50)
								{
									DropItem(
										peer, -1,
										x * 32 + (rand() % 16),
										y * 32 + (rand() % 16),
										112,
										50, 0);
									b -= 50;
									for (int i = 0; i < rand() % 1; i++) DropItem(peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, 5, 0);
									for (int i = 0; i < rand() % 3; i++) DropItem(peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, 1, 0);
									continue;
								}
								if (b >= 10)
								{
									DropItem(
										peer, -1,
										x * 32 + (rand() % 16),
										y * 32 + (rand() % 16),
										112,
										10, 0);
									b -= 10;
									for (int i = 0; i < rand() % 4; i++) DropItem(peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, 1, 0);
									continue;
								}
								if (b >= 5)
								{
									DropItem(
										peer, -1,
										x * 32 + (rand() % 16),
										y * 32 + (rand() % 16),
										112,
										5, 0);
									b -= 5;
									for (int i = 0; i < rand() % 2; i++) DropItem(peer, -1, x * 32 + (rand() % 16), y * 32 + (rand() % 16), 112, 1, 0);
									continue;
								}
								if (b >= 1)
								{
									DropItem(
										peer, -1,
										x * 32 + (rand() % 16),
										y * 32 + (rand() % 16),
										112,
										1, 0);
									b -= 1;
									for (int i = 0; i < rand() % 1; i++) DropItem(peer, -1, x * 32 + (rand() % 8), y * 32 + (rand() % 16), 112, 1, 0);
									continue;
								}
							}
						}
					}
					//degplay

					
					((PlayerInfo*)(peer->data))->xp = ((PlayerInfo*)(peer->data))->xp + 1; // level system

					if (((PlayerInfo*)(peer->data))->xp >= 600 * ((PlayerInfo*)(peer->data))->level) {
						((PlayerInfo*)(peer->data))->xp = 0;
						((PlayerInfo*)(peer->data))->level = ((PlayerInfo*)(peer->data))->level + 1;
						if (((PlayerInfo*)(peer->data))->level == 125)
						{
							return;
						}
						ENetPeer* currentPeer;
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
								continue;
							if (isHere(peer, currentPeer)) {
								string name = ((PlayerInfo*)(peer->data))->displayName;
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `wis now level " + std::to_string(((PlayerInfo*)(peer->data))->level) + "!"));
								string text = "action|play_sfx\nfile|audio/levelup2.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(currentPeer, 0, packet);

								ENetPacket* packet2 = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(currentPeer, 0, packet2);
								ENetPeer* currentPeer;
								int effect = 0;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer)) {

										int x = ((PlayerInfo*)(peer->data))->x;
										int y = ((PlayerInfo*)(peer->data))->y;
										GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), effect), x, y));

										ENetPacket* packetd = enet_packet_create(psp.data,
											psp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packetd);
										delete psp.data;
									}
								}
								delete data;
								delete p.data;

								GamePacket p3 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), name + " `wis now level " + std::to_string(((PlayerInfo*)(peer->data))->level) + "!"));
								ENetPacket* packet3 = enet_packet_create(p3.data,
									p3.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(currentPeer, 0, packet3);
							}
							//GamePacket p3 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), ((PlayerInfo*)(peer->data))->displayName + " was thrown a bucket of " + (((PlayerInfo*)(peer->data))->addgems)), 0));


							data.plantingTree = tile;
						}
					}
				}
				else {
					data.plantingTree = tile;
					world->items[x + (y * world->width)].background = 6864;
				}

			}
			else
				if (y < world->height)
				{
					world->items[x + (y * world->width)].breakTime = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
					world->items[x + (y * world->width)].breakLevel += 4; // TODO
				}
	}
	else {
		for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
		{
			if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == tile)
			{
				if ((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount > 1)
				{
					((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount--;
					SaveInventoryWhenBuildingBlock(peer);
				}
				else {
					((PlayerInfo*)(peer->data))->inventory.items.erase(((PlayerInfo*)(peer->data))->inventory.items.begin() + i);
					SaveInventoryWhenBuildingBlock(peer);
				}
			}
		}
		ItemDefinition yologay;
		if (def.blockType == BlockTypes::BACKGROUND)
		{
			world->items[x + (y * world->width)].background = tile;
		}
		else {
			if (getItemDef(tile).blockType == BlockTypes::LOCK) {
				if (((PlayerInfo*)(peer->data))->rawName == world->owner) {
					return;
				}
				world->owner = ((PlayerInfo*)(peer->data))->rawName;
				world->ownerID = ((PlayerInfo*)(peer->data))->userID;
				isLock = true;
				world->isPublic = false;
				ENetPeer* currentPeer;

				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (isHere(peer, currentPeer)) {
						((PlayerInfo*)(peer->data))->worldsowned.push_back(world->name);
						std::ifstream ifff("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");


						if (ifff.fail()) {
							ifff.close();


						}
						if (ifff.is_open()) {
						}
						json j;
						ifff >> j; //load


						j["worldsowned"] = ((PlayerInfo*)(peer->data))->worldsowned; //edit




						std::ofstream o("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json"); //save
						if (!o.is_open()) {
							cout << GetLastError() << endl;
							_getch();
						}

						o << j << std::endl;
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `3[`w" + world->name + " `ohas been World Locked by `2" + ((PlayerInfo*)(peer->data))->displayName + "`3]"));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(currentPeer, 0, packet);
						delete p.data;
						string text = "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0\n";
						BYTE* data = new BYTE[5 + text.length()];
						BYTE zero = 0;
						int type = 3;
						memcpy(data, &type, 4);
						memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
						memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

						ENetPacket* packetsou = enet_packet_create(data,
							5 + text.length(),
							ENET_PACKET_FLAG_RELIABLE);

						enet_peer_send(currentPeer, 0, packetsou);
					}
				}
			}
			world->items[x + (y * world->width)].foreground = tile;
		}

		world->items[x + (y * world->width)].breakLevel = 0;
	}


	if (getItemDef(tile).properties == Property_MultiFacing) {
		if (((PlayerInfo*)(peer->data))->isRotatedLeft) {

			world->items[x + (y * world->width)].flipped = true;
			UpdateBlockState(peer, x, y, true, world);

		}
	}

	ENetPeer* currentPeer;

	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer))
			SendPacketRaw(4, packPlayerMoving(&data), 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		//cout << "[!] Tile update at: " << data2->punchX << "x" << data2->punchY << endl;
	}
	if (getItemDef(tile).properties == Property_MultiFacing) {
		if (((PlayerInfo*)(peer->data))->isRotatedLeft) {

			world->items[x + (y * world->width)].flipped = true;
			UpdateBlockState(peer, x, y, true, world);

		}
	}
	if (tile == 18) {
		if (world->owner == "" || ((PlayerInfo*)(peer->data))->rawName == world->owner || pinfo->adminLevel > 1) {
			if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::TOGGLE_FOREGROUND || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::CHEST || getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::SWITCH_BLOCK) {
				if (world->items[x + (y * world->width)].activated) {
					sendNothingHappened(peer, x, y);
					world->items[x + (y * world->width)].activated = false;
					UpdateBlockState(peer, x, y, true, world);
				}
				else {
					sendNothingHappened(peer, x, y);
					world->items[x + (y * world->width)].activated = true;
					UpdateBlockState(peer, x, y, true, world);

				}
			}
		}
	}
	if (isLock) {
		ENetPeer* currentPeer;

		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer)) {
				sendTileData(currentPeer, x, y, 0x10, tile, world->items[x + (y * world->width)].background, lockTileDatas(0x20, ((PlayerInfo*)(peer->data))->userID, 0, 0, false, 100));
			}
		}
	}
	if (isTree) {
		int val = rand() % 8;
		visual::updatetree(peer, world->items[x + (y * world->width)].foreground, x, y, world->items[x + (y * world->width)].background, val, 0, 0x00000000);
	}
}
void sendChatMessage(ENetPeer* peer, int netID, string message)
{
	try {
		if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") return;
		if (message.length() == 0) return;
		for (char c : message)

			if (c < 0x18 || std::all_of(message.begin(), message.end(), isspace)) {
				return;
			}

		vector<string> blackWords = { "asshole","ass","nigger","nigga", "niga","niger","nig3r","nigg4","n1gg4","n1gga","sex","bitch","fuck","fucker","fk","gay","idiot","dumb","bitch" };
		if (std::find(blackWords.begin(), blackWords.end(), message) != blackWords.end())
		{
			packet::dialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`oMessage was unsent`|left|32|\nadd_spacer|small|\nadd_label|small|`4WARNING : `oSending inappropriate words or messages on GrowDev is not allowed, this count as your first and last warning, if you did it again you'll get muted|left|\nadd_spacer|small|\nend_dialog||`pSorry|");
			return;
		}

		ENetPeer* currentPeer;
		string name = "";
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (((PlayerInfo*)(currentPeer->data))->netID == netID)
				name = ((PlayerInfo*)(currentPeer->data))->displayName;

		}
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("CP:0_PL:4_OID:_CT:[W]_ `o<`w" + name + "`o> " + message);
		gamepacket_t p2;
		if (((PlayerInfo*)(peer->data))->adminLevel == 20) {
			p2.Insert("OnTalkBubble");
			p2.Insert(netID);
			p2.Insert("`6" + message);
			p2.Insert(0);
		}
		else if (((PlayerInfo*)(peer->data))->adminLevel == 19) {
			p2.Insert("OnTalkBubble");
			p2.Insert(netID);
			p2.Insert("`#" + message);
			p2.Insert(0);
		}
		else {
			p2.Insert("OnTalkBubble");
			p2.Insert(netID);
			p2.Insert(message);
			p2.Insert(0);
		}
		for (currentPeer = server->peers;
			currentPeer < &server->peers[server->peerCount];
			++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
				continue;
			if (isHere(peer, currentPeer))
			{
				p.CreatePacket(currentPeer);
				p2.CreatePacket(currentPeer);
			}
		}
	}
	catch (...) {
		cout << "error in void sendchatmessage";
		enet_peer_disconnect(peer, 0);
		return;
	}
}
void showWrong(ENetPeer* peer, string listFull, string itemFind) {
	GamePacket fff = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wFind item: " + itemFind + "``|left|3802|\nadd_spacer|small|\n" + listFull + "add_textbox|Enter a word below to find the item|\nadd_text_input|item|Item Name||30|\nend_dialog|findid|Cancel|Find the item!|\n"));
	ENetPacket* packetd = enet_packet_create(fff.data,
		fff.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packetd);

	//enet_host_flush(server);
	delete fff.data;
}

void sendWho(ENetPeer* peer)
{
	ENetPeer* currentPeer;
	string name = "";
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer) && ((PlayerInfo*)(currentPeer->data))->isinv == false)
		{

			GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(currentPeer->data))->netID), ((PlayerInfo*)(currentPeer->data))->displayName), 1));
			ENetPacket* packet2 = enet_packet_create(p2.data,
				p2.len,
				ENET_PACKET_FLAG_RELIABLE);


			enet_peer_send(peer, 0, packet2);
			delete p2.data;
			//enet_host_flush(server);
		}
	}
}
void sendPuncheffect(ENetPeer* peer) {
	//return; // TODO
	PlayerInfo* info = ((PlayerInfo*)(peer->data));
	int netID = info->netID;
	ENetPeer* currentPeer;
	int state = getState(info);
	int pro = getState(info);
	int statey = 0;
	if (info->cloth_hand == 6028) statey = 1024;
	if (info->cloth_hand == 6262) statey = 8192;
	if (info->haveGrowId == false) statey = 50000;
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {


			PlayerMoving data;
			data.packetType = 0x14;
			data.characterState = statey;
			data.x = 1000;
			data.y = 100;
			data.punchX = 0;
			data.punchY = 0;
			data.XSpeed = 300;
			data.YSpeed = 600;
			data.netID = netID;
			data.plantingTree = state;
			BYTE* raw = packPlayerMoving(&data);
			int var = info->peffect; // punch effect
			memcpy(raw + 1, &var, 3);
			SendPacketRaw(4, raw, 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);


		}

	}
	// TODO 
}
void sendGazette(ENetPeer* peer) {
	std::ifstream news("news.txt");
	std::stringstream buffer;
	buffer << news.rdbuf();
	std::string newsString(buffer.str());
	GamePacket p8 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), newsString));

	ENetPacket* packet8 = enet_packet_create(p8.data,
		p8.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet8);

	//enet_host_flush(server);
	delete p8.data;

}
void sendAction(ENetPeer* peer, int netID, string action)
{
	ENetPeer* currentPeer;
	string name = "";
	GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnAction"), action));
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {

			memcpy(p2.data + 8, &netID, 4);
			ENetPacket* packet2 = enet_packet_create(p2.data,
				p2.len,
				ENET_PACKET_FLAG_RELIABLE);

			enet_peer_send(currentPeer, 0, packet2);

			//enet_host_flush(server);
		}
	}
	delete p2.data;
}


// droping items WorldObjectMap::HandlePacke

void sendModSpawn(ENetPeer* peer, int netID, int x, int y, int item, int count, BYTE specialEffect)
{
	if (item >= 7068) return;
	if (item < 0) return;
	ENetPeer* currentPeer;
	string name = "";
	for (currentPeer = server->peers;
		currentPeer < &server->peers[server->peerCount];
		++currentPeer)
	{
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
			continue;
		if (isHere(peer, currentPeer)) {
			PlayerMoving data;
			data.packetType = 14;
			data.x = x;
			data.y = y;
			data.netID = netID;
			data.plantingTree = item;
			float val = count; // item count
			BYTE val2 = specialEffect;

			BYTE* raw = packPlayerMoving(&data);
			memcpy(raw + 16, &val, 4);
			memcpy(raw + 1, &val2, 1);

			SendPacketRaw(4, raw, 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
		}
	}
}

void getAutoEffect(ENetPeer* peer) {
	PlayerInfo* info = ((PlayerInfo*)(peer->data));
	if (info->cloth_hand == 5480) {
		info->peffect = 8421456;
		craftItemText();
	}
	else if (info->cloth_face == 1204) {
		info->peffect = 8421386;
		craftItemText();
	}
	else if (info->cloth_face == 138) {
		info->peffect = 8421377;
		craftItemText();
	}
	else if (info->cloth_face == 2476) {
		info->peffect = 8421415;
		craftItemText();
	}
	else if (info->cloth_hand == 366 || info->cloth_hand == 1464) {
		info->peffect = 8421378;
		craftItemText();
	}
	else if (info->cloth_hand == 472) {
		info->peffect = 8421379;
		craftItemText();
	}
	else if (info->cloth_hand == 7912) {
		info->peffect = 8421487;
		craftItemText();
	}
	else if (info->cloth_hand == 594) {
		info->peffect = 8421380;
		craftItemText();
	}
	else if (info->cloth_hand == 768) {
		info->peffect = 8421381;
		craftItemText();
	}
	else if (info->cloth_hand == 900) {
		info->peffect = 8421382;
		craftItemText();
	}
	else if (info->cloth_hand == 910) {
		info->peffect = 8421383;
		craftItemText();
	}
	else if (info->cloth_hand == 930) {
		info->peffect = 8421384;
		craftItemText();
	}
	else if (info->cloth_hand == 1016) {
		info->peffect = 8421385;
		craftItemText();
	}
	else if (info->cloth_hand == 1378) {
		info->peffect = 8421387;
		craftItemText();
	}
	else if (info->cloth_hand == 1484) {
		info->peffect = 8421389;
		craftItemText();
	}
	else if (info->cloth_hand == 1512) {
		info->peffect = 8421390;
		craftItemText();
	}
	else if (info->cloth_hand == 1542) {
		info->peffect = 8421391;
		craftItemText();
	}
	else if (info->cloth_hand == 1576) {
		info->peffect = 8421392;
		craftItemText();
	}
	else if (info->cloth_hand == 1676) {
		info->peffect = 8421393;
		craftItemText();
	}
	else if (info->cloth_hand == 1710) {
		info->peffect = 8421394;
		craftItemText();
	}
	else if (info->cloth_hand == 1748) {
		info->peffect = 8421395;
		craftItemText();
	}
	else if (info->cloth_hand == 1780) {
		info->peffect = 8421396;
		craftItemText();
	}
	else if (info->cloth_hand == 1782) {
		info->peffect = 8421397;
		craftItemText();
	}
	else if (info->cloth_hand == 1804) {
		info->peffect = 8421398;
		craftItemText();
	}
	else if (info->cloth_hand == 1868) {
		info->peffect = 8421399;
		craftItemText();
	}
	else if (info->cloth_hand == 1874) {
		info->peffect = 8421400;
		craftItemText();
	}
	else if (info->cloth_hand == 1946) {
		info->peffect = 8421401;
		craftItemText();
	}
	else if (info->cloth_hand == 1948) {
		info->peffect = 8421402;
		craftItemText();
	}
	else if (info->cloth_hand == 1956) {
		info->peffect = 8421403;
		craftItemText();
	}
	else if (info->cloth_hand == 2908) {
		info->peffect = 8421405;
		craftItemText();
	}
	else if (info->cloth_hand == 2952) {
		info->peffect = 8421405;
		craftItemText();
	}
	else if (info->cloth_hand == 6312) {
		info->peffect = 8421405;
		craftItemText();
	}
	else if (info->cloth_hand == 1980) {
		info->peffect = 8421406;
		craftItemText();
	}
	else if (info->cloth_hand == 2066) {
		info->peffect = 8421407;
		craftItemText();
	}
	else if (info->cloth_hand == 2212) {
		info->peffect = 8421408;
		craftItemText();
	}
	else if (info->cloth_hand == 2218) {
		info->peffect = 8421409;
		craftItemText();
	}
	else if (info->cloth_feet == 2220) {
		info->peffect = 8421410;
		craftItemText();
	}
	else if (info->cloth_hand == 2266) {
		info->peffect = 8421411;
		craftItemText();
	}
	else if (info->cloth_hand == 2386) {
		info->peffect = 8421412;
		craftItemText();
	}
	else if (info->cloth_hand == 2388) {
		info->peffect = 8421413;
		craftItemText();
	}
	else if (info->cloth_hand == 2450) {
		info->peffect = 8421414;
		craftItemText();
	}
	else if (info->cloth_hand == 2512) {
		info->peffect = 8421417;
		craftItemText();
	}
	else if (info->cloth_hand == 2572) {
		info->peffect = 8421418;
		craftItemText();
	}
	else if (info->cloth_hand == 2592) {
		info->peffect = 8421419;
		craftItemText();
	}
	else if (info->cloth_hand == 2720) {
		info->peffect = 8421420;
		craftItemText();
	}
	else if (info->cloth_hand == 2752) {
		info->peffect = 8421421;
		craftItemText();
	}
	else if (info->cloth_hand == 2754) {
		info->peffect = 8421422;
		craftItemText();
	}
	else if (info->cloth_hand == 2756) {
		info->peffect = 8421423;
		craftItemText();
	}
	else if (info->cloth_hand == 2802) {
		info->peffect = 8421425;
		craftItemText();
	}
	else if (info->cloth_hand == 2866) {
		info->peffect = 8421426;
		craftItemText();
	}
	else if (info->cloth_hand == 2876) {
		info->peffect = 8421427;
		craftItemText();
	}
	else if (info->cloth_hand == 2886) {
		info->peffect = 8421430;
		craftItemText();
	}
	else if (info->cloth_hand == 2890) {
		info->peffect = 8421431;
		craftItemText();
	}
	else if (info->cloth_hand == 3066) {
		info->peffect = 8421433;
		craftItemText();
	}
	else if (info->cloth_hand == 3124) {
		info->peffect = 8421434;
		craftItemText();
	}
	else if (info->cloth_hand == 3168) {
		info->peffect = 8421435;
		craftItemText();
	}
	else if (info->cloth_hand == 3214) {
		info->peffect = 8421436;
		craftItemText();
	}
	else if (info->cloth_hand == 3300) {
		info->peffect = 8421440;
		craftItemText();
	}
	else if (info->cloth_hand == 3418) {
		info->peffect = 8421441;
		craftItemText();
	}
	else if (info->cloth_hand == 3476) {
		info->peffect = 8421442;
		craftItemText();
	}
	else if (info->cloth_hand == 3686) {
		info->peffect = 8421444;
		craftItemText();
	}
	else if (info->cloth_hand == 3716) {
		info->peffect = 8421445;
		craftItemText();
	}
	else if (info->cloth_hand == 4290) {
		info->peffect = 8421447;
		craftItemText();
	}
	else if (info->cloth_hand == 4474) {
		info->peffect = 8421448;
		craftItemText();
	}
	else if (info->cloth_hand == 4464) {
		info->peffect = 8421449;
		craftItemText();
	}
	else if (info->cloth_hand == 1576) {
		info->peffect = 8421450;
		craftItemText();
	}
	else if (info->cloth_hand == 4778 || info->cloth_hand == 6026) {
		info->peffect = 8421452;
		craftItemText();
	}
	else if (info->cloth_hand == 4996) {
		info->peffect = 8421453;
		craftItemText();
	}
	else if (info->cloth_hand == 4840) {
		info->peffect = 8421454;
		craftItemText();
	}
	else if (info->cloth_hand == 5480) {
		info->peffect = 8421456;
		craftItemText();
	}
	else if (info->cloth_hand == 6110) {
		info->peffect = 8421457;
		craftItemText();
	}
	else if (info->cloth_hand == 6308) {
		info->peffect = 8421458;
		craftItemText();
	}
	else if (info->cloth_hand == 6310) {
		info->peffect = 8421459;
		craftItemText();
	}
	else if (info->cloth_hand == 6298) {
		info->peffect = 8421460;
		craftItemText();
	}
	else if (info->cloth_hand == 6756) {
		info->peffect = 8421461;
		craftItemText();
	}
	else if (info->cloth_hand == 7044) {
		info->peffect = 8421462;
		craftItemText();
	}
	else if (info->cloth_shirt == 6892) {
		info->peffect = 8421463;
		craftItemText();
	}
	else if (info->cloth_hand == 7088) {
		info->peffect = 8421465;
		craftItemText();
	}
	else if (info->cloth_hand == 7098) {
		info->peffect = 8421466;
		craftItemText();
	}
	else if (info->cloth_shirt == 7192) {
		info->peffect = 8421467;
		craftItemText();
	}
	else if (info->cloth_shirt == 7136) {
		info->peffect = 8421468;
		craftItemText();
	}
	else if (info->cloth_mask == 7216) {
		info->peffect = 8421470;
		craftItemText();
	}
	else if (info->cloth_back == 7196) {
		info->peffect = 8421471;
		craftItemText();
	}
	else if (info->cloth_back == 7392) {
		info->peffect = 8421472;
		craftItemText();
	}
	else if (info->cloth_feet == 7384) {
		info->peffect = 8421474;
		craftItemText();
	}
	else if (info->cloth_hand == 7488) {
		info->peffect = 8421479;
		craftItemText();
	}
	else if (info->cloth_hand == 7586) {
		info->peffect = 8421480;
		craftItemText();
	}
	else if (info->cloth_hand == 7650) {
		info->peffect = 8421481;
		craftItemText();
	}
	else if (info->cloth_feet == 7950) {
		info->peffect = 8421489;
		craftItemText();
	}
	else if (info->cloth_hand == 8036) {
		info->peffect = 8421494;
		craftItemText();
	}
	else if (info->cloth_hand == 8910) {
		info->peffect = 8421505;
		craftItemText();
	}
	else if (info->cloth_hand == 8942) {
		info->peffect = 8421506;
		craftItemText();
	}
	else if (info->cloth_hand == 8948) {
		info->peffect = 8421507;
		craftItemText();
	}
	else if (info->cloth_hand == 8946) {
		info->peffect = 8421509;
		craftItemText();
	}
	else if (info->cloth_back == 9006) {
		info->peffect = 8421511;
		craftItemText();
	}
	else if (info->cloth_hand == 9116 || info->cloth_hand == 9118 || info->cloth_hand == 9120 || info->cloth_hand == 9122) {
		info->peffect = 8421376 + 111;
		craftItemText();
	}
	else {
		info->peffect = 8421376;
		craftItemText();
	}
}

void updateEntrance(ENetPeer* peer, int foreground, int x, int y, bool open, int bg) {
	BYTE* data = new BYTE[69];// memset(data, 0, 69);
	for (int i = 0; i < 69; i++) data[i] = 0;
	int four = 4; int five = 5; int eight = 8;
	int huhed = (65536 * bg) + foreground; int loled = 128;

	memcpy(data, &four, 4);
	memcpy(data + 4, &five, 4);
	memcpy(data + 16, &eight, 4);
	memcpy(data + 48, &x, 4);
	memcpy(data + 52, &y, 4);
	memcpy(data + 56, &eight, 4);
	memcpy(data + 60, &foreground, 4);
	memcpy(data + 62, &bg, 4);

	if (open) {
		int state = 0;
		memcpy(data + 66, &loled, 4);
		memcpy(data + 68, &state, 4);
	}
	else {
		int state = 100;
		int yeetus = 25600;
		memcpy(data + 67, &yeetus, 5);
		memcpy(data + 68, &state, 4);
	}
	ENetPacket* p = enet_packet_create(data, 69, ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, p);
}
void sendWorldCursed(ENetPeer* peer, WorldInfo* worldInfo)
{
#ifdef TOTAL_LOG
	cout << "Entering a world..." << endl;
#endif
	if (worldproperlock == false)
	{
		((PlayerInfo*)(peer->data))->joinClothesUpdated = false;
		string asdf = "0400000004A7379237BB2509E8E0EC04F8720B050000000000000000FBBB0000010000007D920100FDFDFDFD04000000040000000000000000000000070000000000"; // 0400000004A7379237BB2509E8E0EC04F8720B050000000000000000FBBB0000010000007D920100FDFDFDFD04000000040000000000000000000000080000000000000000000000000000000000000000000000000000000000000048133A0500000000BEBB0000070000000000
		string worldName = "HELL";
		int xSize = worldInfo->width;
		int ySize = worldInfo->height;
		int square = xSize * ySize;
		__int16 nameLen = worldName.length();
		int payloadLen = asdf.length() / 2;
		int dataLen = payloadLen + 2 + nameLen + 12 + (square * 8) + 4;
		int allocMem = payloadLen + 2 + nameLen + 12 + (square * 8) + 4 + 16000;
		BYTE* data = new BYTE[allocMem];
		for (int i = 0; i < asdf.length(); i += 2)
		{
			char x = ch2n(asdf[i]);
			x = x << 4;
			x += ch2n(asdf[i + 1]);
			memcpy(data + (i / 2), &x, 1);
		}
		int zero = 0;
		__int16 item = 0;
		int smth = 0;
		for (int i = 0; i < square * 8; i += 4) memcpy(data + payloadLen + i + 14 + nameLen, &zero, 4);
		for (int i = 0; i < square * 8; i += 8) memcpy(data + payloadLen + i + 14 + nameLen, &item, 2);
		memcpy(data + payloadLen, &nameLen, 2);
		memcpy(data + payloadLen + 2, worldName.c_str(), nameLen);
		memcpy(data + payloadLen + 2 + nameLen, &xSize, 4);
		memcpy(data + payloadLen + 6 + nameLen, &ySize, 4);
		memcpy(data + payloadLen + 10 + nameLen, &square, 4);
		BYTE* blockPtr = data + payloadLen + 14 + nameLen;
		for (int i = 0; i < square; i++) {
			if (isMail(worldInfo->items[i].foreground))
			{
				int mailX = i % worldInfo->width;
				int mailY = i / worldInfo->width;
				std::ifstream ifs("mails/" + worldInfo->name + "." + std::to_string(mailX) + "." + std::to_string(mailY) + ".json");
				if (ifs.is_open())
				{
					json j;
					ifs >> j;
					int amount = j["amount"];
					//
					if (amount == 10)
					{
						updateSign(peer, worldInfo->items[i].foreground, i % worldInfo->width, i / worldInfo->width, "`wThere is `210 `wletters in it (`4Full`w)``", worldInfo->items[i].background);
					}
					else
					{
						updateSign(peer, worldInfo->items[i].foreground, i % worldInfo->width, i / worldInfo->width, "`wThere is `2" + std::to_string(amount) + " `wletters in it``", worldInfo->items[i].background);
					}
				}
				else
				{
				}
			}
			if ((worldInfo->items[i].foreground == 0) || (worldInfo->items[i].foreground == 2) || (worldInfo->items[i].foreground == 8) || (worldInfo->items[i].foreground == 100)/* || (worldInfo->items[i].foreground%2)*/)
			{
				memcpy(blockPtr, &worldInfo->items[i].foreground, 2);
				int type = 0x00000000;
				// type 1 = locked
				if (worldInfo->items[i].water)
					type |= 0x04000000;
				if (worldInfo->items[i].glue)
					type |= 0x08000000;
				if (worldInfo->items[i].fire)
					type |= 0x10000000;
				if (worldInfo->items[i].red)
					type |= 0x20000000;
				if (worldInfo->items[i].green)
					type |= 0x40000000;
				if (worldInfo->items[i].blue)
					type |= 0x80000000;


				// int type = 0x04000000; = water
				// int type = 0x08000000 = glue
				// int type = 0x10000000; = fire
				// int type = 0x20000000; = red color
				// int type = 0x40000000; = green color
				// int type = 0x80000000; = blue color
				memcpy(blockPtr + 4, &type, 4);
				/*if (worldInfo->items[i].foreground % 2)
				{
				blockPtr += 6;
				}*/
			}
			else
			{
				memcpy(blockPtr, &zero, 2);
			}
			memcpy(blockPtr + 2, &worldInfo->items[i].background, 2);
			blockPtr += 8;
			/*if (blockPtr - data < allocMem - 2000) // realloc
			{
			int wLen = blockPtr - data;
			BYTE* oldData = data;


			data = new BYTE[allocMem + 16000];
			memcpy(data, oldData, allocMem);
			allocMem += 16000;
			delete oldData;
			blockPtr = data + wLen;

			}*/
		}
		memcpy(data + dataLen - 4, &smth, 4);
		ENetPacket* packet2 = enet_packet_create(data,
			dataLen,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet2);
		//enet_host_flush(server);
		for (int i = 0; i < square; i++) {
			if ((worldInfo->items[i].foreground == 0) || (worldInfo->items[i].foreground == 2) || (worldInfo->items[i].foreground == 8) || (worldInfo->items[i].foreground == 100))
				; // nothing
			else
			{
				PlayerMoving data;
				//data.packetType = 0x14;
				data.packetType = 0x3;

				//data.characterState = 0x924; // animation
				data.characterState = 0x0; // animation
				data.x = i % worldInfo->width;
				data.y = i / worldInfo->height;
				data.punchX = i % worldInfo->width;
				data.punchY = i / worldInfo->width;
				data.XSpeed = 0;
				data.YSpeed = 0;
				data.netID = -1;
				data.plantingTree = worldInfo->items[i].foreground;
				SendPacketRaw(4, packPlayerMoving(&data), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
			}
		}
		((PlayerInfo*)(peer->data))->currentWorld = worldInfo->name;

		//print_ip(peer->address.host);


		if (((PlayerInfo*)(peer->data))->haveGrowId) {

			PlayerInfo* p = ((PlayerInfo*)(peer->data));
			std::ifstream ifff("players/" + PlayerDB::getProperName(p->rawName) + ".json");
			json j;
			ifff >> j;

			p->currentWorld = worldInfo->name;

			int bac, han, fac, hai, fee, pan, nec, shi, mas, anc, ban;
			bac = j["ClothBack"];
			han = j["ClothHand"];
			fac = j["ClothFace"];
			hai = j["ClothHair"];
			fee = j["ClothFeet"];
			pan = j["ClothPants"];
			nec = j["ClothNeck"];
			shi = j["ClothShirt"];
			mas = j["ClothMask"];
			anc = j["ClothAnces"];
			ban = j["isBanned"];
			/*vector <string>frns;
			if (j.count("friends") == 1) {
				for (int i = 0; i < j["friends"].size(); i++) {
					frns.push_back(j["friends"][i]);
				}
			}
			else {
				frns = {};
			}*/

			p->cloth_back = bac;
			p->cloth_hand = han;
			p->cloth_face = fac;
			p->cloth_hair = hai;
			p->cloth_feet = fee;
			p->cloth_pants = pan;
			p->cloth_necklace = nec;
			p->cloth_shirt = shi;
			p->cloth_mask = mas;

			sendClothes(peer);

			ifff.close();

		}

		delete data;

	}
}
void sendWorldOffers(ENetPeer* peer)
{
	if (!((PlayerInfo*)(peer->data))->isIn) return;
	vector<WorldInfo> worlds = worldDB.getRandomWorlds();
	string worldOffers = "default|";
	if (worlds.size() > 0) {
		worldOffers += worlds[0].name;
	}

	worldOffers += "\nadd_button|Showing: Worlds``|_catselect_|0.6|4278190335|\n";
	for (int i = 0; i < worlds.size(); i++) {
		worldOffers += "add_floater|" + worlds[i].name + "|" + std::to_string(getPlayersCountInWorld(worlds[i].name)) + "|0.55|3529161471\n";
	}
	worldOffers += "add_floater|START|0.5||4288190335\n";
	//GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnRequestWorldSelectMenu"), "default|GO FOR IT\nadd_button|Showing: `wFake Worlds``|_catselect_|0.6|3529161471|\nadd_floater|Subscribe|5|0.55|3529161471\nadd_floater|Growtopia|4|0.52|4278190335\nadd_floater|Noobs|150|0.49|3529161471\nadd_floater|...|3|0.49|3529161471\nadd_floater|`6:O :O :O``|2|0.46|3529161471\nadd_floater|SEEMS TO WORK|2|0.46|3529161471\nadd_floater|?????|1|0.43|3529161471\nadd_floater|KEKEKEKEK|13|0.7|3417414143\n"));
	//for (int i = 0; i < p.len; i++) cout << (int)*(p.data + i) << " ";
	GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnRequestWorldSelectMenu"), worldOffers));
	ENetPacket* packet3 = enet_packet_create(p3.data,
		p3.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet3);
	delete p3.data;
	//enet_host_flush(server);
}
void sendDialog(ENetPeer* peer, string message) {
	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), message));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet);
	delete p.data;
}
void sendPlayerToWorld(ENetPeer* peer, PlayerInfo* player, string wrldname, int x_ = -1, int y_ = -1)
{




	toUpperCase(wrldname);
	if (wrldname == "CON" || wrldname == "NUL" || wrldname == "PRN" || wrldname == "AUX" || wrldname == "CLOCK$" || wrldname == "COM0" || wrldname == "COM1" || wrldname == "COM2" || wrldname == "COM3" || wrldname == "COM4" || wrldname == "COM5" || wrldname == "COM6" || wrldname == "COM7" || wrldname == "COM8" || wrldname == "COM9" || wrldname == "LPT0" || wrldname == "LPT1" || wrldname == "LPT2" || wrldname == "LPT3" || wrldname == "LPT4" || wrldname == "LPT5" || wrldname == "LPT6" || wrldname == "LPT7" || wrldname == "LPT8" || wrldname == "LPT9")
	{
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `eWhoops! `wThis `oworld`w can't be warped to, as it is used by `4System`w.``"));
		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);

		delete p.data;
	}
	else
	{
		{
			sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
		}

		WorldInfo info = worldDB.get(wrldname);
		sendWorld(peer, &info);



		int x = 3040;
		int y = 736;


		for (int j = 0; j < info.width * info.height; j++)
		{
			if (info.items[j].foreground == 6) {
				x = (j % info.width) * 32;
				y = (j / info.width) * 32;
			}
		}
		if (x_ != -1 && y_ != -1) { x = x_ * 32; y = y_ * 32; }
		int uid = ((PlayerInfo*)(peer->data))->userID;
		GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnSpawn"), "spawn|avatar\nnetID|" + std::to_string(cId) + "\nuserID|" + std::to_string(uid) + "\ncolrect|0|0|20|30\nposXY|" + std::to_string(x) + "|" + std::to_string(y) + "\nname|``" + ((PlayerInfo*)(peer->data))->displayName + "``\ncountry|" + ((PlayerInfo*)(peer->data))->country + "\ninvis|0\nmstate|0\nsmstate|0\ntype|local\n"));


		ENetPacket* packet = enet_packet_create(p.data,
			p.len,
			ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(peer, 0, packet);


		delete p.data;
		((PlayerInfo*)(peer->data))->netID = cId;
		onPeerConnect(peer);
		cId++;


		sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);




	}
}
void DoCancelTransitionAndTeleport(ENetPeer* peer, int x, int y)
{
	GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnZoomCamera"), 2));
	SendGamePacket(peer, &p);
	GamePacket p2 = packetEnd(appendIntx(appendString(createPacket(), "OnSetFreezeState"), 0));
	memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	SendGamePacket(peer, &p2);
	GamePacket p3 = packetEnd(appendInt(appendString(createPacket(), "OnFailedToEnterWorld"), 1));
	SendGamePacket(peer, &p3);
	GamePacket p4 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), x * 32, y * 32));
	memcpy(p4.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	SendGamePacket(peer, &p4);
}

void DoEnterDoor(ENetPeer* peer, WorldInfo* world, int x, int y)
{
	int idx = x + world->width * y;
	//// First determine door data
	//if (world->blocks[idx].blockData == NULL)
	//{
	//	// fail
	//	DoCancelTransitionAndTeleport(peer, x, y);
	//}
	//else if (world->blocks[idx].blockData->type != 2)
	//{
	//	// fail
	//	DoCancelTransitionAndTeleport(peer, x, y);
	//}
	//else
	{
		WorldItem block = world->items[idx];
		if (block.destWorld == "EXIT")
		{
			// fail
			sendPlayerLeave(peer, ((PlayerInfo*)(peer->data)));
			sendWorldOffers(peer); // this essentially acts just like a Main Door would
		}
		if (block.destWorld == "")
		{
			// it's this world, find a door here
			int x = 0;
			int y = 0;
			for (int i = 0; i < world->width * world->height; i++)
			{
				ItemDefinition def = getItemDef(world->items[i].foreground);
				if (def.blockType == BlockTypes::DOOR) {
					WorldItem blockDest = world->items[i];
					if (blockDest.currId == block.destId)
					{
						x = (i % world->width);
						y = (i / world->width);
						DoCancelTransitionAndTeleport(peer, x, y);
						return;
					}
				}
			}
			x = 0;
			y = 0;

			for (int j = 0; j < world->width * world->height; j++)
			{
				if (world->items[j].foreground == 6) {
					x = (j % world->width);
					y = (j / world->width);
				}
			}
			DoCancelTransitionAndTeleport(peer, x, y);
		}
		else
		{
			try
			{
				WorldInfo worldDest = worldDB.get(block.destWorld);
				if (block.destId == "")
				{
					int x_ = 0;
					int y_ = 0;

					for (int j = 0; j < worldDest.width * worldDest.height; j++)
					{
						if (worldDest.items[j].foreground == 6) {
							x_ = (j % worldDest.width);
							y_ = (j / worldDest.width);
						}
					}
					sendPlayerToWorld(peer, ((PlayerInfo*)(peer->data)), block.destWorld, x_, y_);
					return;
				}
				else
				{
					int x_ = 0;
					int y_ = 0;
					bool found = false;
					for (int i = 0; i < worldDest.width * worldDest.height; i++)
					{
						ItemDefinition def = getItemDef(worldDest.items[i].foreground);
						if (def.blockType == BlockTypes::DOOR) {
							WorldItem blockDest = worldDest.items[i];
							if (block.currId == blockDest.destId)
							{
								x_ = (i % world->width);
								y_ = (i / world->width);
								sendPlayerToWorld(peer, ((PlayerInfo*)(peer->data)), block.destWorld, x_, y_);
								found = true;
								break;
							}
						}
					}
					if (!found)
					{
						int x = 0;
						int y = 0;

						for (int j = 0; j < worldDest.width * worldDest.height; j++)
						{
							if (worldDest.items[j].foreground == 6) {
								x = (j % worldDest.width);
								y = (j / worldDest.width);
							}
						}
						sendPlayerToWorld(peer, ((PlayerInfo*)(peer->data)), block.destWorld, x, y);
					}
				}
			}
			catch (int e)
			{
				DoCancelTransitionAndTeleport(peer, x, y);
				sendChatMessage(peer, (((PlayerInfo*)(peer->data))->netID), "That door can't lead to such an awesome place!");
			}
		}
	}
	GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetFreezeState"), 0));
	memcpy(p5.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
	ENetPacket* packet5 = enet_packet_create(p5.data,
		p5.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet5);
	enet_host_flush(server);

	GamePacket p4 = packetEnd(appendIntx(appendString(createPacket(), "OnFailedToEnterWorld"), 1));
	ENetPacket* packet4 = enet_packet_create(p4.data,
		p4.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(peer, 0, packet4);
	enet_host_flush(server);
}




//replaced X-to-close with a Ctrl+C exit
void exitHandler(int s) {
	saveAllWorlds();
	exit(0);

}

bool has_only_digits(const string s) {
	return s.find_first_not_of("0123456789") == string::npos;
}
bool has_only_digits_wnegative(const string s) {
	return s.find_first_not_of("-0123456789") == string::npos;
}
std::ifstream::pos_type filesize(const char* filename)
{
	std::ifstream in(filename, std::ifstream::ate | std::ifstream::binary);
	return in.tellg();
}

uint32_t HashString(unsigned char* str, int len)
{
	if (!str) return 0;

	unsigned char* n = (unsigned char*)str;
	uint32_t acc = 0x55555555;

	if (len == 0)
	{
		while (*n)
			acc = (acc >> 27) + (acc << 5) + *n++;
	}
	else
	{
		for (int i = 0; i < len; i++)
		{
			acc = (acc >> 27) + (acc << 5) + *n++;
		}
	}
	return acc;

}

unsigned char* getA(string fileName, int* pSizeOut, bool bAddBasePath, bool bAutoDecompress)
{
	unsigned char* pData = NULL;
	FILE* fp = fopen(fileName.c_str(), "rb");
	if (!fp)
	{
		cout << "[!] File not found" << endl;
		if (!fp) return NULL;
	}

	fseek(fp, 0, SEEK_END);
	*pSizeOut = ftell(fp);
	fseek(fp, 0, SEEK_SET);

	pData = (unsigned char*)new unsigned char[((*pSizeOut) + 1)];
	if (!pData)
	{
		printf("Out of memory opening %s?", fileName.c_str());
		return 0;
	}
	pData[*pSizeOut] = 0;
	fread(pData, *pSizeOut, 1, fp);
	fclose(fp);

	return pData;
}

struct itemDataStruct {
	string name;
	string texturefile;
	string audiofile;
	int id;
	uint8_t editableType;
	uint8_t category;
	uint8_t type;
	uint8_t solid;
	uint16_t rarity;
	uint32_t color1;
	uint32_t color2;
	uint8_t textureX;
	uint8_t textureY;
	uint8_t textureType;
	uint8_t hardness;
	uint16_t audioVol;
	uint32_t texturehash;
	uint32_t audiohash;
	uint8_t seedBase;
	uint8_t seedOverlay;
	uint8_t treeBase;
	uint8_t treeOverlay;
};

void decodeName(char* src, int len, int itemID, char* dest) {
	const char key[] = "PBG892FXX982ABC*";
	for (int i = 0; i < len; i++) {
		dest[i] = src[i] ^ key[(i + itemID) % 16];
	}
}

vector<itemDataStruct> items;
itemDataStruct getItem(int id) {
	if (itemsDat == NULL) {
		itemDataStruct ret;
		ret.id = -1;
		return ret;
	}
	uint8_t* itemsPtr = itemsDat + 60;
	itemsPtr += 4;
	while (true) {
		itemsPtr += *(uint16_t*)itemsPtr + 2;

		if (*(uint16_t*)itemsPtr == id) {
			itemDataStruct item;

			item.id = *(uint16_t*)itemsPtr;
			itemsPtr += 2;

			itemsPtr += 2; // ??

			item.editableType = *(uint8_t*)itemsPtr++;
			item.category = *(uint8_t*)itemsPtr++;
			item.type = *(uint8_t*)itemsPtr++;
			itemsPtr++;

			int nameLen = *(uint16_t*)itemsPtr;
			itemsPtr += 2;
			string name;
			name.resize(nameLen);
			decodeName((char*)itemsPtr, nameLen, id, &name[0]);
			item.name = name;
			itemsPtr += nameLen;

			int textureLen = *(uint16_t*)itemsPtr;
			itemsPtr += 2;
			string texturefile;
			texturefile.resize(textureLen);
			memcpy(&texturefile[0], itemsPtr, textureLen);
			item.texturefile = texturefile;
			itemsPtr += textureLen;

			item.texturehash = *(uint32_t*)itemsPtr;
			itemsPtr += 4;

			itemsPtr += 5; // ??

			item.textureX = *(uint8_t*)itemsPtr++;
			item.textureY = *(uint8_t*)itemsPtr++;
			item.textureType = *(uint8_t*)itemsPtr;
			itemsPtr += 2;

			item.solid = *(uint8_t*)itemsPtr++;

			item.hardness = *(uint8_t*)itemsPtr++;

			itemsPtr += 1; // mystery_3
			itemsPtr += 4; // ??

			item.rarity = *(uint16_t*)itemsPtr;
			itemsPtr += 2;

			itemsPtr += 1; // ??

			int audioLen = *(uint16_t*)itemsPtr;
			itemsPtr += 2;
			string audiofile;
			audiofile.resize(audioLen);
			memcpy(&audiofile[0], itemsPtr, audioLen);
			item.audiofile = audiofile;
			itemsPtr += audioLen;

			item.audiohash = *(uint32_t*)itemsPtr;
			itemsPtr += 4;
			item.audioVol = *(uint16_t*)itemsPtr;
			itemsPtr += 2;

			itemsPtr += 16; // ??

			item.seedBase = *(uint8_t*)itemsPtr++;
			item.seedOverlay = *(uint8_t*)itemsPtr++;
			item.treeBase = *(uint8_t*)itemsPtr++;
			item.treeOverlay = *(uint8_t*)itemsPtr++;

			item.color1 = *(uint32_t*)itemsPtr;
			itemsPtr += 4;
			item.color2 = *(uint32_t*)itemsPtr;
			itemsPtr += 4;

			return item;
		}
		else {
			itemsPtr += 8;
			itemsPtr += *(uint16_t*)itemsPtr + 2;
			itemsPtr += *(uint16_t*)itemsPtr + 2;
			itemsPtr += 23;
			itemsPtr += *(uint16_t*)itemsPtr + 2;
			itemsPtr += 8;
			for (int i = 0; i < 4; i++) itemsPtr += *(uint16_t*)itemsPtr + 2;
			itemsPtr += 24;
			itemsPtr += *(uint16_t*)itemsPtr + 2; // not sure about this
			itemsPtr += *(uint16_t*)itemsPtr + 2;
			itemsPtr += *(uint16_t*)itemsPtr + 2;
			itemsPtr += *(uint16_t*)itemsPtr + 2;
			itemsPtr += 78;
		}

		if (itemsPtr - itemsDat >= itemsDatSize) {
			itemDataStruct item;
			item.id = -1;
			return item;
		}
	}
}
void serializeItems() {
	printf("Loading all items...saveallworlds\n");
	int i = 0;
	while (true) {
		itemDataStruct item = getItem(i++);
		if (item.id == -1) break;
		items.push_back(item);
	}
	printf("Finished loading all items...\n");
}
void commands()
{
	while (commands)
	{
		std::string input;
		std::cin >> input;


		if (input == "exit")
		{
			saveAllWorlds();
			exit(0);
		}
		else if (input == "save") {
			saveAllWorlds();
		}
		else if (input == "online")
		{
			string x;


			ENetPeer* currentPeer;
			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
					continue;


				x.append(((PlayerInfo*)(currentPeer->data))->rawName + " (" + to_string(((PlayerInfo*)(currentPeer->data))->adminLevel) + ")" + " (" + ((PlayerInfo*)(currentPeer->data))->charIP + ")" + ", ");
			}
			x = x.substr(0, x.length() - 2);

			cout << "[!] [Console] Peers connected (includes mods) [format: (rawname) (adminlevel) (IP)]: " << x << endl;

		}
		else if (input == "kickall")
		{
			ENetPeer* currentPeer;
			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
					continue;

				enet_peer_disconnect_later(currentPeer, 0);
				enet_peer_reset(currentPeer);
			}
			cout << "[!] Kicked everyone out of server!" << endl;
		}
		else if (input == "help" || input == "?")
		{
			cout << "[!] Operator commands: " << "help " << "kickall " << "save " << "reload" << "online " << "delete " << "maintenance " << "exit" << endl;
		}
		else {
			cout << "[!] Unknown command, type /help to see list of valid commands." << endl;
		}
	}
}

void loadConfig()
{

	cout << "[!] loading config" << endl;
	std::ifstream ifs("config.json");
	if (ifs.is_open()) {


		json j;
		ifs >> j;

		configPort = j["Port"];
		music = j["Music"].get<string>();

		cout << "[~] Config loaded." << endl;
		cout << "[-] Hosting on Port: " << configPort << endl;
		cout << "[!] Music theme: " << music << endl;



	}




	ifs.close();
	// finished
}
void sendConsole(ENetPeer* x, string e) {
	GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), e));
	ENetPacket* packet = enet_packet_create(p.data,
		p.len,
		ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(x, 0, packet);
	delete p.data;
}

void buildgem() {
	for (int i = 0; i < itemDefs.size(); i++) {
		if ((itemDefs[i].id % 2 == 0)) {//not seed
			if (itemDefs[i].rarity > 0 && itemDefs[i].rarity < 20) {
				vector<int> v = { 1, i, i + 1, 0, 1, 1 , 1 };
				itemDefs[i].gem = v;
			}
			if (itemDefs[i].rarity >= 20 && itemDefs[i].rarity < 50) {
				vector<int> v1 = { 1, i, i + 1, 0, 5, 5 , 1 };
				itemDefs[i].gem = v1;
			}
			if (itemDefs[i].rarity >= 50) {
				vector<int> v2 = { 1, i, i + 1, 0, 5, 10, 10 , 1 };
				itemDefs[i].gem = v2;
			}
		}
		else {
			if (itemDefs[i].rarity > 0 && itemDefs[i].rarity < 20) {
				vector<int> v3 = { 1, i, 0, 1 , 1 };
				itemDefs[i].gem = v3;
			}
			if (itemDefs[i].rarity >= 20 && itemDefs[i].rarity < 50) {
				vector<int> v4 = { 1, i, 0, 5, 5 , 1 };
				itemDefs[i].gem = v4;
			}
			if (itemDefs[i].rarity >= 50) {
				vector<int> v5 = { 1, i, 0, 5, 10, 10 , 1 };
				itemDefs[i].gem = v5;
			}
		}
	}
}
/*
action|log
msg|`4UPDATE REQUIRED!`` : The `$V2.981`` update is now available for your device.  Go get it!  You'll need to install it before you can play online.
[DBG] Some text is here: action|set_url
url|http://ubistatic-a.akamaihd.net/0098/20180909/Growtalestaller.exe
label|Download Latest Version
	*/
	//Linux should not have any arguments in main function.
#ifdef _WIN32
int _tmain(int argc, _TCHAR* argv[])
#else
int main()
#endif
{
	cout << "Growtopia Baskerville (c) v3.46" << endl;
	cout << "Server is starting..." << endl;
	cout << "Server Started, Status online! " + currentDateTime() + "!" << endl;
	loadConfig();
	buildgem();
	std::ifstream t("totaluids.txt");
	std::string str((std::istreambuf_iterator<char>(t)),
		std::istreambuf_iterator<char>());
	totaluserids = atoi(str.c_str());
	enet_initialize();
	//Unnecessary save at exit. Commented out to make the program exit slightly quicker.
	if (atexit(saveAllWorlds)) {
	}
	/*if (RegisterApplicationRestart(L" -restarted", 0) == S_OK)
	{
		cout << "Autorestart is ready" << endl;
	}
	else {
		cout << "Binding autorestart failed!" << endl;
	}
	Sleep(65000);
	int* p = NULL;
	*p = 5;*/
	int itemdathash;
	{
		std::ifstream file("items.dat", std::ios::binary | std::ios::ate);
		itemsDatSize = file.tellg();
		itemsDat = new BYTE[60 + itemsDatSize];
		string asdf = "0400000010000000FFFFFFFF000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
		for (int i = 0; i < asdf.length(); i += 2)
		{
			char x = ch2n(asdf[i]);
			x = x << 4;
			x += ch2n(asdf[i + 1]);
			memcpy(itemsDat + (i / 2), &x, 1);
			if (asdf.length() > 60 * 2) throw 0;
		}
		memcpy(itemsDat + 56, &itemsDatSize, 4);
		file.seekg(0, std::ios::beg);

		if (file.read((char*)(itemsDat + 60), itemsDatSize))
		{
			uint8_t* pData;
			int size = 0;
			const char filename[] = "items.dat";
			size = filesize(filename);
			pData = getA((string)filename, &size, false, false);
			cout << "Server items loaded! hash : " << HashString((unsigned char*)pData, size) << endl;
			itemdathash = HashString((unsigned char*)pData, size);
			file.close();
			//serializeItems();

		}
		else {
			cout << "Server items.dat not found." << endl;
		}
	}


	//world = generateWorld();
	ENetAddress address;
	/* Bind the server to the default localhost.     */
	/* A specific host address can be specified by   */
	enet_address_set_host(&address, "0.0.0.0");
	//address.host = ENET_HOSconT_ANY;
	/* Bind the server to port 1234. */
	address.port = configPort;
	server = enet_host_create(&address /* the address to bind the server host to */,
		1024      /* allow up to 32 clients and/or outgoing connections */,
		10      /* allow up to 2 channels to be used, 0 and 1 */,
		0      /* assume any amount of incoming bandwidth */,
		0      /* assume any amount of outgoing bandwidth */);
	if (server == NULL)
	{
		fprintf(stderr,
			"An error occurred while trying to create an ENet server host.\n");
		while (1);
		exit(EXIT_FAILURE);
	}
	server->checksum = enet_crc32;
	enet_host_compress_with_range_coder(server);

	BuildItemsDatabase();
	cout << "Server database builded!" << endl;
	/*cout << "Items.dat serialized! Loaded items: " << items.size() << endl;
	ofstream decompile;
	decompile.open("itemsdatdecompiled.txt", std::ios_base::app);
	for (int i = 0; i < items.size(); i++) {
		//cout << "Decompiling items.dat at id: " << items[i].id << " with name: " << items[i].name << endl;
		decompile << "name|" << items[i].name << endl;
		decompile << "audiofile|" << items[i].audiofile << endl;
		decompile << "id|" << items[i].id << endl;
		decompile << "editableType|" << items[i].editableType << endl;
		decompile << "itemCategory|" << items[i].category << endl;
		decompile << "actionType|" << items[i].type << endl;
		decompile << "solid|" << items[i].solid << endl;
		decompile << "color1|" << items[i].color1 << endl;
		decompile << "color2|" << items[i].color2 << endl;
		decompile << "textureX|" << items[i].textureX << endl;
		decompile << "textureY|" << items[i].textureY << endl;
		decompile << "textureType|" << items[i].textureType << endl;
		decompile << "hardness|" << items[i].hardness << endl;
		decompile << "audioVol|" << items[i].audioVol << endl;
		decompile << "texturehash|" << items[i].texturehash << endl;
		decompile << "audiohash|" << items[i].audiohash << endl;
		decompile << "seedBase|" << items[i].seedBase << endl;
		decompile << "seedOverlay|" << items[i].seedOverlay << endl;
		decompile << "treeBase|" << items[i].treeBase << endl;
		decompile << "treeOverlay|" << items[i].treeOverlay << endl;
		decompile << "\n";
	}
	decompile.close();*/

	ENetEvent event;
	/* Wait up to 1000 milliseconds for an event. */
	while (true)
		while (enet_host_service(server, &event, 1000) > 0)
		{
			ENetPeer* peer = event.peer;
			if (!peer) continue;
			switch (event.type)
			{
			case ENET_EVENT_TYPE_CONNECT:
			{
#ifdef TOTAL_LOG
				printf("A new client connected.\n");
#endif

				/* Store any relevant client information here. */
				//event.peer->data = "Client information";
				if (getPlayersCountInServer() >= 220) {
					GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `4OOPS: `oServer is at MAX capacity. Please click `5CANCEL `oand try again in a few seconds.``"));
					ENetPacket* packet = enet_packet_create(p.data,
						p.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packet);
					delete p.data;
					//enet_host_flush(server);
					enet_peer_disconnect_later(peer, 0);
				}
				ENetPeer* currentPeer;
				int count = 0;
				for (currentPeer = server->peers;
					currentPeer < &server->peers[server->peerCount];
					++currentPeer)
				{
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
						continue;
					if (currentPeer->address.host == peer->address.host)
						count++;
				}
				event.peer->data = new PlayerInfo;
				/* Get the string ip from peer */
				char clientConnection[16];
				enet_address_get_host_ip(&peer->address, clientConnection, 16);
				((PlayerInfo*)(peer->data))->charIP = clientConnection;
				if (count > 3)
				{
					GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^Too many accounts are logged on from this IP. Log off one account before playing please.``"));
					ENetPacket* packet = enet_packet_create(p.data,
						p.len,
						ENET_PACKET_FLAG_RELIABLE);
					enet_peer_send(peer, 0, packet);
					delete p.data;
					//enet_host_flush(server);
					enet_peer_disconnect_later(peer, 0);
				}
				else {
					sendData(peer, 1, 0, 0);
				}


				continue;
			}
			case ENET_EVENT_TYPE_RECEIVE:
			{

				if (std::find(bannedlist.begin(), bannedlist.end(), ((PlayerInfo*)(peer->data))->tankIDName) != bannedlist.end())
				{
					sendLogonFail(peer, "`oSorry, but`w " + ((PlayerInfo*)(peer->data))->tankIDName + "`o account is `4Banned`o! If you have some questions please Contact Us at Discord!");
					enet_peer_disconnect_later(peer, 0);
				}
				if ((char)event.packet->data == '\xFF') {
					Player::OnConsoleMessage(peer, "`oIf you see this contact the developer!");
					continue;
				}
				
				int messageType = GetMessageTypeFromPacket(event.packet);
				//cout << "[!] Packet type is " << messageType << endl;
				//cout << (event->packet->data+4) << endl;
				WorldInfo* world = getPlyersWorld(peer);
				switch (messageType) {
				case 2:
				{
					string cch = GetTextPointerFromPacket(event.packet);
					if (event.packet->dataLength > 4096) {
						continue;
					}
					if (cch.size() <= 3) {
						break;
					}
					if (cch == "" || cch == " " || cch == "  " || cch == "   " || cch == "    " || cch == "     " || cch == "      " || cch == "       " || cch == "        " || cch == "        ")
					{
						break;
					}
					if (cch.size() > 2048) {
						break;
					}
					if (cch.length() > 2048) {
						break;
					}
					if (cch.find("©") != std::string::npos) {
						break;
					}
					if (((PlayerInfo*)(peer->data))->isUpdating)
					{
						continue;
					}
					if (cch.length() > 500)
					{
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `4Oh No! something is wrong and you will be disconnected..."));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
						enet_peer_disconnect_later(peer, 0);
					}

					string str = cch.substr(cch.find("text|") + 5, cch.length() - cch.find("text|") - 1);
					if (cch.find("action|wrench") == 0) {
						try {
							std::stringstream ss(cch);
							std::string to;
							int id = -1;
							while (std::getline(ss, to, '\n')) {
								vector<string> infoDat = explode("|", to);
								if (infoDat.size() < 3) continue;
								if (infoDat[1] == "netid") {
									try {
										id = stoi(infoDat[2]); // crash fix
									}
									catch (...) {}
								}

							}
							if (id < 0) continue; //not found

							string rolex;
							if (((PlayerInfo*)(peer->data))->adminLevel == 2) {
								rolex = "`6Developer";
							}
							else if (((PlayerInfo*)(peer->data))->adminLevel == 1) {
								rolex = "`#Moderator";
							}
							else if (((PlayerInfo*)(peer->data))->adminLevel == 0) {
								rolex = "`oGrowPlayer";
							}
							else {
								rolex = "`w[GrowDev] Guest";
							}



							string worldsowned;

							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;


								if (isHere(peer, currentPeer)) {
									if (((PlayerInfo*)(currentPeer->data))->netID == id) {

										string rolexs;
										if (((PlayerInfo*)(currentPeer->data))->adminLevel == 2) {
											rolex = "`6Developer";
										}
										else if (((PlayerInfo*)(currentPeer->data))->adminLevel == 1) {
											rolex = "`#Moderator";
										}
										else if (((PlayerInfo*)(currentPeer->data))->adminLevel == 0) {
											rolex = "`oGrowPlayer";
										}
										else {
											rolex = "`w[GrowDev] Guest";
										}

										((PlayerInfo*)(peer->data))->lastInfo = ((PlayerInfo*)(currentPeer->data))->rawName;
										((PlayerInfo*)(peer->data))->lastInfoname = ((PlayerInfo*)(currentPeer->data))->tankIDName;

										string name = ((PlayerInfo*)(currentPeer->data))->displayName;
										string rawnam = ((PlayerInfo*)(peer->data))->rawName;
										string rawnamofwrench = ((PlayerInfo*)(currentPeer->data))->rawName;
										string gems = std::to_string(((PlayerInfo*)(currentPeer->data))->gem);
										string token = std::to_string(((PlayerInfo*)(currentPeer->data))->wls);
										string guildleader = ((PlayerInfo*)(peer->data))->guildLeader;
										if (((PlayerInfo*)(peer->data))->haveGrowId == false) {
											break;
										}
										if (rawnamofwrench != rawnam)
										{

											if (rawnamofwrench != "")
											{
												if (find(((PlayerInfo*)(peer->data))->guildMembers.begin(), ((PlayerInfo*)(peer->data))->guildMembers.end(), name) != ((PlayerInfo*)(peer->data))->guildMembers.end()) {
													if (world->owner == ((PlayerInfo*)(peer->data))->rawName && ((PlayerInfo*)(peer->data))->haveGrowId || ((PlayerInfo*)(peer->data))->adminLevel >= 1)
													{
														if (((PlayerInfo*)(peer->data))->haveGrowId == false) {
															break;
														}
														if (((PlayerInfo*)(peer->data))->adminLevel >= 1 || ((PlayerInfo*)(peer->data))->rawName == "baskerville" || ((PlayerInfo*)(peer->data))->rawName == "baskerville")
														{
															packet::dialog(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + to_string(((PlayerInfo*)(currentPeer->data))->level) + "`w)``|left|18|\nadd_spacer|small||\nadd_spacer|small|\nadd_label|small|\nadd_label|small|`oGems : `w" + gems + "$|left|4|\nadd_spacer|small|\nadd_button|pull|`5Pull|0|0|\nadd_button|kick|`4Kick|0|0|\nadd_button|wban|`4World Ban|0|0|\nadd_spacer|small|\nadd_button|tradebutton|`wTrade|0|0|\nadd_button|tradebutton|`wTrade|0|0|\nadd_button|addfriendrnbutton|`wAdd Friend|0|0|\nadd_button|\nadd_spacer|small|Continue|0|0|\nadd_quick_exit");

														}
														else
														{
															packet::dialog(peer, "set_default_color|`o\nadd_label_with_icon|big|`0" + name + " `w(`2" + to_string(((PlayerInfo*)(currentPeer->data))->level) + "`w)``|left|18|\nadd_spacer|small|\nadd_label|small|\nadd_label|small|`oGems : `w" + gems + "$|left|4|\nadd_button|pull|`5Pull|0|0|\nadd_button|kick|`4Kick|0|0|\nadd_button|wban|`4World Ban|0|0|\nadd_button|giveownership|`wGive ownership to this player!|0|0|\nadd_spacer|small|\nadd_button||Continue|0|0|\nadd_quick_exit");

														}
													}
													else
													{
														packet::dialog(peer, "set_default_color|`o\nadd_label_with_icon|big|`0" + name + " `w(`2" + to_string(((PlayerInfo*)(currentPeer->data))->level) + "`w)``|left|18|\nadd_spacer|small|\nadd_label|small|\nadd_label|small|`oGems : `w" + gems + "$|left|4|\nadd_spacer|small|\nadd_button||Continue|0|0|\nadd_quick_exit");

													}
												}
												else if (((PlayerInfo*)(peer->data))->rawName == guildleader) {
													if (world->owner == ((PlayerInfo*)(peer->data))->rawName && ((PlayerInfo*)(peer->data))->haveGrowId || ((PlayerInfo*)(peer->data))->adminLevel >= 1)
													{
														if (((PlayerInfo*)(peer->data))->adminLevel >= 1 || ((PlayerInfo*)(peer->data))->rawName == "baskerville")
														{
															packet::dialog(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + to_string(((PlayerInfo*)(currentPeer->data))->level) + "`w)``|left|18|\nadd_spacer|small|\nadd_label|small|`oGems : `w" + gems + "$|left|4|\nadd_label|small|\nadd_spacer|small|\nadd_button|inviteguildbutton|`wInvite to guild|0|0|\nadd_button|pull|`5Pull|0|0|\nadd_button|kick|`4Kick|0|0|\nadd_button|wban|`4World Ban|0|0|\nadd_button|tradebutton|`wTrade|0|0|\nadd_button|addfriendrnbutton|`wAdd Friend|0|0|\nadd_spacer|small|\nadd_button||Continue|0|0|\nadd_quick_exit");

														}
														else
														{
															packet::dialog(peer, "set_default_color|`o\nadd_label_with_icon|big|`0" + name + " `w(`2" + to_string(((PlayerInfo*)(currentPeer->data))->level) + "`w)``|left|18|\nadd_spacer|small|\nadd_label|small|\nadd_label|small|`oGems : `w" + gems + "$|left|4|\nadd_button|inviteguildbutton|`wInvite to guild|0|0|\nadd_button|pull|`5Pull|0|0|\nadd_button|kick|`4Kick|0|0|\nadd_button|wban|`4World Ban|0|0|\nadd_button|tradebutton|`wTrade|0|0|\nadd_button|addfriendrnbutton|`wAdd Friend|0|0|\nadd_spacer|small|\nadd_button||Continue|0|0|\nadd_quick_exit");

														}
													}
													else
													{
														packet::dialog(peer, "set_default_color|`o\nadd_label_with_icon|big|`0" + name + " `w(`2" + to_string(((PlayerInfo*)(currentPeer->data))->level) + "`w)``|left|18|\nadd_spacer|small|\nadd_label|small|\nadd_label|small|`oGems : `w" + gems + "$|left|4|\nadd_button|tradebutton|`wTrade|0|0|\nadd_button|addfriendrnbutton|`wAdd Friend|0|0|\nadd_spacer|small|\nadd_button||Continue|0|0|\nadd_quick_exit");

													}
												}
												else {
													if (world->owner == ((PlayerInfo*)(peer->data))->rawName && ((PlayerInfo*)(peer->data))->haveGrowId || ((PlayerInfo*)(peer->data))->adminLevel >= 1)
													{
														if (((PlayerInfo*)(peer->data))->adminLevel >= 1 || ((PlayerInfo*)(peer->data))->rawName == "baskerville")
														{
															packet::dialog(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + to_string(((PlayerInfo*)(currentPeer->data))->level) + "`w)``|left|18|\nadd_spacer|small|\nadd_label|small|\nadd_label|small|`oGems : `w" + gems + "$|left|4|\nadd_spacer|small|\nadd_button|tradebutton|`wTrade|0|0|\nadd_button|addfriendrnbutton|`wAdd Friend|0|0|\nadd_button|pull|`5Pull|0|0|\nadd_button|kick|`4Kick|0|0|\nadd_button|wban|`4World Ban|0|0|\nadd_button|infobutton|`4Punish/view|0|0|\nadd_spacer|small|\nadd_button||Continue|0|0|\nadd_quick_exit");
														}
														else
														{
															packet::dialog(peer, "set_default_color|`o\nadd_label_with_icon|big|`0" + name + " `w(`2" + to_string(((PlayerInfo*)(currentPeer->data))->level) + "`w)``|left|18|\nadd_spacer|small|\nadd_label|small|\nadd_label|small|`oGems : `w" + gems + "$|left|4|\nadd_button|tradebutton|`wTrade|0|0|\nadd_button|addfriendrnbutton|`wAdd Friend|0|0||\nadd_button|pull|`5Pull|0|0|\nadd_button|kick|`4Kick|0|0|\nadd_button|wban|`4World Ban|0|0|\nadd_spacer|small|\nadd_button||Continue|0|0|\nadd_quick_exit");
														}
													}
													else
													{
														packet::dialog(peer, "set_default_color|`o\nadd_label_with_icon|big|`0" + name + " `w(`2" + to_string(((PlayerInfo*)(currentPeer->data))->level) + "`w)``|left|18|\nadd_spacer|small|\nadd_label|small|\nadd_label|small|`oGems : `w" + gems + "$|left|4|\nadd_button|tradebutton|`wTrade|0|0|\nadd_button|addfriendrnbutton|`wAdd Friend|0|0|\nadd_spacer|small|\nadd_button||Continue|0|0|\nadd_quick_exit");
													}
												}
											}
											else
											{
												packet::dialog(peer, "set_default_color|`o\nadd_label_with_icon|big|`0" + name + " `w(`2" + to_string(((PlayerInfo*)(currentPeer->data))->level) + "`w)``|left|\nadd_spacer|small|\nadd_button|chc0|Close|noflags|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
											}
										}
										else
										{
											if (((PlayerInfo*)(peer->data))->haveGrowId == true)
											{
												long playmore = 0;// = ((PlayerInfo*)(peer->data))->clover - GetCurrentTimeInternalSeconds();

												string buffs;
												if (playmore > 0) {
													buffs += "\nadd_label_with_icon|small|`wLucky Cover `o(`w" + OutputBanTime(playmore) + "`o)``|left|528|";
												}
												else
												{
													buffs += "\nadd_label_with_icon|small|`wYou don't have any active effects``|left|18|";
												}
												std::ostringstream oss;
												if (!((PlayerInfo*)(peer->data))->worldsowned.empty())
												{
													std::copy(((PlayerInfo*)(peer->data))->worldsowned.begin(), ((PlayerInfo*)(peer->data))->worldsowned.end() - 1,
														std::ostream_iterator<string>(oss, " , "));

													// Now add the last element with no delimiter
													oss << ((PlayerInfo*)(peer->data))->worldsowned.back();
												}
												else {
													string oss = "You dont have any worlds!";
												}
												int yy = ((PlayerInfo*)(peer->data))->posX / 32;
												int xx = ((PlayerInfo*)(peer->data))->posY / 32;
												int levels = ((PlayerInfo*)(peer->data))->level;
												int xp = ((PlayerInfo*)(peer->data))->xp;
												string currentworld = ((PlayerInfo*)(peer->data))->currentWorld;

												if (((PlayerInfo*)(peer->data))->haveGrowId == false) {
													break;
												}
												bool existsbansz = std::experimental::filesystem::exists("sup/_" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
												string sup;

												if (existsbansz) {
													sup += "`oYou are a `2Super Supporter";
												}
												else {
													sup += "`oYou are not yet a `2Super Supporter";
												}
												if (((PlayerInfo*)(peer->data))->joinguild == true) {
													packet::dialog(peer, "set_default_color|`o\n\nadd_player_info|" + name + "|" + std::to_string(levels) + "|" + std::to_string(xp) + "|" + to_string((600 * ((PlayerInfo*)(peer->data))->level)) + "|\nadd_spacer|small|\nadd_button|worlds|My worlds|left|\nadd_button|account|Account settings|left|\nadd_button|notebook|Notebook|left|\nadd_spacer|small|\nadd_dual_layer_icon_label|small|`9Guild : `2" + ((PlayerInfo*)(peer->data))->guild + "|right|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\nadd_spacer|small|\nadd_textbox|Active effects :|left|" + buffs + "\nadd_spacer|small|\nadd_textbox|`oCurrent role`o: " + rolex + "|left|\nadd_spacer|small|\nadd_textbox|`oYou have `w" + to_string(((PlayerInfo*)(peer->data))->currentInventorySize) + " `obackpack slots.|\nadd_textbox|`oCurrent world:`w " + ((PlayerInfo*)(currentPeer->data))->currentWorld + "``(`w" + std::to_string(xx) + "``, `w" + std::to_string(yy) + "``) (`w" + std::to_string(getPlayersCountInWorld(((PlayerInfo*)(currentPeer->data))->currentWorld)) + "`` person)````|left|\nadd_spacer|small|\nadd_button|mojis|Growmojis|left|\nadd_spacer|small|\nadd_label|small|" + sup + "|left|\nadd_spacer|small|\n\nadd_quick_exit|\nend_dialog||Close|");
												}
												else if (((PlayerInfo*)(peer->data))->isinvited == true) {
													packet::dialog(peer, "set_default_color|`o\n\nadd_player_info|" + name + "|" + std::to_string(levels) + "|" + std::to_string(xp) + "|" + to_string((600 * ((PlayerInfo*)(peer->data))->level))  + "|\nadd_spacer|small|\nadd_button|worlds|My worlds|left|\nadd_button|account|Account settings|left|\nadd_button|notebook|Notebook|left|\nadd_spacer|small|\nadd_button|joinguild|`9Join `w" + ((PlayerInfo*)(currentPeer->data))->guildlast + " `9Guild!|left|\nadd_spacer|small|\nadd_textbox|Active effects :|left|" + buffs + "\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|`oCurrent role`o: " + rolex + "|left|\nadd_spacer|small|\nadd_textbox|`oYou have `w" + to_string(((PlayerInfo*)(peer->data))->currentInventorySize) + " `obackpack slots.|\nadd_textbox|`oCurrent world:`w " + ((PlayerInfo*)(currentPeer->data))->currentWorld + "``(`w" + std::to_string(xx) + "``, `w" + std::to_string(yy) + "``) (`w" + std::to_string(getPlayersCountInWorld(((PlayerInfo*)(currentPeer->data))->currentWorld)) + "`` person)````|left|\nadd_spacer|small|\nadd_button|mojis|Growmojis|left|\nadd_spacer|small|\nadd_label|small|" + sup + "|left|\nadd_spacer|small|\n\nadd_quick_exit|\nend_dialog||Close|");
												}
												packet::dialog(peer, "set_default_color|`o\n\nadd_player_info|" + name + "|" + std::to_string(levels) + "|" + std::to_string(xp) + "|" + to_string((600 * ((PlayerInfo*)(peer->data))->level)) + "|\nadd_spacer|small|\nadd_button|worlds|My worlds|left|\nadd_button|account|Account settings|left|\nadd_button|notebook|Notebook|left|\nadd_spacer|small|\nadd_textbox|Active effects :|left|" + buffs + "\nadd_spacer|small|\nadd_textbox|`oCurrent role`o: " + rolex + "|left|\nadd_spacer|small|\nadd_textbox|`oYou have `w" + to_string(((PlayerInfo*)(peer->data))->currentInventorySize) + " `obackpack slots.|\nadd_textbox|`oCurrent world:`w " + ((PlayerInfo*)(currentPeer->data))->currentWorld + "``(`w" + std::to_string(xx) + "``, `w" + std::to_string(yy) + "``) (`w" + std::to_string(getPlayersCountInWorld(((PlayerInfo*)(currentPeer->data))->currentWorld)) + "`` person)````|left|\nadd_spacer|small|\nadd_button|mojis|Growmojis|left|\nadd_spacer|small|\nadd_label|small|" + sup + "|left|\nadd_spacer|small|\n\nadd_quick_exit|\nend_dialog||Close|");
											}
											else
											{
											}
										}

									}


								}


							}
						}
						catch (...) {
							ofstream collectlog("crash.txt", ios::app);
							collectlog << "error in action|wrench" << endl;
							collectlog.close();
							cout << "error in action|wrench";
						}
					}
					if (cch.find("action|friends") == 0)
					{
						if (((PlayerInfo*)(peer->data))->joinguild == true) {
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|backonlinelist|Show Friends``|0|0|\nadd_button|changelogs|Change logs``|0|0|\nadd_button|showguild|Show Guild Members``|0|0|\nend_dialog||OK||\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						else {
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|backonlinelist|Show Friends``|0|0|\nadd_button|changelogs|Change logs``|0|0|\nadd_button|createguildinfo|Create Guild``|0|0|\nend_dialog||OK||\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
					}
					if (cch.find("action|respawn") == 0)
					{
						if (cch.find("action|respawn_spike") == 0) {
							playerRespawn(peer, true);
						}
						else
						{
							playerRespawn(peer, false);
						}
					}
					if (cch.find("action|growid") == 0)
					{
						player::dialogDuration(peer, 500, "set_default_color|`o\n\nadd_label_with_icon|big|`wGet a GrowID``|left|206|\n\nadd_spacer|small|\nadd_textbox|A `wGrowID `wmeans `oyou can use a name and password to logon from any device.|\nadd_spacer|small|\nadd_textbox|This `wname `owill be reserved for you and `wshown to other players`o, so choose carefully!|\nadd_text_input|username|GrowID||30|\nadd_text_input_password|password|Password||100|\nadd_text_input_password|passwordverify|Password Verify||100|\nadd_textbox|Your `wemail address `owill only be used for account verification purposes and won't be spammed or shared. If you use a fake email, you'll never be able to recover or change your password.|\nadd_text_input|email|Email||100|\nend_dialog|register|Cancel|Get My GrowID!|\n");
					}
					if (cch.find("action|store") == 0) {
						if (((PlayerInfo*)(peer->data))->haveGrowId == true) {
							packet::dialog(peer, "\nadd_label_with_icon|big|Growtopia Royal Store|left|5638|\nadd_spacer|small|\nadd_smalltext|What kind of items you would like to buy?|left|\nadd_spacer|small|\nadd_button|locks|`wPurchase `@Locks|left|\nadd_button|items|`wPurchase `@Items|left|\nadd_button|blocks|`wPurchase `@Blocks|left|\nadd_button|farma|`wPurchase `@Farmables|left|\nadd_button|consum|`wPurchase `@Consumables|left|\nadd_spacer|small|\nend_dialog||Close|\nadd_quick_exit|");
						}
					}

					if (cch.find("action|buy\nitem|itemomonth") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 199999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 199999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oDoomsday Warhammer");
							OnStorePurchaseResults(peer, "`5You just bought a Doomsday Warhammer and\n`oReceived: `o1 `2Doomsday Warhammer.");

							SaveShopsItemMoreTimes(9606, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|door_mover") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 4999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 5000;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oDoor Mover");
							OnStorePurchaseResults(peer, "`5You just bought a World lock and\n`oReceived: `o1 `2Door Mover.");

							SaveShopsItemMoreTimes(1404, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|rockin_pack") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 9999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 9999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oKeytar");
							Player::OnConsoleMessage(peer, "`5Got 1 `oBass Guitar");
							Player::OnConsoleMessage(peer, "`5Got 1 `oTambourine");
							Player::OnConsoleMessage(peer, "`5Got 1 `oStarchild Makeup");
							Player::OnConsoleMessage(peer, "`5Got 1 `oRockin' Headband");
							Player::OnConsoleMessage(peer, "`5Got 1 `oLeopard Leggings");
							Player::OnConsoleMessage(peer, "`5Got 1 `oShredded T-Shirt");
							Player::OnConsoleMessage(peer, "`5Got 1 `oDrumkit");
							Player::OnConsoleMessage(peer, "`5Got 6 Stage Support");
							Player::OnConsoleMessage(peer, "`5Got 6 Mega Rock Speaker");
							Player::OnConsoleMessage(peer, "`5Got 6 Rock N' Roll Wallpaper");
							OnStorePurchaseResults(peer, "`5You just bought a Rockin'Pack and\n`oReceived: `o1 `2Rockin'Pack .");

							SaveShopsItemMoreTimes(1714, 1, peer, success); // aposition, itemid, quantity, peer, success
							SaveShopsItemMoreTimes(1710, 1, peer, success); // aposition, itemid, quantity, peer, success
							SaveShopsItemMoreTimes(1712, 1, peer, success); // aposition, itemid, quantity, peer, success
							SaveShopsItemMoreTimes(1718, 1, peer, success); // aposition, itemid, quantity, peer, success
							SaveShopsItemMoreTimes(1732, 1, peer, success); // aposition, itemid, quantity, peer, success
							SaveShopsItemMoreTimes(1722, 1, peer, success); // aposition, itemid, quantity, peer, success
							SaveShopsItemMoreTimes(1720, 1, peer, success); // aposition, itemid, quantity, peer, success
							SaveShopsItemMoreTimes(1724, 1, peer, success); // aposition, itemid, quantity, peer, success
							SaveShopsItemMoreTimes(1728, 6, peer, success); // aposition, itemid, quantity, peer, success
							SaveShopsItemMoreTimes(1730, 6, peer, success); // aposition, itemid, quantity, peer, success
							SaveShopsItemMoreTimes(1726, 6, peer, success); // aposition, itemid, quantity, peer, success

							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|world_lock") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 1999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 1999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oWorldLock");
							OnStorePurchaseResults(peer, "`5You just bought a World lock and\n`oReceived: `o1 `2World Lock.");

							SaveShopsItemMoreTimes(242, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|ads_tv") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 49) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 49;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oGrowShow TV");
							OnStorePurchaseResults(peer, "`5You just bought a GrowShow TV and\n`oReceived: `o1 `2GrowShow TV.");

							SaveShopsItemMoreTimes(9466, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|upgrade_backpack") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 3700) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 3699;
							savejson(peer);
							bool success = true;

							Player::OnConsoleMessage(peer, "`5Got `o10 Inventory slots!");
							OnStorePurchaseResults(peer, "`5You just bought a Inventory Upgrade and\n`oReceived: `210 Inventory slots!.");
							short nextSpace = 0;

							if (((PlayerInfo*)(peer->data))->currentInventorySize + 30 > 200)
							{
								nextSpace = 200;
							}
							else
							{
								nextSpace = ((PlayerInfo*)(peer->data))->currentInventorySize + 10;
							}

							ofstream fs("usersinventorysize/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
							fs << nextSpace;
							fs.close();
							sendConsoleMsg(peer, "`2Payment Succesful! `2Successfully upgraded your inventory!");
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							enet_peer_disconnect_later(peer, 0);
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");
						}
					}
					if (cch.find("action|buy\nitem|small_lock") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 49) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 49;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oSmall Lock");
							OnStorePurchaseResults(peer, "`5You just bought a GrowShow TV and\n`oReceived: `o1 `2Small Lock.");

							SaveShopsItemMoreTimes(202, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|big_lock") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 199) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 199;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oBig Lock");
							OnStorePurchaseResults(peer, "`5You just bought a GrowShow TV and\n`oReceived: `o1 `2Big Lock.");

							SaveShopsItemMoreTimes(204, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|huge_lock") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 499) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 499;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oHuge Lock");
							OnStorePurchaseResults(peer, "`5You just bought a GrowShow TV and\n`oReceived: `o1 `2Huge Lock.");

							SaveShopsItemMoreTimes(206, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|door_pack") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 15) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 15;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oDoor");
							Player::OnConsoleMessage(peer, "`5Got 1 `oSign");
							OnStorePurchaseResults(peer, "`5You just bought a Door & Sign Hello Pack and\n`oReceived: `o1 `2Door. `oand `o1 `2Sign");

							SaveShopsItemMoreTimes(12, 1, peer, success);
							SaveShopsItemMoreTimes(20, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|nyan_hat") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 24999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 24999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oTurtle Hat");
							OnStorePurchaseResults(peer, "`5You just bought a Turtle Hat and\n`oReceived: `o1 `2Turtle Hat.");

							SaveShopsItemMoreTimes(574, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|tiny_horsie") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 24999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 24999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oTiny Horsie");
							OnStorePurchaseResults(peer, "`5You just bought a Tiny Horsie and\n`oReceived: `o1 `2Tiny Horsie.");

							SaveShopsItemMoreTimes(592, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Efnough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|diggers_spade") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 200, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oDigger´s Spade Digger´s Spade ");
							OnStorePurchaseResults(peer, "`5You just bought a Digger´s Spade and\n`oReceived: `o1 `2Digger´s Spade.");
							RemoveInventoryItem(1486, 200, peer);
							SaveShopsItemMoreTimes(2952, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|xp_potion") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 10, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oExperience Potion ");
							OnStorePurchaseResults(peer, "`5You just bought a Experience Potion and\n`oReceived: `o1 `2Experience Potion.");
							RemoveInventoryItem(1486, 10, peer);
							SaveShopsItemMoreTimes(1488, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|megaphone") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 10, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oMegaphone ");
							OnStorePurchaseResults(peer, "`5You just bought a Megaphone and\n`oReceived: `o1 `2Megaphone.");
							RemoveInventoryItem(1486, 10, peer);
							SaveShopsItemMoreTimes(2480, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|mini_mod") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 20, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oMini-Mod ");
							OnStorePurchaseResults(peer, "`5You just bought a Mini-Mod and\n`oReceived: `o1 `2Mini-Mod.");
							RemoveInventoryItem(1486, 20, peer);
							SaveShopsItemMoreTimes(4758, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|derpy_star") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 30, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oDerpy Star Block ");
							OnStorePurchaseResults(peer, "`5You just bought a Derpy Star Block and\n`oReceived: `o1 `2Derpy Star Block.");
							RemoveInventoryItem(1486, 30, peer);
							SaveShopsItemMoreTimes(1628, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|dirt_gun") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 40, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oBlYoshi's Dirtgun ");
							OnStorePurchaseResults(peer, "`5You just bought a BLYoshi's Dirtgun and\n`oReceived: `o1 `2BlYoshi's Dirtgun.");
							RemoveInventoryItem(1486, 40, peer);
							SaveShopsItemMoreTimes(2876, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|nothingness") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 50, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oWeather Machine - Nothingness. ");
							OnStorePurchaseResults(peer, "`5You just bought a Nothingness and\n`oReceived: `o1 `2Weather Machine - Nothingness.");
							RemoveInventoryItem(1486, 50, peer);
							SaveShopsItemMoreTimes(1490, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|spike_juice") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 60, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oSpike Juice ");
							OnStorePurchaseResults(peer, "`5You just bought a Spike Juice and\n`oReceived: `o1 `2Spike Juice.");
							RemoveInventoryItem(1486, 60, peer);
							SaveShopsItemMoreTimes(1662, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|doodad") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 75, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oDoodad ");
							OnStorePurchaseResults(peer, "`5You just bought a Doodad and\n`oReceived: `o1 `2Doodad.");
							RemoveInventoryItem(1486, 75, peer);
							SaveShopsItemMoreTimes(1492, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|crystal_cape") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 90, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oCrystal Cape ");
							OnStorePurchaseResults(peer, "`5You just bought a Doodad and\n`oReceived: `o1 `2Crystal Cape.");
							RemoveInventoryItem(1486, 90, peer);
							SaveShopsItemMoreTimes(1738, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|focused_eyes") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 100, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oFocused Eyes ");
							OnStorePurchaseResults(peer, "`5You just bought a Focused Eyes and\n`oReceived: `o1 `2Focused Eyes.");
							RemoveInventoryItem(1486, 100, peer);
							SaveShopsItemMoreTimes(1204, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|grip_tape") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 100, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oGrip Tape ");
							OnStorePurchaseResults(peer, "`5You just bought a Grip Tape and\n`oReceived: `o1 `2Grip Tape.");
							RemoveInventoryItem(1486, 100, peer);
							SaveShopsItemMoreTimes(3248, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|cat_eyes") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 100, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oCat Eyes ");
							OnStorePurchaseResults(peer, "`5You just bought a Cat Eyes and\n`oReceived: `o1 `2Cat Eyes.");
							RemoveInventoryItem(1486, 100, peer);
							SaveShopsItemMoreTimes(7106, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|night_vision") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 110, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oNight Vision Goggles ");
							OnStorePurchaseResults(peer, "`5You just bought a Night Vision Goggles and\n`oReceived: `o1 `2Night Vision Goggles.");
							RemoveInventoryItem(1486, 110, peer);
							SaveShopsItemMoreTimes(3576, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|piranha") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 150, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oCuddly Piranha ");
							OnStorePurchaseResults(peer, "`5You just bought a Cuddly Piranha and\n`oReceived: `o1 `2Cuddly Piranha.");
							RemoveInventoryItem(1486, 150, peer);
							SaveShopsItemMoreTimes(1534, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|muddy_pants") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 125, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oMuddy Pants ");
							OnStorePurchaseResults(peer, "`5You just bought a Muddy Pants and\n`oReceived: `o1 `2Muddy Pants.");
							RemoveInventoryItem(1486, 125, peer);
							SaveShopsItemMoreTimes(2584, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|10_wl") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 19999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 19999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 10 `oWorldLock");
							OnStorePurchaseResults(peer, "`5You just bought 10 World locks and\n`oReceived: `o10 `2World Lock.");

							SaveShopsItemMoreTimes(242, 10, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}

					if (cch.find("action|buy\nitem|star_ship") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 24999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 24999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oPleiadian Star Ship");
							OnStorePurchaseResults(peer, "`5You just bought a Pleiadian Star Ship and\n`oReceived: `o1 `2Pleiadian Star Ship.");

							SaveShopsItemMoreTimes(760, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|dragon_hand") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 49999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 49999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `4Dragon Hand");
							OnStorePurchaseResults(peer, "`5You just bought a Dragon Hand and\n`oReceived: `o1 `4Dragon Hand.");

							SaveShopsItemMoreTimes(900, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|corvette") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 24999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 24999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `2Little Red Corvette");
							OnStorePurchaseResults(peer, "`5You just bought a Little Red Corvette and\n`oReceived: `o1 `2Little Red Corvette.");

							SaveShopsItemMoreTimes(766, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|ambulance") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 24999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 24999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `2Ambulance");
							OnStorePurchaseResults(peer, "`5You just bought a Ambulance and\n`oReceived: `o1 `2Ambulance.");

							SaveShopsItemMoreTimes(1272, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|raptor") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 24999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 24999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `2Riding Raptor");
							OnStorePurchaseResults(peer, "`5You just bought a Riding Raptor and\n`oReceived: `o1 `2Riding Raptor.");

							SaveShopsItemMoreTimes(1320, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|owl") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 25999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 25999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oMid Pacific Owl");
							OnStorePurchaseResults(peer, "`5You just bought a Mid Pacific Owl and\n`oReceived: `o1 `2Mid Pacific Owl.");

							SaveShopsItemMoreTimes(1540, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|unicorn") == 0) {
						if (((PlayerInfo*)(peer->data))->gem > 49999) {
							((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 49999;
							savejson(peer);
							bool success = true;
							Player::OnConsoleMessage(peer, "`5Got 1 `oUnicorn Garland");
							OnStorePurchaseResults(peer, "`5You just bought a Unicorn Garland and\n`oReceived: `o1 `2Unicorn Garland.");

							SaveShopsItemMoreTimes(1648, 1, peer, success);
							GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet5 = enet_packet_create(p5.data,
								p5.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet5);
							delete p5.data;
							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later.");

						}
					}
					if (cch.find("action|buy\nitem|puddy_leash") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 180, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oPuddy Leash ");
							OnStorePurchaseResults(peer, "`5You just bought a Puddy Leash and\n`oReceived: `o1 `2Puddy Leash.");
							RemoveInventoryItem(1486, 180, peer);
							SaveShopsItemMoreTimes(2032, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|golden_axe") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 180, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oGolden Pickaxe ");
							OnStorePurchaseResults(peer, "`5You just bought a Golden Pickaxe and\n`oReceived: `o1 `2Golden Pickaxe.");
							RemoveInventoryItem(1486, 200, peer);
							SaveShopsItemMoreTimes(1438, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|puppy_leash") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 180, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oPuppy Leash ");
							OnStorePurchaseResults(peer, "`5You just bought a Puppy Leash and\n`oReceived: `o1 `2Puppy Leash.");
							RemoveInventoryItem(1486, 200, peer);
							SaveShopsItemMoreTimes(1742, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|meow_ears") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 200, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oMeow Ears ");
							OnStorePurchaseResults(peer, "`5You just bought Meow Ears and\n`oReceived: `o1 `2Meow Ears.");
							RemoveInventoryItem(1486, 200, peer);
							SaveShopsItemMoreTimes(698, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|frosty_hair") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 200, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oFrosty Hair ");
							OnStorePurchaseResults(peer, "`5You just bought Frosty Hair and\n`oReceived: `o1 `2Frosty Hair.");
							RemoveInventoryItem(1486, 200, peer);
							SaveShopsItemMoreTimes(1444, 1, peer, success);
						}
					}

					if (cch.find("action|buy\nitem|seils_magic_orb") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 200, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oSeils Magic Orbs ");
							OnStorePurchaseResults(peer, "`5You just bought Seils Magic Orbs and\n`oReceived: `o1 `2Seils Magic Orbs.");
							RemoveInventoryItem(1486, 200, peer);
							SaveShopsItemMoreTimes(820, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|zerkon_helmet") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 200, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oSeils Magic Orbs ");
							OnStorePurchaseResults(peer, "`5You just bought Seils Magic Orbs and\n`oReceived: `o1 `2Seils Magic Orbs.");
							RemoveInventoryItem(1486, 200, peer);
							SaveShopsItemMoreTimes(1440, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|atomic_shadow_scythe") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 200, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oAtomic Shadow Scythe ");
							OnStorePurchaseResults(peer, "`5You just bought a Atomic Shadow Scythe and\n`oReceived: `o1 `2Atomic Shadow Scythe.");
							RemoveInventoryItem(1486, 200, peer);
							SaveShopsItemMoreTimes(1484, 1, peer, success);

						}
					}
					if (cch.find("action|buy\nitem|poseidon_diggers_trident") == 0) {
						bool iscontains = false;
						SearchInventoryItem(peer, 1486, 200, iscontains);
						if (!iscontains)
						{
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Tokens To Buy This Items. `5Try again later.");

						}
						else {
							bool success = true;
							if (success)
								Player::OnConsoleMessage(peer, "`5Got 1 `oPoseidon's Digger's Trident ");
							OnStorePurchaseResults(peer, "`5You just bought a Poseidon's Digger's Trident and\n`oReceived: `o1 `2Poseidon's Digger's Trident.");
							RemoveInventoryItem(1486, 200, peer);
							SaveShopsItemMoreTimes(7434, 1, peer, success);

						}
					}
					if (cch.find("action|info") == 0)
					{
						std::stringstream ss(cch);
						std::string to;
						int id = -1;
						int count = -1;
						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 3) {
								if (infoDat[1] == "itemID") id = atoi(infoDat[2].c_str());
								if (infoDat[1] == "count") count = atoi(infoDat[2].c_str());
							}
						}

						if (id == -1 || count == -1) continue;
						if (itemDefs.size() < id || id < 0) continue;
						string properties = "";
						ItemDefinition itemDef = GetItemDef(id);
						if (itemDef.rarity != 999)
							properties += "add_textbox|`oRarity: `w" + to_string(itemDef.rarity) + "``|\n";
						properties += "add_spacer|small|\n";
						// find properties
						if (itemDef.properties & Property_Untradable)
							properties += "add_textbox|`1This item cannot be dropped or traded.``|\n";
						if (itemDef.properties & Property_Wrenchable)
							properties += "add_textbox|`1This item has special properties you can adjust with the Wrench.``|\n";
						if (itemDef.properties & Property_NoSeed)
							properties += "add_textbox|`1This item never drops any seeds.``|\n";
						if (itemDef.properties & Property_Permanent)
							properties += "add_textbox|`1This item can't be destroyed - smashing it will return it to your backpack if you have room!``|\n";
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wAbout " + itemDef.name + " (" + std::to_string(id) + ")``|left|" + std::to_string(id) + "|\n\nadd_spacer|small|\nadd_textbox|" + itemDef.description + "|left|\nadd_spacer|small\n" + properties + "\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|iteminfo||Close|"));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);

						//enet_host_flush(server);
						delete p.data;
					}
					
					/*string modTradeText = "action|mod_trade\nitemID|";
					if (cch.find(modTradeText) == 0) {
						try {
							// item id detection


							int id = -1;
							id = atoi(cch.substr(modTradeText.size()).c_str());
							if (id == -1) continue;
							PlayerInfo* pinfo = (PlayerInfo*)peer->data;
							if (!pinfo->isTrading) {
								Player::PlayAudio(peer, "audio/cant_place_tile.wav", 0);
								break;
							}

							if (pinfo->tradeItems.size() >= 4) {
								Player::PlayAudio(peer, "audio/cant_place_tile.wav", 0);
								break;
							}

							int count = 0;

							//	count = ((PlayerInfo*)(peer->data))->wls;
							packet::dialog(peer, "add_label_with_icon|big|`2Trade `w" + items.at(id).name + "``|left|" + to_string(id) + "|\nadd_textbox|`2How many to trade?``|\nadd_text_input|count||" + to_string(count) + "|3|\nend_dialog|trade_add" + to_string(id) + "|Cancel|OK|");

						}
						catch (...) {
							cout << "error in mod_trade";
						}
					}*/
					if (cch.find("action|mod_trade") == 0) {
						std::stringstream ss(cch);
						std::string to;
						int itemid = -1;
						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 2) {

								if (infoDat[0] == "itemID") itemid = atoi(infoDat[1].c_str());

							}
						}
						if (itemid == -1) continue;
						if (itemDefs.size() < itemid || itemid < 0) continue;
						if (itemid == 18 || itemid == 32)
						{
							Player::OnTextOverlay(peer, "You'd be sorry if you lost that!");
							Player::PlayAudio(peer, "audio/cant_place_tile.wav", 0);
							continue;
						}
						((PlayerInfo*)(peer->data))->lastTradeItem = itemid;
						short int currentItemCount = 0;
						for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
						{
							if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == itemid)
							{
								currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
								if (currentItemCount < 0)
								{
									currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
								}
							}
						}
						sendDialog(peer, "add_label_with_icon|big|`2Trade `w" + itemDefs.at(itemid).name + "``|left|" + std::to_string(itemid) + "|\nadd_textbox|`2How many to trade?``|\nadd_text_input|count||" + to_string(currentItemCount) + "|3|\nend_dialog|trade_add" + std::to_string(itemid) + "|Cancel|OK|");
					}
					if (cch.find("action|trade_accept") == 0) { // trading
						try {
							std::stringstream ss(cch);
							std::string to;
							int status = 0;
							while (std::getline(ss, to, '\n')) {
								vector<string> infoDat = explode("|", to);
								if (infoDat.size() == 2) {
									if (infoDat[0] == "status")
									{
										if (infoDat[1] == "1")
										{
											status = 1;
										}
									}
								}
							}
							PlayerInfo* pinfo = (PlayerInfo*)peer->data;
							if (!pinfo->isTrading) continue;

							pinfo->isAcceptingTrade = status;
							UpdateTradeAcceptedStatus(peer);
							ENetPeer* peer2 = NULL;
							PlayerInfo* pinfo2 = NULL;
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer)) {
									if (pinfo->isTradingWithUserID == ((PlayerInfo*)(currentPeer->data))->userID || ((PlayerInfo*)(peer->data))->userID == ((PlayerInfo*)(currentPeer->data))->isTradingWithUserID) {
										pinfo2 = (PlayerInfo*)currentPeer->data;
										peer2 = currentPeer;
										if (pinfo->isAcceptingTrade && pinfo2->isAcceptingTrade)
										{
											bool successful = true;

											Players::OnForceTradeEnd(peer);
											Players::OnForceTradeEnd(peer2);
											//Player::OnForceTradeEnd(peer2); TODO

											pinfo->isInFinalTradeDialog = true;
											pinfo2->isInFinalTradeDialog = true;
											pinfo->isWaitingForTradeWithUserID = 0;
											pinfo2->isWaitingForTradeWithUserID = 0;
											pinfo->isWaitingForTrade = false;
											pinfo2->isWaitingForTrade = false;
											pinfo2->isAcceptingTrade = false;
											pinfo->isAcceptingTrade = false;
											packet::dialog(peer, "add_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small\nadd_textbox|`4You'll give:|\nadd_spacer|small\n" + FormatTradeItemsForDialog(pinfo->tradeItems, 0) + "\nadd_spacer|small\nadd_textbox|`2You'll get:``|\nadd_spacer|small\n" + FormatTradeItemsForDialog(pinfo2->tradeItems, 1) + "\nadd_spacer|small|\nadd_button|dothetrade|`oDo The Trade!``|\nend_dialog|tradeconfirm|||");
											packet::dialog(peer2, "add_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small\nadd_textbox|`4You'll give:|\nadd_spacer|small\n" + FormatTradeItemsForDialog(pinfo2->tradeItems, 0) + "\nadd_spacer|small\nadd_textbox|`2You'll get:``|\nadd_spacer|small\n" + FormatTradeItemsForDialog(pinfo->tradeItems, 1) + "\nadd_spacer|small|\nadd_button|dothetrade|`oDo The Trade!``|\nend_dialog|tradeconfirm|||");
										}

										break;

									}
								}
							}
						}
						catch (...) {
							cout << "error in action|trade_accept";
						}
					}
					if (cch.find("action|dialog_return\ndialog_name| ") == 0) {
						if (world != NULL) {
							if (((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner)) {
								std::stringstream ss(GetTextPointerFromPacket(event.packet));
								std::string to;
								int x = 0;
								int y = 0;
								bool created = false;
								string text = "";
								string world = ((PlayerInfo*)(peer->data))->currentWorld;
								while (std::getline(ss, to, '\n')) {
									string id = to.substr(0, to.find("|"));
									string act = to.substr(to.find("|") + 1, to.length() - to.find("|") - 1);
									if (id == "tilex")
									{
										x = atoi(act.c_str());

									}
									else if (id == "tiley")
									{
										y = atoi(act.c_str());
									}
									else if (id == "ch3")
									{
										text = act;
										created = true;
									}
									if (created == true) {
										if (text == "__%&P&%__") {
											sendConsoleMsg(peer, ">> Can't use this!");
											continue;
										}
									}
									if (text.length() < 255) {
										WorldInfo* worldInfo = getPlyersWorld(peer);
										int squaresign = ((PlayerInfo*)(peer->data))->wrenchx + (((PlayerInfo*)(peer->data))->wrenchy * 100);
										updateSignSound(peer, worldInfo->items[squaresign].foreground, squaresign % worldInfo->width, squaresign / worldInfo->width, text, worldInfo->items[squaresign].background);
										worldInfo->items[squaresign].text = text;
									}
								}
							}
						}
					}
					if (cch.find("action|dialog_return") == 0)
					{
						std::stringstream ss(cch);
						std::string to;
						string btn = "";
						bool isRegisterDialog = false;
						bool isVendPicker = false;
						bool isDonatePicker = false;
						int magplantitem;
						bool puts = false;
						bool isFinishTrade = false;
						bool magpicker = false;
						string strBuyWorldLockOffer = "";
						bool isWorldLockBuyDialog = false;
						bool isFindDialog = false;
						bool isEntranceDialog = false;
						int vendid = 0;
						int donateid = 0;
						string entranceresult = "";
						bool Accesspicker = false;
						bool isEditDoorDialog = false;
						bool isEditPDoorDialog = false;
						bool isTrashDialog = false;
						bool isownerdialog = false;
						string trashitemcount = "";
						string dropitemcount = "";
						bool isPwdDoorDialog = false;
						string passwords = "";
						string passwordss = "";
						bool moderator = false;
						bool vip = false;
						bool isStuffDialog = false;
						bool isOptionalStuffDialog = false;
						bool istradedi1;
						string di1price;
						bool istradery1;
						string ry1price;
						bool istradeac1;
						string ac1price;
						bool istradetk1;
						string tk1price;
						bool istradeln1;
						string ln1price;
						bool isDropDialog = false;
						bool megaphone = false;
						bool donation = false;
						bool notebook = false;
						string notebooktext = "";
						string sbtext = "";
						string donate = "";
						string bantime = "";
						bool marsblast = false;
						string marstext = "";
						bool isSecurityDialog = false;
						string c0de = "";
						bool isTradeDialog = false;
						string item = "";
						bool isMailDialog = false;
						string mail = "";
						string message = "";
						bool isWarnDialog = false;
						string warntext = "";
						bool signEditor = false;
						string omgitem = "2";
						int stuffgrav = -1;
						bool isLockDialog = false;
						string pub = "";
						string playerNetId = "";
						string disable_music = "";
						string tempo = "";
						string disable_music_render = "";
						int vendprice = 0;
						bool isGuildDialog = false;
						string guildName = "";
						string guildStatement = "";
						string guildFlagBg = "";
						string guildFlagFg = "";
						string putmag = "";
						string itemFind = "";
						string username = "";
						string password = "";
						string passwordverify = "";
						string netid = "";
						string email = "";
						string discord = "";
						string stuffitem = "";
						string gravitystr = "";
						string people = "";
						bool spin = 0;
						bool invert = 0;
						string destworld = "", destid = "", label = "", currid = "";
						string strBuyOfferlevel = "";
						bool isLevelBuyDialog = false;
						bool isVendUpdate = false;
						bool isVendPurchase = false;
						bool isCnamedialog = false;
						bool isGrowscan = false;
						bool bandialog = false;
						bool mutedialog = false;
						string newname = "";
						string mutetime = "";
						string strBuyOffergems = "";
						bool isGemsBuyDialog = false;
						bool retmag = false;
						int counttodo = 0;
						int itemtodo = 0;
						string retrievemag = "";
						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 2) {
								if (infoDat[0] == "dialog_name" && infoDat[1] == "growscan_float")
									isGrowscan = true;
								if (infoDat[0] == "buttonClicked") btn = infoDat[1];
								if (infoDat[0] == "dialog_name" && infoDat[1] == "register")
								{
									isRegisterDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "reqworldlockoffer")
								{
									isWorldLockBuyDialog = true;
								}
								if (isWorldLockBuyDialog)
								{
									if (infoDat[0] == "worldlockoffer")
									{
										strBuyWorldLockOffer = infoDat[1];
										bool contains_non_int = !std::regex_match(strBuyWorldLockOffer, std::regex("^[0-9]+$"));
										if (contains_non_int == true)
										{
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Invalid `2World Lock's `@Format!"));
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
											continue;
										}
										else
										{
											if (strBuyWorldLockOffer.size() > 3 || strBuyWorldLockOffer.size() <= 0)
											{
												continue;
											}
											int konvertuotasInt = stoi(strBuyWorldLockOffer);
											if (CheckItemMaxed(peer, 242, konvertuotasInt))
											{
												Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Those world locks wont fit into my backpack!", 0, true);
												break;
											}
											if (konvertuotasInt <= 0 || konvertuotasInt >= 200)
											{
												GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9World Lock's `@Should Be Between `91-199`@!"));
												ENetPacket* packet2 = enet_packet_create(p2.data,
													p2.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet2);
												delete p2.data;
												continue;
											}
											else
											{
												PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
												if (pinfo->gem >= 1000 * konvertuotasInt)
												{
													((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 1000 * konvertuotasInt;
													GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
													ENetPacket* packet5 = enet_packet_create(p5.data,
														p5.len,
														ENET_PACKET_FLAG_RELIABLE);

													enet_peer_send(peer, 0, packet5);
													delete p5.data;
													bool success = true;
													SaveShopsItemMoreTimes(242, konvertuotasInt, peer, success); // aposition, itemid, quantity, peer, success
													if (!success)continue;
													GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`wYou bought `2" + to_string(konvertuotasInt) + " `9World Locks"));
													ENetPacket* packet2 = enet_packet_create(p2.data,
														p2.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet2);
													delete p2.data;
													sendSound(peer, "achievement.wav");
												}
												else
												{
													GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enought `9Gem's`9!"));
													ENetPacket* packet2 = enet_packet_create(p2.data,
														p2.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet2);
													delete p2.data;
												}
											}
										}
									}
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "sendwarn")
								{
									isWarnDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "retrievemagitem")
								{
									retmag = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "vendds") {
									isVendUpdate = true;
								}
								if (isTradeDialog) {

									if (infoDat[0] == "count")
									{
										counttodo = atoi(infoDat[1].c_str());
										if (counttodo == -1) continue;
									}
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "tradeconfirm") {
									isFinishTrade = true;

								}
								if (infoDat[0] == "dialog_name" && infoDat[1].find("trade_add") == 0)
								{

									itemtodo = atoi(infoDat[1].substr(9).c_str());
									if (itemtodo == -1) break;
									isTradeDialog = true;
								}
								if (isTradeDialog) {
									//((PlayerInfo*)(peer->data))->currentTradeItems += "add_slot|" + to_string(((PlayerInfo*)(peer->data))->lastTradeItem) + "|" + tradeitemcount + "locked|0\nreset_locks|1\naccepted|1\n"; // TODO TRADE
									//Player::OnTradeStatus(peer, ((PlayerInfo*)(peer->data))->lastTradeNetID, ((PlayerInfo*)(peer->data))->lastTradeName, ((PlayerInfo*)(peer->data))->currentTradeItems, "");//gPlayer::OnConsoleMessage, 0, true
									if (counttodo == -1 || itemtodo == -1) continue;
									PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
									if (!pinfo->isTrading) continue;

									if (pinfo->tradeItems.size() >= 4) continue;
									if (counttodo < 0 || itemtodo == 18 || itemtodo == 32 || itemtodo == 5480)
									{
										Player::OnTalkBubble(peer, pinfo->netID, "That would never have worked, let's be honest.", 0, true);
										continue;
									}

									bool iscontains9 = false;
									SearchInventoryItem(peer, itemtodo, counttodo, iscontains9);
									if (!iscontains9)
									{
										Player::OnTalkBubble(peer, pinfo->netID, "Trying to dupe huh? That would never have worked.", 0, true);
										continue;
									}

									if (counttodo < 1) continue;

									/*	if (itemtodo == 242 && counttodo > pinfo->wls) {
											Player::OnTextOverlay(peer, "You don't have this many locks!");
											continue;
										}*/
									int i = 0;
									for (i = 0; i < pinfo->tradeItems.size(); i++)
									{
										if (pinfo->tradeItems[i].id == itemtodo)
										{
											pinfo->tradeItems.erase(pinfo->tradeItems.begin() + i);
											continue;
										}
									}
									UpdateTradeStatus(peer, pinfo->isTradingWithUserID, true);
									TradeItem trdItem = { itemtodo, counttodo };
									pinfo->tradeItems.push_back(trdItem);
									UpdateTradeStatus(peer, pinfo->isTradingWithUserID, 1);

								}
								if (isFinishTrade) {
									try {
										PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
										if (!pinfo) continue;
										if (!pinfo->isTrading) continue;
										if (!pinfo->isInFinalTradeDialog) continue;
										ENetPeer* peer2 = NULL;
										PlayerInfo* pinfo2 = NULL;
										//if (!pinfo->isTradingWithWho) continue; TODO
										//ENetPeer* peer2 = pinfo->isTradingWithWho; TODO
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer)) {
												if (pinfo->isTradingWithUserID == ((PlayerInfo*)(currentPeer->data))->userID || ((PlayerInfo*)(peer->data))->userID == ((PlayerInfo*)(currentPeer->data))->isTradingWithUserID) {
													pinfo2 = (PlayerInfo*)currentPeer->data;
													peer2 = currentPeer;
													break;
												}
											}
										}
										if (peer2 == NULL) break;
										if (pinfo2 == NULL) break;
										if (pinfo == NULL) break;

										if (btn == "canceltrade")
										{
											SendCancelTrade(peer2, "Trade was cancelled by the other player.");
											SendCancelTrade(peer, "Trade was cancelled by the other player.");
											break;
										}

										if (btn == "dothetrade")

											pinfo->acceptedFinalDialog = true;

										if (pinfo->acceptedFinalDialog)
										{

											Player::OnTalkBubble(peer2, pinfo2->netID, "`o[`wTrade accepted by other player, waiting for you`o]``", 0, true);
										}

										if (((PlayerInfo*)(currentPeer->data))->acceptedFinalDialog == false)
										{
											((PlayerInfo*)(peer->data))->acceptedFinalDialog = true;
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "[`wTrade accepted by you, waiting for the player to accept`o]", 0, true);
											Player::OnTalkBubble(peer2, pinfo2->netID, "`o[`wTrade accepted by other player, waiting for you`o]``", 0, true);
											break;
										}

										if (!pinfo->isInFinalTradeDialog) break;
										//if (!pinfo->isTradingWithWho) continue; TODO
										// do the item switching
										int duration = 500;
										for (auto& f : pinfo->tradeItems)
										{

											// remove the item from pinfo inventory and add it to pinfo2's inventory.
											// but only do it if player has enough

											bool success = true;
											SaveShopsItemMoreTimes(f.id, f.count, peer2, success);
											RemoveInventoryItem(f.id, f.count, peer);

											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeer)) {
													Player::PlayAudio(currentPeer, "audio/change_clothes.wav", duration);
													SendTradeEffect(currentPeer, f.id, pinfo->netID, pinfo2->netID, duration);

												}
											}

											/*switch (f.id) {
											case 2952:
												//TODO TRADING RAYMAN ETC
												pinfo->hasDiggerSpade = false;
												for (int i = 0; pinfo->pitems.size(); i++) {
													if (pinfo->pitems.at(i).id == 2952) {
														pinfo->pitems.erase(pinfo->pitems.begin() + (i - 1));
													}
												}
												if (pinfo2->hasDiggerSpade == false) {
													//pinfo2->pitems.push_back()
													pinfo2->hasDiggerSpade = true;
												}
												break;
											case 242:
												pinfo->wls -= f.count;
												pinfo2->wls += f.count;
												break;
											case 1784:
												pinfo->hasLWing = false;
												pinfo2->hasLWing = true;
												break;
											case 5480:
												pinfo->hasRayman = false;
												pinfo2->hasRayman = true;
												break;
											default:
												break;
											}*/

											duration += 500;

											pinfo->isTrading = false;
											pinfo->isWaitingForTrade = false;
											pinfo->isInFinalTradeDialog = false;
											pinfo->isAcceptingTrade = false;
											pinfo->acceptedFinalDialog = false;
											pinfo->isTradingWithUserID = 0;
											pinfo2->isTradingWithUserID = 0;
											pinfo->isWaitingForTradeWithUserID = 0;
											pinfo2->isWaitingForTradeWithUserID = 0;
											pinfo2->isTrading = false;
											pinfo2->isWaitingForTrade = false;
											pinfo2->isInFinalTradeDialog = false;
											pinfo2->isAcceptingTrade = false;
											pinfo2->acceptedFinalDialog = false;
											UpdateTradeStatus(peer, pinfo->isTradingWithUserID, false);
											UpdateTradeStatus(peer, pinfo2->isTradingWithUserID, false);
										}
										for (auto& f : pinfo2->tradeItems)
										{


											/*switch (f.id) {
											case 2952:
												pinfo2->hasDiggerSpade = false;
												pinfo->hasDiggerSpade = true;
												break;
											case 242:
												pinfo2->wls -= f.count;
												pinfo->wls += f.count;
												break;
											case 1784:
												pinfo2->hasLWing = false;
												pinfo->hasLWing = true;
												break;
											case 5480:
												pinfo2->hasRayman = false;
												pinfo->hasRayman = true;
												break;
											default:
												break;
											}*/

											bool success = true;
											SaveShopsItemMoreTimes(f.id, f.count, peer, success);
											RemoveInventoryItem(f.id, f.count, peer2);

											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeer)) {
													Player::PlayAudio(currentPeer, "audio/change_clothes.wav", duration);
													SendTradeEffect(currentPeer, f.id, pinfo2->netID, pinfo->netID, duration);

												}
											}

											duration += 500;
											pinfo->isTrading = false;
											pinfo->isWaitingForTrade = false;
											pinfo->isInFinalTradeDialog = false;
											pinfo->isAcceptingTrade = false;
											pinfo->acceptedFinalDialog = false;
											pinfo->isTradingWithUserID = 0;
											pinfo2->isTradingWithUserID = 0;
											pinfo->isWaitingForTradeWithUserID = 0;
											pinfo2->isWaitingForTradeWithUserID = 0;
											pinfo2->isTrading = false;
											pinfo2->isWaitingForTrade = false;
											pinfo2->isInFinalTradeDialog = false;
											pinfo2->isAcceptingTrade = false;
											pinfo2->acceptedFinalDialog = false;
											UpdateTradeStatus(peer, pinfo->isTradingWithUserID, false);
											UpdateTradeStatus(peer, pinfo2->isTradingWithUserID, false);
										}

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer)) Player::PlayAudio(currentPeer, "audio/keypad_hit.wav", duration + 100);


										}




										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`1" + pinfo->displayName + "`1 traded " + FormatTradeItemsForMessage(pinfo->tradeItems) + " to " + pinfo2->displayName + "`1."));
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`1" + pinfo2->displayName + "`1 traded " + FormatTradeItemsForMessage(pinfo2->tradeItems) + " to " + pinfo->displayName + "`1."));
										SendGamePacketEveryoneInWorld(peer, &p);
										SendGamePacketEveryoneInWorld(peer, &p2);

										ofstream collectlog("tradelogs.txt", ios::app);
										collectlog << "`1" + pinfo->displayName + "`1 traded " + FormatTradeItemsForMessage(pinfo->tradeItems) + " to " + pinfo2->displayName + "`1." << endl;
										collectlog << "`1" + pinfo2->displayName + "`1 traded " + FormatTradeItemsForMessage(pinfo2->tradeItems) + " to " + pinfo->displayName + "`1." << endl;
										collectlog.close();


										// cancel the trade silently

										pinfo->isTrading = false;
										pinfo->isWaitingForTrade = false;
										pinfo->isInFinalTradeDialog = false;
										pinfo->isAcceptingTrade = false;
										pinfo->acceptedFinalDialog = false;
										pinfo->isTradingWithUserID = 0;
										pinfo2->isTradingWithUserID = 0;
										pinfo->isWaitingForTradeWithUserID = 0;
										pinfo2->isWaitingForTradeWithUserID = 0;
										pinfo2->isTrading = false;
										pinfo2->isWaitingForTrade = false;
										pinfo2->isInFinalTradeDialog = false;
										pinfo2->isAcceptingTrade = false;
										pinfo2->acceptedFinalDialog = false;
										Players::OnForceTradeEnd(peer);
										Players::OnForceTradeEnd(peer2);
										UpdateTradeStatus(peer, pinfo->isTradingWithUserID, false);
										UpdateTradeStatus(peer, pinfo2->isTradingWithUserID, false);


									}
									catch (...) {
										break;
									}

									// TODO
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "putmagitem")
								{
									puts = true;
								}
								if (btn == "tradebutton")
								{
									if (((PlayerInfo*)(peer->data))->dotrade == true || ((PlayerInfo*)(peer->data))->isTrading == true)
									{
										PlayerInfo* pinfo = (PlayerInfo*)peer->data;
										Players::OnForceTradeEnd(peer); // just in case
										pinfo->isTrading = false;
										pinfo->isAcceptingTrade = false;
										pinfo->isTradingWithUserID = 0;
										pinfo->isWaitingForTradeWithUserID = 0;
										pinfo->isWaitingForTrade = false;
										break;
									}

									if (((PlayerInfo*)(peer->data))->level < 2) {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You need 2 levels to do that!"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
										break;
									}

									string name = ((PlayerInfo*)(peer->data))->lastInfo;
									ENetPeer* peerToTradeWith = findPeerWithName(name);
									if (!peerToTradeWith)
									{
										Player::OnTextOverlay(peer, "That player couldn't be found.");
										break;
									}
									int a = WaitForTradeWithThisPlayer(peer, peerToTradeWith);
									if (a == -1)
									{
										Player::OnTextOverlay(peer, "That player is busy.");
									}
									if (a == -2)
									{
										Player::OnTextOverlay(peer, "You can't trade with yourself!");
									}
									if (a == -3)
									{
										Player::OnTextOverlay(peer, "This player is not in the same world as you!");
									}
								}
								if (btn == "claimdumb") { // ZEYBOBOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOXNXX.COMOOOOOOOOOOOOOOOOOOOOOOOOPORNHUB.COMOOOOOOOOOOOOOOOOOOOOXVIDEOS.COMOOOOOOOOOOOOOOXPANAS.COMOOOOOOOOOOOOOOOO
									try {
										int x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
										int y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
										if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
											continue;
										}
										string wtfs;
										if (world->items[x + (y * world->width)].magcount >= 200) {
											wtfs += "200";
										}
										else {
											wtfs += "" + to_string(world->items[x + (y * world->width)].magcount) + "";
										}
										string jumlah = std::to_string(world->items[x + (y * world->width)].magcount);
										string jenisitem = getItemDef(world->items[x + (y * world->width)].magitem).name;
										packet::dialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wRetrieve Magplant Items``|left|5638|\nadd_label|small|`oThis machine contains `6" + jumlah + " `2" + jenisitem + "|left|\nadd_label_with_icon|small|`oHow much magplant item you wanna retrieve?|left|486|\nadd_text_input|retrievemag||" + wtfs + "|7|\nend_dialog|retrievemagitem|Cancel|`wRetrieve|\n");

									}
									catch (...) {
										break;
									}
								}
								if (retmag) {
									try {
										if (infoDat[0] == "retrievemag")
										{
											retrievemag = infoDat[1];
											PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
											int x = pinfo->wrenchedBlockLocation % world->width;
											int y = pinfo->wrenchedBlockLocation / world->width;
											int konvertuotasInt = stoi(retrievemag);
											if (konvertuotasInt <= 0 || konvertuotasInt > 200)
											{
												SendTalkSelf(peer, "`wBro, i think thats too much...");
												continue;
											}

											if (CheckItemMaxed(peer, world->items[x + (y * world->width)].magitem, stoi(retrievemag)))
											{
												SendTalkSelf(peer, "`1(Item maxed)");
												break;
											}
											if (CheckItemExists(peer, world->items[x + (y * world->width)].magitem) == false)
											{
												if (((PlayerInfo*)(peer->data))->inventory.items.size() == ((PlayerInfo*)(peer->data))->currentInventorySize) {
													SendTalkSelf(peer, "`4(Inventory full)");
													break;
												}
											}
											if (world->items[x + (y * world->width)].magcount >= stoi(retrievemag)) {

												string jenisitem = getItemDef(world->items[x + (y * world->width)].magitem).name;
												bool success = false;
												SaveShopsItemMoreTimes(world->items[x + (y * world->width)].magitem, stoi(retrievemag), peer, success);
												SendTalkSelf(peer, "`wRetrieved `2" + retrievemag + " `w" + jenisitem + " from the machine");
												world->items[x + (y * world->width)].magcount = world->items[x + (y * world->width)].magcount - stoi(retrievemag);
											}
											else {
												SendTalkSelf(peer, "`wMagplant doesnt have enought that much...");

											}

										}
									}
									catch (...) {
										break;
									}
								}
								if (puts) {
									try {
										if (infoDat[0] == "putmag")
										{
											PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
											int x = pinfo->wrenchedBlockLocation % world->width;
											int y = pinfo->wrenchedBlockLocation / world->width;
											string jenisitem = getItemDef(world->items[x + (y * world->width)].magitem).name;
											putmag = infoDat[1];
											bool iscontains9 = false;
											SearchInventoryItem(peer, world->items[x + (y * world->width)].magitem, stoi(putmag), iscontains9);
											if (!iscontains9)
											{
												SendTalkSelf(peer, "`wBro, you don't have that much.");
												continue;
											}
											else {
												SendTalkSelf(peer, "`wYou added `2" + putmag + " `w" + jenisitem + " to the machine.");
												RemoveInventoryItem(world->items[x + (y * world->width)].magitem, stoi(putmag), peer);
												world->items[x + (y * world->width)].magcount += stoi(putmag);
											}
										}
									}
									catch (std::invalid_argument& e) {
										break;
									}
									catch (const std::out_of_range& e) {
										break;
									}
									catch (...) {
										break;
									}
								}
								if (isGrowscan && btn.substr(0, 4) == "item") {

									int Id = atoi(btn.substr(4, btn.length() - 4).c_str());
									int intid = atoi(btn.substr(4, btn.length() - 4).c_str());
									string ide = btn.substr(4, btn.length() - 4).c_str();
									sendArrow(peer, Id, true);

								}
								//agoy
								if (infoDat[0] == "dialog_name" && infoDat[1] == "sendsb")
								{
									megaphone = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "senddonate")
								{
									donation = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "savenotebook")
								{
									notebook = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "banplayer")
								{
									bandialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "muteplayer")
								{
									mutedialog = true;
								}
								if (infoDat[0] == "venditem")
								{
									isVendPicker = true;
								}
								if (infoDat[0] == "donateitem")
								{
									isDonatePicker = true;
								}
								if (infoDat[0] == "magplantitem")
								{
									magpicker = true;
								}
								if (isVendPicker) {
									// VULNERABLE
									PlayerInfo* pinfo = (PlayerInfo*)peer->data;
									int netID = pinfo->netID;
									if (((PlayerInfo*)(peer->data))->currentWorld != "EXIT") {
										int donationid1 = -1;
										int jumlahitem = 1;

										if (infoDat[0] == "venditem") vendid = atoi(infoDat[1].c_str());

										string itename = getItemDef(vendid).name;
										string sids = std::to_string(vendid);
										WorldInfo* world = getPlyersWorld(peer);
										ItemDefinition itemDef = getItemDef(vendid);
										int x = pinfo->wrenchedBlockLocation % world->width;
										int y = pinfo->wrenchedBlockLocation / world->width;
										bool iscontains = false;
										SearchInventoryItem(peer, vendid, 1, iscontains);
										if (!iscontains)
										{
											enet_peer_disconnect(peer, 0);
											break;
											continue;
										}
										else if (vendid == 5640 || vendid == 1785 || vendid == 9759 || vendid == 18 || vendid == 32 || vendid == 112 || vendid == 242 || vendid == 1796 || vendid == 7188) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(((PlayerInfo*)(peer->data))->netID);
											p.Insert("`wThat won't really work, trust me.");
											p.Insert(0);
											p.CreatePacket(peer);
											break;
											continue;
										}
										else {
											int fg = world->items[pinfo->wrenchedBlockLocation].foreground;
											world->items[pinfo->wrenchedBlockLocation].intdata = vendid;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeer)) {

													UpdateVend(currentPeer, x, y, vendid, false, 0);
													RemoveInventoryItem(vendid, 1, peer);
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(((PlayerInfo*)(peer->data))->netID);
													p.Insert("`7[`w" + pinfo->displayName + " `wput `2" + itename + "`w in the Vending Machine.`7]");
													p.Insert(0);
													p.CreatePacket(currentPeer);
													break;
													continue;
												}
											}



											string initial = "set_default_color|`o\n\nadd_label_with_icon|big|`wVending Machine``|left|2978|\nadd_spacer|small|\nadd_label_with_icon|small|`oThe machine contains 1 `2" + itename + "|left|" + sids + "|\nadd_spacer|small|\nadd_label|small|Not currently for sale|\nadd_button|emptyvending123|Empty the machine|\nadd_smalltext|`5(Vending Machine will not function when price is set to 0)|\nadd_text_input|addprice|Price ||6||\nadd_quick_exit|\nadd_button|peritem|Set to Items Per World Locks|\nend_dialog|vendds|Close|Update|";
											gamepacket_t p(300, netID);
											p.Insert("OnDialogRequest");
											p.Insert(initial);
										}
									}
								}
								if (isDonatePicker) {
									// VULNERABLE
									PlayerInfo* pinfo = (PlayerInfo*)peer->data;
									int netID = pinfo->netID;
									if (((PlayerInfo*)(peer->data))->currentWorld != "EXIT") {

										if (infoDat[0] == "donateitem") donateid = atoi(infoDat[1].c_str());
										
										string itename = getItemDef(donateid).name;
										string sids = std::to_string(donateid);
										WorldInfo* world = getPlyersWorld(peer);
										ItemDefinition itemDef = getItemDef(donateid);
										int x = pinfo->wrenchedBlockLocation % world->width;
										int y = pinfo->wrenchedBlockLocation / world->width;
										if (donateid == world->items[x + (y * world->width)].donate1 && world->items[x + (y * world->width)].donate2 && world->items[x + (y * world->width)].donate3 && world->items[x + (y * world->width)].donate4 && world->items[x + (y * world->width)].donate5 && world->items[x + (y * world->width)].donate6 && world->items[x + (y * world->width)].donate7 && world->items[x + (y * world->width)].donate8 && world->items[x + (y * world->width)].donate9 && world->items[x + (y * world->width)].donate10) {
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wThe donation box already `4contains `wthis item!", 0, true);
											continue;
											break;
										}
										if (world->items[x + (y * world->width)].counts1 == 10) {
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Donation box is `5full`w!", 0, true);
											continue;
											break;
										}
										else if (getItemDef(donateid).rarity <= 2)
										{
											SendTalkSelf(peer, "`wThe minimum rarity is `53`w and above!");
											continue;
											break;
										}
										pinfo->lastdonateitem = donateid;
										short int currentItemCount = 0;
										for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
										{
											if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == pinfo->lastdonateitem)
											{
												currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
												if (currentItemCount < 0)
												{
													currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
												}
											}
										}
										packet::dialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|" + itename + "|left|" + sids + "|\nadd_label|small|`oHow many to put on donation box as a gift? (Note : You will `4LOSE `othe items you will give!)|left|\nadd_text_input|donate|Count:|" + to_string(currentItemCount) + "|7|\nend_dialog|senddonate|Cancel|`4Give the item(s)|left|");
										
									}
								}
								if (isVendUpdate) {
									try {
										PlayerInfo* pinfo = (PlayerInfo*)peer->data;

										if (infoDat[0] == "addprice") vendprice = atoi(infoDat[1].c_str());

										int	avendid = world->items[pinfo->wrenchedBlockLocation].intdata;
										int netID = pinfo->netID;
										string itename = getItemDef(avendid).name;
										string sids = std::to_string(avendid);
										WorldInfo* world = getPlyersWorld(peer);

										int x = pinfo->wrenchedBlockLocation % world->width;
										int y = pinfo->wrenchedBlockLocation / world->width;

										int fg = world->items[pinfo->wrenchedBlockLocation].foreground;




										if (btn == "emptyvending123") { // ZEYBOBOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOXNXX.COMOOOOOOOOOOOOOOOOOOOOOOOOPORNHUB.COMOOOOOOOOOOOOOOOOOOOOXVIDEOS.COMOOOOOOOOOOOOOOXPANAS.COMOOOOOOOOOOOOOOOO

											ENetPeer* currentPeer;
											for (currentPeer = server->peers;

												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeer))
												{
													UpdateVend(currentPeer, x, y, 0, false, 0);
													bool success = false;
													SaveShopsItemMoreTimes(world->items[pinfo->wrenchedBlockLocation].intdata, 1, peer, success);
													world->items[pinfo->wrenchedBlockLocation].intdata = 0;
													world->items[pinfo->wrenchedBlockLocation].sold = false;
													SendParticleEffect(currentPeer, 44, x * 32, y * 32);
													continue;
													break;
												}
											}

										}

										bool testint = false;
										string pricez = std::to_string(vendprice);
										if (pricez.find_first_not_of("0123456789") != string::npos) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(((PlayerInfo*)(peer->data))->netID);
											p.Insert("That won't really work, lets be honest!");
											p.Insert(0);
											p.CreatePacket(peer);
											break;
										}
										else {
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;

												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeer))
												{
													UpdateVend(currentPeer, x, y, avendid, false, vendprice);
													testint = true;
													world->items[pinfo->wrenchedBlockLocation].price = vendprice;
													SendParticleEffect(currentPeer, 44, x * 32, y * 32);
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(((PlayerInfo*)(peer->data))->netID);
													p.Insert("`7[`w" + pinfo->displayName + " `wchanged the price of `2" + itename + "`w to `5" + std::to_string(vendprice) + " World Locks each.`7]");
													p.Insert(0);
													p.CreatePacket(peer);
												}
											}
										}
										world->items[pinfo->wrenchedBlockLocation].sold = false;
										if (testint == true) {
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`7[`o" + pinfo->displayName + " `ochanged the price of `2" + itename + "`w to `5" + std::to_string(vendprice) + " World Locks each.`7]");
											p.CreatePacket(peer);
										}
									}
									catch (...) {
										break;
									}
								}
								if (isVendPurchase) {
									try {
										PlayerInfo* pinfo = (PlayerInfo*)peer->data;
										int intvend = world->items[pinfo->wrenchedBlockLocation].intdata;
										int buyamount = 0;
										if (infoDat[0] == "buymanyhow") buyamount = atoi(infoDat[1].c_str());
										int netID = pinfo->netID;
										string itename = getItemDef(intvend).name;
										string sids = std::to_string(intvend);
										WorldInfo* world = getPlyersWorld(peer);

										int x = pinfo->wrenchedBlockLocation % world->width;
										int y = pinfo->wrenchedBlockLocation / world->width;
										int price = world->items[pinfo->wrenchedBlockLocation].price;

										int fg = world->items[pinfo->wrenchedBlockLocation].foreground;

										pinfo->lastvendprice = price;
										pinfo->lastvenditem = intvend;
										string initial = "set_default_color|`o\n\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nadd_label|small|`4You'll give:|\nadd_spacer|small|\nadd_label_with_icon|small|`o(`w" + std::to_string(price) + "`o)`8 World Locks|r|242|\nadd_spacer|small|\nadd_label|small|`2You'll get:|\nadd_spacer|small|\nadd_label_with_icon|small|`o(`w1`o)`2 " + itename + "|r|" + sids + "|\nadd_spacer|small|\nadd_label|small|Are you sure you want to make this purchase?|\nend_dialog|vendConfirm|Cancel|OK|";
										packet::dialog(peer, initial);
									}
									catch (exception& o) {
										cout << o.what();
										std::fstream logs("crashLogs.txt", std::ios::in | std::ios::out | std::ios::ate);
										logs << o.what() << endl;
										logs.close();
										cout << "error" << endl;
										break;
									}

								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "editsign")
									signEditor = true;
								if (signEditor) {
									if (infoDat[0] == "signtext") message = infoDat[1];
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "sendmb")
								{
									if (isCnamedialog) {
										if (infoDat[0] == "newname") newname = infoDat[1];

									}
									marsblast = true;
								}
								if (infoDat[0] == "stuffitem")
								{
									isStuffDialog = true;

								}
								

								if (infoDat[0] == "magplant1" && infoDat[1] == "0")
								{
									try {
										if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 2 || ((PlayerInfo*)(peer->data))->rawName == "zeyrox") {
											int x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
											int y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
											if (world->items[x + (y * world->width)].magcollect == true) {
												world->items[x + (y * world->width)].magcollect = false;
											}

										}
									}
									catch (...) {
										break;
									}
								}
								if (infoDat[0] == "magplant1" && infoDat[1] == "1")
								{
									try {
										if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 2 || ((PlayerInfo*)(peer->data))->rawName == "zeyrox") {
											int x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
											int y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
											if (world->items[x + (y * world->width)].magcollect == false) {
												world->items[x + (y * world->width)].magcollect = true;
											}

										}
									}
									catch (...) {
										break;
									}
								}
								if (infoDat[0] == "gemplant" && infoDat[1] == "0")
								{
									try {
										if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 2 || ((PlayerInfo*)(peer->data))->rawName == "zeyrox") {
											if (world->maggemc == true) {
												world->maggemc = false;
											}

										}
									}
									catch (...) {
										break;
									}
								}
								if (infoDat[0] == "gemplant" && infoDat[1] == "1")
								{
									try {
										if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 2 || ((PlayerInfo*)(peer->data))->rawName == "zeyrox") {
											if (world->maggemc == false) {
												world->maggemc = true;
											}

										}
									}
									catch (...) {
										break;
									}
								}
								if (infoDat[0] == "entrancepublic" && infoDat[1] == "1")
								{
									try {
										if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 2 || ((PlayerInfo*)(peer->data))->rawName == "zeyrox") {
											int x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
											int y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
											int fg = world->items[x + (y * world->width)].foreground;
											int bg = world->items[x + (y * world->width)].background;
											if (world->items[x + (y * world->width)].isopen == false) {
												world->items[x + (y * world->width)].isopen = true;
												if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 20 || ((PlayerInfo*)(peer->data))->rawName == "zeyrox") {
													visual::updateEntrance(peer, fg, x, y, true, bg);
												}
												else {
													visual::updateEntrance(peer, fg, x, y, true, bg);
												}
											}
										}
									}
									catch (...) {
										break;
									}
								}
								if (infoDat[0] == "entrancepublic" && infoDat[1] == "0")
								{
									try {
										if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 2 || ((PlayerInfo*)(peer->data))->rawName == "zeyrox") {
											int x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
											int y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
											int fg = world->items[x + (y * world->width)].foreground;
											int bg = world->items[x + (y * world->width)].background;
											if (world->items[x + (y * world->width)].isopen == true) {
												world->items[x + (y * world->width)].isopen = false;
												if (((PlayerInfo*)(peer->data))->rawName != world->owner || ((PlayerInfo*)(peer->data))->adminLevel != 20 || ((PlayerInfo*)(peer->data))->rawName != "zeyrox") {
													visual::updateEntrance(peer, fg, x, y, false, bg);
												}
												else {
													visual::updateEntrance(peer, fg, x, y, true, bg);
												}
											}
										}
									}
									catch (...) {
										break;
									}
								}
								if (infoDat[0] == "tae1" && infoDat[1] == "1")
								{
									try {
										if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 20 || ((PlayerInfo*)(peer->data))->rawName == "baskerville") {
											if (world->gscanpublic == false) {
												world->gscanpublic = true;
											}
										}
									}
									catch (...) {
										break;
									}
								}
								if (infoDat[0] == "tae1" && infoDat[1] == "0")
								{
									try {
										if (((PlayerInfo*)(peer->data))->rawName == world->owner || ((PlayerInfo*)(peer->data))->adminLevel == 20 || ((PlayerInfo*)(peer->data))->rawName == "baskerville") {
											if (world->gscanpublic == true) {
												world->gscanpublic = false;
											}

										}
									}
									catch (...) {
										break;
									}
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "stuff")
								{
									isOptionalStuffDialog = true;
								}
								if (signEditor) {
									PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
									WorldInfo* world = getPlyersWorld(peer);
									int x = pinfo->wrenchedBlockLocation % world->width;
									int y = pinfo->wrenchedBlockLocation / world->width;
									if (world->items[x + (y * world->width)].foreground == 1420 || world->items[x + (y * world->width)].foreground == 10078 || world->items[x + (y * world->width)].foreground == 10076 || world->items[x + (y * world->width)].foreground == 10074 || world->items[x + (y * world->width)].foreground == 10072 || world->items[x + (y * world->width)].foreground == 6214) {
										updateMannequin(peer, world->items[x + (y * world->width)].foreground, x, y, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].signn,
											world->items[x + (y * world->width)].clothHair, world->items[x + (y * world->width)].clothHead,
											world->items[x + (y * world->width)].clothMask, world->items[x + (y * world->width)].clothHand, world->items[x + (y * world->width)].clothNeck,
											world->items[x + (y * world->width)].clothShirt, world->items[x + (y * world->width)].clothPants, world->items[x + (y * world->width)].clothFeet,
											world->items[x + (y * world->width)].clothBack, true, 0);

										PlayerInfo* pinfo = (PlayerInfo*)(peer->data);
										WorldInfo* world = getPlyersWorld(peer);

										world->items[pinfo->wrenchedBlockLocation].sign = message;

										UpdateMessageVisuals(peer,
											world->items[pinfo->wrenchedBlockLocation].foreground,
											x,
											y,
											message,
											world->items[pinfo->wrenchedBlockLocation].background);
									}
									else {
										world->items[pinfo->wrenchedBlockLocation].sign = message;

										UpdateMessageVisuals(peer,
											world->items[pinfo->wrenchedBlockLocation].foreground,
											x,
											y,
											message,
											world->items[pinfo->wrenchedBlockLocation].background);
									}
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "trashdialog")
								{
									isTrashDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "dropdialog")
								{
									isDropDialog = true;
								}
								if (isDropDialog) {
									if (infoDat[0] == "dropitemcount") dropitemcount = infoDat[1];

								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "lock_edit") {
									isLockDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "moderator")
								{
									moderator = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "vip")
								{
									vip = true;
								}
								if (magpicker) {

									PlayerInfo* pinfo = (PlayerInfo*)peer->data;
									int netID = pinfo->netID;
									int x = pinfo->wrenchedBlockLocation % world->width;
									int y = pinfo->wrenchedBlockLocation / world->width;
									if (((PlayerInfo*)(peer->data))->currentWorld != "EXIT") {
										if (infoDat[0] == "magplantitem") magplantitem = atoi(infoDat[1].c_str());
										int x = pinfo->wrenchedBlockLocation % world->width;
										int y = pinfo->wrenchedBlockLocation / world->width;
										bool iscontains = false;
										SearchInventoryItem(peer, magplantitem, 1, iscontains);
										if (!iscontains)
										{
											enet_peer_disconnect(peer, 0);
											break;
											continue;
										}
										else if (magplantitem == 5640 || magplantitem == 1785 || magplantitem == 9759 || magplantitem == 18 || magplantitem == 32 || magplantitem == 112 || magplantitem == 242 || magplantitem == 1796 || magplantitem == 7188) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(((PlayerInfo*)(peer->data))->netID);
											p.Insert("`wThat won't really work, trust me.");
											p.Insert(0);
											p.CreatePacket(peer);
											break;
											continue;
										}
										/*else if (magplantitem == NULL) { // NO LEGIT
											autoBan(peer, true, 24, "NULL ITEM");
											break;
											continue;
										}*/
										world->items[x + (y * world->width)].magitem = magplantitem;
										world->items[x + (y * world->width)].magcount == 0;
										world->items[x + (y * world->width)].magX == pinfo->wrenchedBlockLocation % world->width;
										world->items[x + (y * world->width)].magY == pinfo->wrenchedBlockLocation / world->width;
										string jenisitem = getItemDef(world->items[x + (y * world->width)].magitem).name;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer)) {
												int pp = world->items[x + (y * world->width)].magitem;
												world->items[x + (y * world->width)].magcollect = true;
												sendMag(currentPeer, x, y, pp, 1, world->items[x + (y * world->width)].magitem, world->items[x + (y * world->width)].magitem);
												player::consolemessage(currentPeer, "`o[`wOwner has changed magplant collection to `2" + jenisitem + "`o] ");
												if (pinfo->wrenchedMagLocation != x + (y * world->width)) {
													gamepacket_t p3, p5;
													p5.Insert("OnPlanterActivated");
													p5.Insert("0");
													p5.CreatePacket(peer);
													p3.Insert("OnPlanterActivated");
													p3.Insert(world->items[x + (y * world->width)].magitem);
													p3.CreatePacket(peer);
												}
											}
										}
									}
								}
								if (infoDat[0] == "allowNoclip" && infoDat[1] == "1")
								{
									if (((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1336) {

										bool casin = world->isCasino;
										if (world->isCasino == false) {
											world->isCasino = true;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeer))
												{
													sendConsoleMsg(currentPeer, "World owner has been `4DISABLED `ono clipping in this world`o!");
													if (((PlayerInfo*)(currentPeer->data))->rawName == world->owner || ((PlayerInfo*)(currentPeer->data))->adminLevel > 1119)
													{

													}
													else
													{
														((PlayerInfo*)(currentPeer->data))->isGhost = false;
														sendState(currentPeer);
													}


												}
											}
										}



									}

								}

								if (infoDat[0] == "allowNoclip" && infoDat[1] == "0")
								{
									if (((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1336) {


										bool casin = std::experimental::filesystem::exists("casino/" + world->name + ".txt");
										if (world->isCasino = true) {
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeer))
												{
													sendConsoleMsg(currentPeer, "World owner has been `2ENABLED `ono clipping in this world`o!");

												}
											}
											world->isCasino = false;

										}

									}
								}
								if (infoDat[0] == "isWorldPublic" && infoDat[1] == "1")
								{
									if (((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1336) {


										if (getPlyersWorld(peer)->isPublic == false)
										{
											getPlyersWorld(peer)->isPublic = true;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeer))
												{
													sendConsoleMsg(currentPeer, "World owner has been set the world `2PUBLIC");
												}
											}

										}
									}

								}
								if (infoDat[0] == "isWorldPublic" && infoDat[1] == "0")
								{
									if (((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1336) {


										if (getPlyersWorld(peer)->isPublic == true)
										{
											getPlyersWorld(peer)->isPublic = false;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeer))
												{
													sendConsoleMsg(currentPeer, "World owner has been set the world `4PRIVATE");
												}
											}
										}

									}
								}
								if (infoDat[0] == "enablemag" && infoDat[1] == "1")
								{
									if (((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner) || ((PlayerInfo*)(peer->data))->adminLevel > 1336) {
										getPlyersWorld(peer)->magplant = true;
										PlayerInfo* pinfo = (PlayerInfo*)peer->data;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												sendConsoleMsg(currentPeer, "`oWorld owner has turned `2on `othe magplant!");
											}
										}
									}

								}
								if (infoDat[0] == "enablemag" && infoDat[1] == "0")
								{
									PlayerInfo* pinfo = (PlayerInfo*)peer->data;
									int squaresign = ((PlayerInfo*)(peer->data))->wrenchx + (((PlayerInfo*)(peer->data))->wrenchy * 100);
									getPlyersWorld(peer)->magplant = false;

									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											sendConsoleMsg(currentPeer, "`oWorld owner has turned `4off `othe magplant!");
										}
									}
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "guildconfirm") isGuildDialog = true;
								if (isRegisterDialog) {
									if (infoDat[0] == "username") username = infoDat[1];
									if (infoDat[0] == "password") password = infoDat[1];
									if (infoDat[0] == "passwordverify") passwordverify = infoDat[1];
									if (infoDat[0] == "email") email = infoDat[1];
									if (infoDat[0] == "discord") discord = infoDat[1];
								}
								if (isTrashDialog) {
									if (infoDat[0] == "trashitemcount") trashitemcount = infoDat[1];

								}
								if (isStuffDialog) {
									// VULNERABLE
									if (((PlayerInfo*)(peer->data))->currentWorld != "EXIT") {
										int stuffitemi = -1;
										int gravity = 100;

										int x = ((PlayerInfo*)(peer->data))->lastPunchX;
										int y = ((PlayerInfo*)(peer->data))->lastPunchY;

										if (infoDat[0] == "stuffitem") stuffitem = infoDat[1];
										if (infoDat[0] == "gravity") gravitystr = infoDat[1];
										if (has_only_digits(stuffitem)) stuffitemi = atoi(stuffitem.c_str());
										if (has_only_digits_wnegative(gravitystr)) gravity = atoi(gravitystr.c_str());

										if (gravity > -1000 && gravity < 1000 && stuffitemi > -1 && stuffitemi < 9142) {
											world->items[x + (y * world->width)].displayBlock = stuffitemi;
											world->items[x + (y * world->width)].gravity = gravity;
										}

										// updateStuffWeather(peer, x, y, stuffitemi, world->items[x + (y * world->width)].background, gravity, false, false);
										updateStuffWeather(peer, x, y, stuffitemi, 14, gravity, false, false);
										getPlyersWorld(peer)->weather = 29;
									}

								}
								if (isGuildDialog) {
									if (infoDat[0] == "gname") guildName = infoDat[1];
									if (infoDat[0] == "gstatement") guildStatement = infoDat[1];
									if (infoDat[0] == "ggcflagbg") guildFlagBg = infoDat[1];
									if (infoDat[0] == "ggcflagfg") guildFlagFg = infoDat[1];
								}
								if (isDropDialog) {
									int x;

									try {
										x = stoi(dropitemcount);
									}
									catch (std::invalid_argument& e) {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 Please enter how many u want to drop"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
									}
									if (x < 0) {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 That too less to drop"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
									}
									if (x > 200) {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 That too many to drop."));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
									}
									short int currentItemCount = 0;
									for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
									{
										if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastdropitem)
										{
											currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										}
									}
									if (x <= 0 || x > currentItemCount) {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oYou cant dupe them."));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
									}
									else {

										int xx = ((PlayerInfo*)(peer->data))->x + (32 * (((PlayerInfo*)(peer->data))->isRotatedLeft ? -1 : 1));
										int netid = -1;
										int yy = ((PlayerInfo*)(peer->data))->y;
										DropItem(peer, netid, xx, yy, ((PlayerInfo*)(peer->data))->lastdropitem, x, 0);
										RemoveInventoryItem(((PlayerInfo*)(peer->data))->lastdropitem, x, peer);
										//	DropItem(peer, -1, ((PlayerInfo*)(peer->data))->x + (32 * (((PlayerInfo*)(peer->data))->isRotatedLeft ? -1 : 1)), ((PlayerInfo*)(peer->data))->y, ((PlayerInfo*)(peer->data))->lastdropitem, x, 0);

									}
								}

								if (isTrashDialog) {
									int x;

									try {
										x = stoi(trashitemcount);
									}
									catch (std::invalid_argument& e) {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oItem `2Trashed"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
									}
									short int currentItemCount = 0;
									for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
									{
										if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lasttrashitem)
										{
											currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
										}
									}

									if (x <= 0 || x > currentItemCount) {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oThat too many or too less to `4trash`^!"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
									}
									if (((PlayerInfo*)(peer->data))->lasttrashitem == 9488 || ((PlayerInfo*)(peer->data))->lasttrashitem == 9490 || ((PlayerInfo*)(peer->data))->lasttrashitem == 9492 || ((PlayerInfo*)(peer->data))->lasttrashitem == 9494 || ((PlayerInfo*)(peer->data))->lasttrashitem == 9496 || ((PlayerInfo*)(peer->data))->lasttrashitem == 9499 || ((PlayerInfo*)(peer->data))->lasttrashitem == 18 || ((PlayerInfo*)(peer->data))->lasttrashitem == 32) {
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oYou can't trash this item!"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;

									}
									else {
										//	sendDrop(peer, -1, ((PlayerInfo*)(peer->data))->x + (32 * (((PlayerInfo*)(peer->data))->isRotatedLeft ? -1 : 1)), ((PlayerInfo*)(peer->data))->y, ((PlayerInfo*)(peer->data))->lastdropitem, x, 0);
										RemoveInventoryItem(((PlayerInfo*)(peer->data))->lasttrashitem, x, peer);
										sendSound(peer, "trash.wav");
									}
								}
								if (isCnamedialog) {

									if (newname.find(".") != string::npos || newname.find(",") != string::npos || newname.find("@") != string::npos || newname.find("[") != string::npos || newname.find("]") != string::npos || newname.find("#") != string::npos || newname.find("<") != string::npos || newname.find(">") != string::npos || newname.find(":") != string::npos || newname.find("{") != string::npos || newname.find("}") != string::npos || newname.find("|") != string::npos || newname.find("+") != string::npos || newname.find("_") != string::npos || newname.find("~") != string::npos || newname.find("-") != string::npos || newname.find("!") != string::npos || newname.find("$") != string::npos || newname.find("%") != string::npos || newname.find("^") != string::npos || newname.find("&") != string::npos || newname.find("`") != string::npos || newname.find("*") != string::npos || newname.find("(") != string::npos || newname.find(")") != string::npos || newname.find("=") != string::npos || newname.find("'") != string::npos || newname.find(";") != string::npos || newname.find(" ") != string::npos || newname.find("oflegend") != string::npos || newname.find("/") != string::npos) {

										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wChange your GrowID|left|1280|\nadd_label|small|`4Dont use bad name!``|left|4|\nadd_label|small|`oThis will change your GrowID `4permanently`o.``|left|4|\nadd_label|small|`oYou will pay `220,000 $ `oif you click on `5Change it`o.``|left|4|\nadd_textbox|`oEnter your new name: |\nadd_text_input|newname|||20|\nend_dialog|cnamedialog|Cancel|Change it!|\n"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);

										//enet_host_flush(server);
										delete p.data;
										continue;
									}
									string name = newname;
									if (name == "CON" || name == "PRN" || name == "AUX" || name == "NUL" || name == "COM1" || name == "COM2" || name == "COM3" || name == "COM4" || name == "COM5" || name == "COM6" || name == "COM7" || name == "COM8" || name == "COM9" || name == "LPT1" || name == "LPT2" || name == "LPT3" || name == "LPT4" || name == "LPT5" || name == "LPT6" || name == "LPT7" || name == "LPT8" || name == "LPT9" || name == "con" || name == "prn" || name == "aux" || name == "nul" || name == "com1" || name == "com2" || name == "com3" || name == "com4" || name == "com5" || name == "com6" || name == "com7" || name == "com8" || name == "com9" || name == "lpt1" || name == "lpt2" || name == "lpt3" || name == "lpt4" || name == "lpt5" || name == "lpt6" || name == "lpt7" || name == "lpt8" || name == "lpt9") {

										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wChange your GrowID|left|1280|\nadd_label|small|`4Dont use bad name!``|left|4|\nadd_label|small|`oThis will change your GrowID `4permanently`o.``|left|4|\nadd_label|small|`oYou will pay `220,000 $ `oif you click on `5Change it`o.``|left|4|\nadd_textbox|`oEnter your new name: |\nadd_text_input|newname|||20|\nend_dialog|cnamedialog|Cancel|Change it!|\n"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);

										//enet_host_flush(server);
										delete p.data;
										continue;
									}
									if (newname.length() < 2) {

										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wChange your GrowID|left|1280|\nadd_label|small|`4Minimum is `23 letter atleast!``|left|4|\nadd_label|small|`oThis will change your GrowID `4permanently`o.``|left|4|\nadd_label|small|`oYou will pay `220,000 $ `oif you click on `5Change it`o.``|left|4|\nadd_textbox|`oEnter your new name: |\nadd_text_input|newname|||20|\nend_dialog|cnamedialog|Cancel|Change it!|\n"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);

										//enet_host_flush(server);
										delete p.data;
										continue;

									}

									std::ifstream ifs("players/" + newname + ".json");
									if (ifs.is_open()) {
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wChange your GrowID|left|1280|\nadd_label|small|`4I know `othis GrowID name is nice but `2" + newname + " `4is already in use!`o.``|left|4|\nadd_label|small|`oThis will change your GrowID `4permanently`o.``|left|4|\nadd_label|small|`oYou will pay `220,000 $ `oif you click on `5Change it`o.``|left|4|\nadd_textbox|`oEnter your new name: |\nadd_text_input|newname|||20|\nend_dialog|cnamedialog|Cancel|Change it!|\n"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);

										//enet_host_flush(server);
										delete p.data;
										continue;
									}
									else
									{
										std::ifstream ifsz("players/gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
										std::string content((std::istreambuf_iterator<char>(ifsz)),
											(std::istreambuf_iterator<char>()));

										int b = atoi(content.c_str());

										if (b > 19999)
										{

											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`2Succesfully purchased `wchanged your name."));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`2Succesfully purchased `wchanged your name."));
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;

											int gemcalc10k = b - 20000;


											ofstream myfile2;
											myfile2.open("players/gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
											myfile2 << std::to_string(gemcalc10k);
											myfile2.close();

											std::ifstream ifszi("players/gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
											std::string contentx((std::istreambuf_iterator<char>(ifszi)),
												(std::istreambuf_iterator<char>()));


											int updgem = atoi(contentx.c_str());
											GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
											ENetPacket* packetpp = enet_packet_create(pp.data,
												pp.len,
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(peer, 0, packetpp);
											delete pp.data;

											string ooname = ((PlayerInfo*)(peer->data))->rawName;
											auto filename = "players/" + ooname + ".json";
											auto filename1 = "players/" + newname + ".json";
											auto filename2 = "players/gemdb/" + ooname + ".txt";
											auto filename3 = "players/gemdb/" + newname + ".txt";
											rename(filename2.c_str(), filename3.c_str());
											rename(filename.c_str(), filename1.c_str());
											((PlayerInfo*)(peer->data))->rawName = newname;
											((PlayerInfo*)(peer->data))->displayName = newname;
											GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Please relog to get ur role back!!"));
											ENetPacket* packetsdd = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packetsdd);
											delete ps.data;
											string leb = ((PlayerInfo*)(peer->data))->tankIDPass;
											GamePacket p90 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), newname), leb));
											ENetPacket* packet90 = enet_packet_create(p90.data,
												p90.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet90);

											//enet_host_flush(server);
											delete p90.data;

											((PlayerInfo*)(peer->data))->tankIDName = newname;

											std::ifstream ifff("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");


											if (ifff.fail()) {
												ifff.close();


											}
											if (ifff.is_open()) {
											}
											json j;
											ifff >> j; //load


											j["username"] = ((PlayerInfo*)(peer->data))->tankIDName; //edit




											std::ofstream o("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json"); //save
											if (!o.is_open()) {
												cout << GetLastError() << endl;
												_getch();
											}

											o << j << std::endl;
										}
										else {

											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4No enough gems!."));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
									}
								}
								if (isWarnDialog) {
									if (infoDat[0] == "warntext")
									{
										warntext = infoDat[1];
										ENetPeer* currentPeerpx;

										for (currentPeerpx = server->peers;
											currentPeerpx < &server->peers[server->peerCount];
											++currentPeerpx)
										{
											if (currentPeerpx->state != ENET_PEER_STATE_CONNECTED)
												continue;

											if (isHere(peer, currentPeerpx))
											{




												if (((PlayerInfo*)(currentPeerpx->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo) // if last wrench
												{
													GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`0Warning from `4ADMIN`0: " + warntext), "audio/hub_open.wav"), 0));
													ENetPacket* packet2 = enet_packet_create(ps2.data,
														ps2.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(currentPeerpx, 0, packet2);
													GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Applied punishment on " + ((PlayerInfo*)(peer->data))->lastInfoname + "."));
													//memcpy(p2.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
													ENetPacket* packetto = enet_packet_create(pto.data,
														pto.len,
														ENET_PACKET_FLAG_RELIABLE);

													enet_peer_send(peer, 0, packetto);
												}
											}
										}
										GamePacket p6 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `w[`cMOD LOGS `w- " + currentDateTime() + "`w] `2" + ((PlayerInfo*)(peer->data))->displayName + " (`$" + ((PlayerInfo*)(peer->data))->tankIDName + "`2) has `4warned `2" + ((PlayerInfo*)(peer->data))->lastInfoname));
										string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length());
										memcpy(data + 4 + text.length(), &zero, 1);
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (!((PlayerInfo*)(currentPeer->data))->radio)
												continue;
											if (((PlayerInfo*)(currentPeer->data))->adminLevel > 333) {
												ENetPacket* packet6 = enet_packet_create(p6.data,
													p6.len,
													ENET_PACKET_FLAG_RELIABLE);

												enet_peer_send(currentPeer, 0, packet6);




												ENetPacket* packet2 = enet_packet_create(data,
													5 + text.length(),
													ENET_PACKET_FLAG_RELIABLE);

												enet_peer_send(currentPeer, 0, packet2);

												//enet_host_flush(server);
											}
										}
									}
								}
								if (donation) {
									if (infoDat[0] == "donate")
									{
										donate = infoDat[1];
										int x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
										int y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
										bool iscontains = false;
										SearchInventoryItem(peer, ((PlayerInfo*)(peer->data))->lastdonateitem, stoi(donate), iscontains);
										if (!iscontains)
										{
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou dont have that `5much`w...", 0, true);
											continue;
											break;
										}
										bool contains_non_int = !std::regex_match(donate, std::regex("^[0-9]+$"));
										if (contains_non_int == true)
										{
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wWhat do you mean?", 0, true);
											continue;
											break;
										}
										if (stoi(donate) <= 0 || stoi(donate) >= 200)
										{
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wThats too `5much`w...", 0, true);
											continue;
											break;
										}
										if (donate.length() > 5) {
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wThats too `5much`w...", 0, true);
											continue;
											break;
										}
										RemoveInventoryItem(((PlayerInfo*)(peer->data))->lastdonateitem, stoi(donate), peer);
										world->items[x + (y * world->width)].counts1 = world->items[x + (y * world->width)].counts1 + 1;
										if (world->items[x + (y * world->width)].donate1 == 0) {
											string name = GetItemDef(((PlayerInfo*)(peer->data))->lastdonateitem).name;
											world->items[x + (y * world->width)].donate1 = ((PlayerInfo*)(peer->data))->lastdonateitem;
											world->items[x + (y * world->width)].cdonate1 = stoi(donate);
											world->items[x + (y * world->width)].mdonate1 = "`o" + name + " (`w" + donate + "`o) from `w" + ((PlayerInfo*)(peer->data))->rawName + "";
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wDonated `2" + donate + " `5" + name + "`w to donation box.", 0, true);
											visual::SendDonateData(peer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, 1);
											sendSound(peer, "page_turn.wav");
											continue;
											break;
										}
										else if (world->items[x + (y * world->width)].donate2 == 0) {
											string name = GetItemDef(((PlayerInfo*)(peer->data))->lastdonateitem).name;
											world->items[x + (y * world->width)].donate2 = ((PlayerInfo*)(peer->data))->lastdonateitem;
											world->items[x + (y * world->width)].cdonate2 = stoi(donate);
											world->items[x + (y * world->width)].mdonate2 = "`o" + name + " (`w" + donate + "`o) from `w" + ((PlayerInfo*)(peer->data))->rawName + "";
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wDonated `2" + donate + " `5" + name + "`w to donation box.", 0, true);
											visual::SendDonateData(peer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, 1);
											sendSound(peer, "page_turn.wav");
											continue;
											break;
										}
										else if (world->items[x + (y * world->width)].donate3 == 0) {
											string name = GetItemDef(((PlayerInfo*)(peer->data))->lastdonateitem).name;
											world->items[x + (y * world->width)].donate3 = ((PlayerInfo*)(peer->data))->lastdonateitem;
											world->items[x + (y * world->width)].cdonate3 = stoi(donate);
											world->items[x + (y * world->width)].mdonate3 = "`o" + name + " (`w" + donate + "`o) from `w" + ((PlayerInfo*)(peer->data))->rawName + "";
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wDonated `2" + donate + " `5" + name + "`w to donation box.", 0, true);
											visual::SendDonateData(peer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, 1);
											sendSound(peer, "page_turn.wav");
											continue;
											break;
										}
										else if (world->items[x + (y * world->width)].donate4 == 0) {
											string name = GetItemDef(((PlayerInfo*)(peer->data))->lastdonateitem).name;
											world->items[x + (y * world->width)].donate4 = ((PlayerInfo*)(peer->data))->lastdonateitem;
											world->items[x + (y * world->width)].cdonate4 = stoi(donate);
											world->items[x + (y * world->width)].mdonate4 = "`o" + name + " (`w" + donate + "`o) from `w" + ((PlayerInfo*)(peer->data))->rawName + "";
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wDonated `2" + donate + " `5" + name + "`w to donation box.", 0, true);
											visual::SendDonateData(peer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, 1);
											sendSound(peer, "page_turn.wav");
											continue;
											break;
										}
										else if (world->items[x + (y * world->width)].donate5 == 0) {
											string name = GetItemDef(((PlayerInfo*)(peer->data))->lastdonateitem).name;
											world->items[x + (y * world->width)].donate5 = ((PlayerInfo*)(peer->data))->lastdonateitem;
											world->items[x + (y * world->width)].cdonate5 = stoi(donate);
											world->items[x + (y * world->width)].mdonate5 = "`o" + name + " (`w" + donate + "`o) from `w" + ((PlayerInfo*)(peer->data))->rawName + "";
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wDonated `2" + donate + " `5" + name + "`w to donation box.", 0, true);
											visual::SendDonateData(peer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, 1);
											sendSound(peer, "page_turn.wav");
											continue;
											break;
										}
										else if (world->items[x + (y * world->width)].donate6 == 0) {
											string name = GetItemDef(((PlayerInfo*)(peer->data))->lastdonateitem).name;
											world->items[x + (y * world->width)].donate6 = ((PlayerInfo*)(peer->data))->lastdonateitem;
											world->items[x + (y * world->width)].cdonate6 = stoi(donate);
											world->items[x + (y * world->width)].mdonate6 = "`o" + name + " (`w" + donate + "`o) from `w" + ((PlayerInfo*)(peer->data))->rawName + "";
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wDonated `2" + donate + " `5" + name + "`w to donation box.", 0, true);
											visual::SendDonateData(peer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, 1);
											sendSound(peer, "page_turn.wav");
											continue;
											break;
										}
										else if (world->items[x + (y * world->width)].donate7 == 0) {
											string name = GetItemDef(((PlayerInfo*)(peer->data))->lastdonateitem).name;
											world->items[x + (y * world->width)].donate7 = ((PlayerInfo*)(peer->data))->lastdonateitem;
											world->items[x + (y * world->width)].cdonate7 = stoi(donate);
											world->items[x + (y * world->width)].mdonate7 = "`o" + name + " (`w" + donate + "`o) from `w" + ((PlayerInfo*)(peer->data))->rawName + "";
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wDonated `2" + donate + " `5" + name + "`w to donation box.", 0, true);
											visual::SendDonateData(peer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, 1);
											sendSound(peer, "page_turn.wav");
											continue;
											break;
										}
										else if (world->items[x + (y * world->width)].donate8 == 0) {
											string name = GetItemDef(((PlayerInfo*)(peer->data))->lastdonateitem).name;
											world->items[x + (y * world->width)].donate8 = ((PlayerInfo*)(peer->data))->lastdonateitem;
											world->items[x + (y * world->width)].cdonate8 = stoi(donate);
											world->items[x + (y * world->width)].mdonate8 = "`o" + name + " (`w" + donate + "`o) from `w" + ((PlayerInfo*)(peer->data))->rawName + "";
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wDonated `2" + donate + " `5" + name + "`w to donation box.", 0, true);
											visual::SendDonateData(peer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, 1);
											sendSound(peer, "page_turn.wav");
											continue;
											break;
										}
										else if (world->items[x + (y * world->width)].donate9 == 0) {
											string name = GetItemDef(((PlayerInfo*)(peer->data))->lastdonateitem).name;
											world->items[x + (y * world->width)].donate9 = ((PlayerInfo*)(peer->data))->lastdonateitem;
											world->items[x + (y * world->width)].cdonate9 = stoi(donate);
											world->items[x + (y * world->width)].mdonate9 = "`o" + name + " (`w" + donate + "`o) from `w" + ((PlayerInfo*)(peer->data))->rawName + "";
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wDonated `2" + donate + " `5" + name + "`w to donation box.", 0, true);
											visual::SendDonateData(peer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, 1);
											sendSound(peer, "page_turn.wav");
											continue;
											break;
										}
										else if (world->items[x + (y * world->width)].donate10 == 0) {
											string name = GetItemDef(((PlayerInfo*)(peer->data))->lastdonateitem).name;
											world->items[x + (y * world->width)].donate10 = ((PlayerInfo*)(peer->data))->lastdonateitem;
											world->items[x + (y * world->width)].cdonate10 = stoi(donate);
											world->items[x + (y * world->width)].mdonate10 = "`o" + name + " (`w" + donate + "`o) from `w" + ((PlayerInfo*)(peer->data))->rawName + "";
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wDonated `2" + donate + " `5" + name + "`w to donation box.", 0, true);
											visual::SendDonateData(peer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, 1);
											sendSound(peer, "page_turn.wav");
											continue;
											break;
										}
									}
								}
								if (megaphone) {
									if (infoDat[0] == "sbtext")
									{
										sbtext = infoDat[1];
										GamePacket p;


										p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 CP:0_PL:4_OID:_CT:[SB]_ `w** `5Super-Broadcast`w from `2" + (((PlayerInfo*)(peer->data))->rawName + "`w (in `$" + ((PlayerInfo*)(peer->data))->currentWorld + "`w) ** :`# " + sbtext)));

										RemoveInventoryItem(2480, 1, peer);
										sendConsoleMsg(peer, "`o >>`5 Super-Broadcast `osent. `oUsed `$1 Megaphone.");
										string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length());
										memcpy(data + 4 + text.length(), &zero, 1);
										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (!((PlayerInfo*)(currentPeer->data))->radio)
												continue;

											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(currentPeer, 0, packet);




											ENetPacket* packet2 = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);


											enet_peer_send(currentPeer, 0, packet2);

											//enet_host_flush(server);
										}
										delete data;
										delete p.data;
									}
								}
								if (notebook) {
									if (infoDat[0] == "notebooktext")
									{
										notebooktext = infoDat[1];
										((PlayerInfo*)(peer->data))->notebook = notebooktext;
										string notebook = ((PlayerInfo*)(peer->data))->notebook;
									}
								}
								if (bandialog) {
									if (infoDat[0] == "bantime")
									{
										bantime = infoDat[1];

										bool contains_non_int = !std::regex_match(bantime, std::regex("^[0-9]+$"));
										if (contains_non_int == true)
										{
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfoAboutPlayer) {
													packet::dialog(peer, "\nadd_label|big|`wBan `^" + ((PlayerInfo*)(currentPeer->data))->rawName + "|left|\nadd_spacer|small|\nadd_label|small|`wSir, symbols are `4not `wAllowed `wtry again?|left|\nadd_spacer|small|\nadd_smalltext|`9Ban time `w(`^Minutes`w) :|left|\nadd_text_input|bantime|||100|\nadd_smalltext|`wMax ban time is `443200 `w(`930 days`w)|left|\nadd_spacer|small|\nend_dialog|banplayer|Cancel|Ban Player|");
												}
											}
											continue;
											break;
										}
										if (bantime.length() > 5) {
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfoAboutPlayer) {
													packet::dialog(peer, "\nadd_label|big|`wBan `^" + ((PlayerInfo*)(currentPeer->data))->rawName + "|left|\nadd_spacer|small|\nadd_label|small|`wSir, max bantime is `443200 `wtry again?|left|\nadd_spacer|small|\nadd_smalltext|`9Ban time `w(`^Minutes`w) :|left|\nadd_text_input|bantime|||100|\nadd_smalltext|`wMax ban time is `443200 `w(`930 days`w)|left|\nadd_spacer|small|\nend_dialog|banplayer|Cancel|Ban Player|");
												}
											}
											continue;
											break;
										}
										if (stoi(bantime) <= 0 || stoi(bantime) > 43200) // 10080  - iki 7 dienu
										{
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfoAboutPlayer) {
													packet::dialog(peer, "\nadd_label|big|`wBan `^" + ((PlayerInfo*)(currentPeer->data))->rawName + "|left|\nadd_spacer|small|\nadd_label|small|`wSir, max bantime is `443200 `wtry again?|left|\nadd_spacer|small|\nadd_smalltext|`9Ban time `w(`^Minutes`w) :|left|\nadd_text_input|bantime|||100|\nadd_smalltext|`wMax ban time is `443200 `w(`930 days`w)|left|\nadd_spacer|small|\nend_dialog|banplayer|Cancel|Ban Player|");
												}
											}
											continue;
											break;
										}

										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfoAboutPlayer) {
												GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`wWarning from `4Admin `w: You've got banned from Growtopia Royal for " + OutputBanTime1(stoi(bantime) * 60) + ""), "audio/hub_open.wav"), 0));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet);
												delete p.data;
												ofstream savebantime("timebanned/" + ((PlayerInfo*)(currentPeer->data))->rawName + ".txt");
												savebantime << (GetCurrentTimeInternalSeconds() + (stoi(bantime) * 60)) << endl;
												savebantime << ((PlayerInfo*)(peer->data))->rawName << endl;
												savebantime.close();
												ofstream savebantime2("timebanned/" + ((PlayerInfo*)(currentPeer->data))->charIP + ".txt");
												savebantime2 << (GetCurrentTimeInternalSeconds() + (stoi(bantime) * 60)) << endl;
												savebantime2 << ((PlayerInfo*)(peer->data))->rawName << endl;
												savebantime2.close();
												player::disconnect(peer);
											}
										}
									}
								}
								if (mutedialog) {
									if (infoDat[0] == "mutetime")
									{
										mutetime = infoDat[1];

										bool contains_non_int = !std::regex_match(mutetime, std::regex("^[0-9]+$"));
										if (contains_non_int == true)
										{
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfoAboutPlayer) {
													packet::dialog(peer, "\nadd_label|big|`wMute `^" + ((PlayerInfo*)(currentPeer->data))->rawName + "|left|\nadd_spacer|small|\nadd_label|small|`wSir, symbols are `4not `wAllowed `wtry again?|left|\nadd_spacer|small|\nadd_smalltext|`9Mute time `w(`^Minutes`w) :|left|\nadd_text_input|mutetime|||100|\nadd_smalltext|`wMax mute time is `410080 `w(`97 days`w)|left|\nadd_spacer|small|\nend_dialog|muteplayer|Cancel|Mute Player|");
												}
											}
											continue;
											break;
										}
										if (mutetime.length() > 5) {
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfoAboutPlayer) {
													packet::dialog(peer, "\nadd_label|big|`wMute `^" + ((PlayerInfo*)(currentPeer->data))->rawName + "|left|\nadd_spacer|small|\nadd_label|small|`wSir, max mutetime is `410080 `wtry again?|left|\nadd_spacer|small|\nadd_smalltext|`9Mute time `w(`^Minutes`w) :|left|\nadd_text_input|mutetime|||100|\nadd_smalltext|`wMax mute time is `410080 `w(`97 days`w)|left|\nadd_spacer|small|\nend_dialog|muteplayer|Cancel|Mute Player|");
												}
											}
											continue;
											break;
										}
										if (stoi(mutetime) <= 0 || stoi(mutetime) > 10080) // 10080  - iki 7 dienu
										{
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfoAboutPlayer) {
													packet::dialog(peer, "\nadd_label|big|`wMute `^" + ((PlayerInfo*)(currentPeer->data))->rawName + "|left|\nadd_spacer|small|\nadd_label|small|`wSir, max mutetime is `410080 `wtry again?|left|\nadd_spacer|small|\nadd_smalltext|`9Mute time `w(`^Minutes`w) :|left|\nadd_text_input|mutetime|||100|\nadd_smalltext|`wMax mute time is `410080 `w(`97 days`w)|left|\nadd_spacer|small|\nend_dialog|muteplayer|Cancel|Mute Player|");
												}
											}
											continue;
											break;
										}

										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfoAboutPlayer) {
												GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`wWarning from `4Admin `w: You've got muted from Growtopia Royal for " + OutputBanTime1(stoi(mutetime) * 60) + ""), "audio/hub_open.wav"), 0));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet);
												delete p.data;
												ofstream savebantime("timemuted/" + ((PlayerInfo*)(currentPeer->data))->rawName + ".txt");
												savebantime << (GetCurrentTimeInternalSeconds() + (stoi(mutetime) * 60)) << endl;
												savebantime.close();
												using namespace std::chrono;
												((PlayerInfo*)(currentPeer->data))->taped = true;
												((PlayerInfo*)(currentPeer->data))->isDuctaped = true;
												((PlayerInfo*)(currentPeer->data))->lastMuted = ((duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) + (stoi(mutetime) * 60 * 1000);
												sendState(currentPeer);
											}
										}
									}
								}
								if (marsblast) {
									if (infoDat[0] == "marstext") {
										marstext = infoDat[1];
										WorldInfo* wrld = getPlyersWorld(peer);
										generateWorlds(marstext, wrld->width, wrld->height);
										sendPlayerToWorldss(peer, (PlayerInfo*)(peer->data), marstext);
									}
								}
								if (vip) {
									((PlayerInfo*)(peer->data))->wls = ((PlayerInfo*)(peer->data))->wls - 200;
									GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "You received `cVIP"), "audio/hub_open.wav"), 0));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									std::ifstream ifff("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");




									if (ifff.fail()) {
										ifff.close();


									}
									if (ifff.is_open()) {
									}
									json j;
									ifff >> j; //load

									j["adminLevel"] = 111;

									//j["friends"] = ((PlayerInfo*)(peer->data))->friendinfo;


									std::ofstream o("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json"); //save
									if (!o.is_open()) {
										cout << GetLastError() << endl;
										_getch();
									}

									o << j << std::endl;
									enet_peer_disconnect_later(peer, 0);
								}
								if (moderator) {
									((PlayerInfo*)(peer->data))->wls = ((PlayerInfo*)(peer->data))->wls - 500;
									GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`2You Purchased `#MODERATOR"), "audio/hub_open.wav"), 0));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									std::ifstream ifff("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");



									if (ifff.fail()) {
										ifff.close();


									}
									if (ifff.is_open()) {
									}
									json j;
									ifff >> j; //load

									j["adminLevel"] = 444;

									//j["friends"] = ((PlayerInfo*)(peer->data))->friendinfo;


									std::ofstream o("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json"); //save
									if (!o.is_open()) {
										cout << GetLastError() << endl;
										_getch();
									}

									o << j << std::endl;
									enet_peer_disconnect_later(peer, 0);
								}
								if (isOptionalStuffDialog) {
									if (((PlayerInfo*)(peer->data))->currentWorld != "EXIT") {
										int stuffitemi = -1;
										int gravity = 100;

										int x = ((PlayerInfo*)(peer->data))->lastPunchX;
										int y = ((PlayerInfo*)(peer->data))->lastPunchY;

										if (infoDat[0] == "stuffitem") stuffitem = infoDat[1];


										if (infoDat[0] == "gravity") gravitystr = infoDat[1];

										if (has_only_digits(stuffitem)) stuffitemi = atoi(stuffitem.c_str());
										if (has_only_digits_wnegative(gravitystr)) gravity = atoi(gravitystr.c_str());

										if (gravity > -1000 && gravity < 1000 && stuffitemi > -1 && stuffitemi < 9142) {
											world->stuffID = stuffitemi;
											world->gravity = gravity;
										}

										updateStuffWeather(peer, x, y, stuffitemi, world->items[x + (y * world->width)].background, gravity, invert, spin);
										getPlyersWorld(peer)->weather = 29;
									}

								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "editdoor")
								{
									isEditDoorDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "editpdoor")
								{
									isEditPDoorDialog = true;
								}
								if (isEditDoorDialog || isEditPDoorDialog) {
									if (infoDat[0] == "dest")
									{
										string a = getStrUpper(infoDat[1]);
										vector<string> b = explode(":", a);
										if (b.size() == 1)
										{
											destworld = b[0];
										}
										else if (b.size() > 1)
										{
											destworld = b[0];
											destid = b[1];
										}
									}
									if (infoDat[0] == "label")
									{
										label = infoDat[1];
									}
									if (infoDat[0] == "doorid")
									{
										currid = getStrUpper(infoDat[1]);
									}
									if (infoDat[0] == "doorpw")
									{
										passwordss = getStrUpper(infoDat[1]);
									}
								}
								if (isEditDoorDialog || isEditPDoorDialog)
								{
									PlayerInfo* pinfo = (PlayerInfo*)peer->data;
									if (pinfo->wrenchsession < 0 && pinfo->wrenchsession > 6000) break;
									world->items[pinfo->wrenchsession].destWorld = destworld;
									world->items[pinfo->wrenchsession].destId = destid;
									world->items[pinfo->wrenchsession].currId = currid;
									world->items[pinfo->wrenchsession].label = label;
									world->items[pinfo->wrenchsession].password = passwordss;
									string labelForDoor = label == "" ? (destid == "" ? destworld : destworld + "...") : label;
									updateDoor(peer, world->items[pinfo->wrenchsession].foreground, pinfo->wrenchsession % world->width, pinfo->wrenchsession / world->width, labelForDoor);
									// .....
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "pwddoor")
								{
									isPwdDoorDialog = true;
								}
								if (isPwdDoorDialog) {
									if (infoDat[0] == "doorpass") passwords = infoDat[1];
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "findid")
								{
									isFindDialog = true;
								}
								if (isFindDialog) {
									if (infoDat[0] == "item") itemFind = infoDat[1];
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "omgc0de") isSecurityDialog = true;
								if (isSecurityDialog) {
									if (infoDat[0] == "item") c0de = infoDat[1];
								}
								if (infoDat[0] == "netid") {
									netid = infoDat[1];
									Accesspicker = true;
								}
							}
						}
						if (btn == "worldPublic") if (((PlayerInfo*)(peer->data))->rawName == getPlyersWorld(peer)->owner) getPlyersWorld(peer)->isPublic = true;
						if (btn == "worldPrivate") if (((PlayerInfo*)(peer->data))->rawName == getPlyersWorld(peer)->owner) getPlyersWorld(peer)->isPublic = false;
						if (btn == "backsocialportal") {
							if (((PlayerInfo*)(peer->data))->joinguild == true) {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|backonlinelist|Show Friends``|0|0|\nadd_button|showguild|Show Guild Members``|0|0|\nadd_button|guildrewards|Guild Rewards``|0|0|\nend_dialog||OK||\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|backonlinelist|Show Friends``|0|0|\nadd_button|createguildinfo|Create Guild``|0|0|\nend_dialog||OK||\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "traderubble") {
							if (((PlayerInfo*)(peer->data))->ban > 0) {
								int valgem = rand() % 15;
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem + valgem;
								((PlayerInfo*)(peer->data))->ban = ((PlayerInfo*)(peer->data))->ban - 1;
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You got " + to_string(valgem) + " gems."));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete ps.data;
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetpp);
								delete pp.data;
							}

							else {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`3You don't have any rubbles"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete ps.data;
							}
							if (((PlayerInfo*)(peer->data))->haveGrowId) {
								savejson(peer);
							}
						}
						if (btn == "wolftamer") //PRO ITEM ...
						{
							bool iscontains = false;
							SearchInventoryItem(peer, 4354, 90, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enought `2 WolfTickets`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else {
								bool success = true;
								if (success)
								{
									RemoveInventoryItem(4354, 90, peer);
									SaveShopsItemMoreTimes(2986, 1, peer, success);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You Purchased A `2Howler!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "itempacks") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_button_with_icon|rockpack|Rockin' Pack|staticBlueFrame|1710|\nadd_button_with_icon|shoppack|Shop Pack|staticBlueFrame|1430|\nadd_button_with_icon|cinemapack|Cinema Pack|staticBlueFrame|1608|\nadd_button_with_icon|doorsign|Door & Sign Hello Pack|staticBlueFrame|12|\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|sciencepack|Mad Science Pack|staticBlueFrame|1932|\nadd_button_with_icon|ringofwisdom||staticBlueFrame|1996|\nadd_button_with_icon|ringofsavings||staticBlueFrame|3140|\nadd_button_with_icon|ringofnature||staticBlueFrame|6846|\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|ringofsmithing||staticBlueFrame|3174|\nadd_button_with_icon|ringofnight||staticBlueFrame|8962|\nadd_button_with_icon|ringofshrinking||staticBlueFrame|6028|\nadd_button_with_icon|theonering||staticBlueFrame|1904|\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "legenddragon") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`9Quest For Fire``|left|1790|\n\nadd_spacer|small|\nadd_label|small|`oThis quest will challenge every fiber of your Growtopian being. it will cost you thousands of gems weeks or months of time, and possibly your friendss and family. Every quest has 10 steps to complete, and each step alone is probably more than the most Growtopians could manage. But the rewards are also vast. If you complete this quest you will earn the `9 Legendary Dragon`o! These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest. You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turn in their final quest step to me, so don't let other people have access to me! There's one last thing you should know before you begin. You canquit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end ``|left|4|\n\nadd_spacer|small|\nadd_textbox|`oSo... now that you'be received the official disclaimer, yare you truly prepared to embark on the Quest for Honor?!|small|left|\nadd_button|legenddragon1|`oYes!``|0|0||"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "legenddragon1") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`9Quest For Fire``|left|1790|\nadd_label|small|`o(Step 1/5)``|left|4|\n\nadd_spacer|small|\nadd_label|small|`oI challenge you to bring me `1 Rayman's Fist!``|left|4|\n\nadd_spacer|small|\nadd_button|legenddragon2|`oDeliver 1 Rayman's fist!``|0|0|\nadd_quick_exit|\nend_dialog|noty|Give up on quest!|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "legenddragon2") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`9Quest For Fire``|left|1790|\nadd_label|small|`o(Step 2/5)``|left|4|\n\nadd_spacer|small|\nadd_label|small|`oI challenge you to bring me 400 Sand Seeds``|left|4|\n\nadd_spacer|small|\nadd_button|legenddragon3|`oDeliver 400 Sand Seeds!``|0|0|\nadd_quick_exit|\nend_dialog|noty|Give up on quest!|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Quest step complete!!"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
						}
						if (btn == "legenddragon3") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`9Quest For Fire``|left|1790|\nadd_label|small|`o(Step 3/5)``|left|4|\n\nadd_spacer|small|\nadd_label|small|`oI challenge you to bring me 1 Megaphone``|left|4|\n\nadd_spacer|small|\nadd_button|legenddragon4|`oDeliver 1 Megaphone!``|0|0|\nadd_quick_exit|\nend_dialog|noty|Give up on quest!|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Quest step complete!!"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
						}
						if (btn == "legenddragon4") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`9Quest For Fire``|left|1790|\nadd_label|small|`o(Step 4/5)``|left|4|\n\nadd_spacer|small|\nadd_label|small|`oI challenge you to deliver me 2 Cosmic Capes``|left|4|\n\nadd_spacer|small|\nadd_button|legenddragon5|`oDeliver 2 Cosmic Cape!``|0|0|\nadd_quick_exit|\nend_dialog|noty|Give up on quest!|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Quest step complete!!"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
						}
						if (btn == "legenddragon5") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`9Quest For Fire``|left|1790|\nadd_label|small|`o(Step 5/5)``|left|4|\n\nadd_spacer|small|\nadd_label|small|`oI challenge you to deliver me 1 Legendary Orb``|left|4|\n\nadd_spacer|small|\nadd_button|legenddragon11|`oDeliver 1 Legendary Orb!``|0|0|\nadd_quick_exit|\nend_dialog|noty|Give up on quest!|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Quest step complete!!"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
						}

						if (btn == "tokenitems") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_button_with_icon|feyes|Focused Eyes|staticBlueFrame|1204|\nadd_button_with_icon|goldenpickaxe|Golden Pickaxe|staticBlueFrame|1438|\nadd_button_with_icon|puppyleash|Puppy Leash|staticBlueFrame|1742|\nadd_button_with_icon|crystalcape|Crystal Cape|staticBlueFrame|1738|\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|nvisgoggle|Night Vision Goggles|staticBlueFrame|3576|\nadd_button_with_icon|gtokenmegaphone|Megaphone|staticBlueFrame|2480|\nadd_button_with_icon|doodad|Doodad|staticBlueFrame|1492|\nadd_button_with_icon|SpikeJuice|Spike Juice|staticBlueFrame|1662|END_LIST|noflags|0|0|\nadd_button_with_icon|nothingness|Nothingness|staticBlueFrame|1490|\nadd_button_with_icon|ringofnight||staticBlueFrame|8962|\nadd_button_with_icon|ringofshrinking||staticBlueFrame|6028|\nadd_button_with_icon|theonering||staticBlueFrame|1904|\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "playeritems") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_button_with_icon|iotm|Item Of The Month 200.000|staticBlueFrame|5480|\nadd_button_with_icon|storeinvupgrade|Backpack Store|staticBlueFrame|448|\nadd_button_with_icon|puppyleash|Puppy Leash 200 Growtokens|staticBlueFrame|1742|\nadd_button_with_icon|crystalcape|Crystal Cape 90 Growtokens|staticBlueFrame|1738|\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|nvisgoggle|Night Vision Goggles 120 Growtokens|staticBlueFrame|3576|\nadd_button_with_icon|gtokenmegaphone|Megaphone 10 Growtokens|staticBlueFrame|2480|\nadd_button_with_icon|ringofsavings||staticBlueFrame|3140|\nadd_button_with_icon|ringofnature||staticBlueFrame|6846|\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|ringofsmithing||staticBlueFrame|3174|\nadd_button_with_icon|ringofnight||staticBlueFrame|8962|\nadd_button_with_icon|ringofshrinking||staticBlueFrame|6028|\nadd_button_with_icon|theonering||staticBlueFrame|1904|\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "feyes") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`oThis Untradeable item lets you shoot electricity from your eyes! Wear them with pride, and creepiness.``|left|1430|\nadd_spacer|\nadd_button|confirmfeyes|`2BUY!|\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "confirmfeyes") //PRO ITEM ...
						{
							bool iscontains = false;
							SearchInventoryItem(peer, 1486, 100, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`5You `@Don't `9Have enought `2 Growtokens`5!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else {
								bool success = true;
								if (success)
								{
									RemoveInventoryItem(1486, 100, peer);
									SaveShopsItemMoreTimes(1204, 1, peer, success);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`5You Purchased `2Focused Eyes!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}/*
						if (btn == "20kblock") {
							if (((PlayerInfo*)(peer->data))->lq < 20000) {
								sendConsoleMsg(peer, "You have to destory " + std::to_string(20000 - ((PlayerInfo*)(peer->data))->lq) + " more blocks.", false, "", false, false);
							}
							else {
								((PlayerInfo*)(peer->data))->lq = 0;
								((PlayerInfo*)(peer->data))->step = 3;
								sendDialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`9Quest For Honor``|left|1790|\nadd_label|small|`o(Step 3/3)``|left|4|\n\nadd_spacer|small|\nadd_label|small|`oAnd for the last step, I challenge you to bring 1 reborn wings (note: you are going to lose it)!``|left|4|\n\nadd_spacer|small|\nadd_button|rwing|`oDeliver Reborn Wing!``|0|0|\nadd_quick_exit|\nend_dialog|noty|GoodBye!||gazette||");
								updatedb(peer);
							}
						}
						if (btn == "rwing") {
							if (((PlayerInfo*)(peer->data))->allow1 == 0) {
								sendConsoleMsg(peer, "You dont have Reborn Wings to deliver", false, "", false, false);
							}
							else {
								((PlayerInfo*)(peer->data))->allow1 = 0;
								((PlayerInfo*)(peer->data))->lname = 1;
								((PlayerInfo*)(peer->data))->cloth_back = 0;
								sendConsoleMsg(peer, "`9You are a legendary, reenter the world to get your legendary name", false, "", false, false);
								((PlayerInfo*)(peer->data))->displayName = ((PlayerInfo*)(peer->data))->displayName + " of Legend";
								sendClothes(peer);
								updatedb(peer);
							}
						}
						if (btn == "lname") {
							((PlayerInfo*)(peer->data))->step = 1;
							updatedb(peer);
							sendDialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`9Quest For Honor``|left|1790|\nadd_label|small|`o(Step 1/3)``|left|4|\n\nadd_spacer|small|\nadd_label|small|`oI challenge you to bring me 50,000 gems!``|left|4|\n\nadd_spacer|small|\nadd_button|50kgem|`oDeliver 50,000 Gem!``|0|0|\nadd_quick_exit|\nend_dialog|noty|GoodBye!||gazette||");
						}
						if (btn == "50kgem") {
							if (((PlayerInfo*)(peer->data))->gem >= 50000) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 50000;
								setbux(peer);
								((PlayerInfo*)(peer->data))->step = 2;
								sendDialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`9Quest For Honor``|left|1790|\nadd_label|small|`o(Step 2/3)``|left|4|\n\nadd_spacer|small|\nadd_label|small|`oI challenge you to destory 20,000 blocks!``|left|4|\n\nadd_spacer|small|\nadd_button|20kblock|`oI destroyed 20,000 blocks!``|0|0|\nadd_quick_exit|\nend_dialog|noty|GoodBye!||gazette||");
								updatedb(peer);
							}
							else {
								sendConsoleMsg(peer, "`oYou need " + std::to_string(50000 - ((PlayerInfo*)(peer->data))->gem) + " more gems.", false, "", false, false);
							}
						}
						else {
							sendConsoleMsg(peer, "`9Use /lname to enable/disable your legendary name!", false, "", false, false);
						}
						}
						sendDialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`9Quest For Honor``|left|1790|\nadd_label|small|`o(Step 2/3)``|left|4|\n\nadd_spacer|small|\nadd_label|small|`oI challenge you to break 20,000 blocks!``|left|4|\n\nadd_spacer|small|\nadd_button|20kblock|`oI destroyed 20,000 blocks!``|0|0|\nend_dialog|noty|GoodBye!||gazette||");
								}
								else if (((PlayerInfo*)(peer->data))->step == 3) {
								sendDialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`9Quest For Honor``|left|1790|\nadd_label|small|`o(Step 3/3)``|left|4|\n\nadd_spacer|small|\nadd_label|small|`oAnd for the last step, I challenge you to bring 1 reborn wings (note: you are going to lose it)!``|left|4|\n\nadd_spacer|small|\nadd_button|rwing|`oDeliver Reborn Wing!``|0|0|\nend_dialog|noty|GoodBye!||gazette||");
								}*/
						if (btn == "iotm") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`oThe perfect punch! Ever wanted to send a disembodied fist flying across the land like Rayman? Well, now you can! Land a blow like none other with this furious fist. It even comes with a friend: Globox!``|left|1430|\nadd_spacer|\nadd_button|confirmiotm|`2BUY!|\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "confirmiotm") //PRO ITEM ...
							if (((PlayerInfo*)(peer->data))->gem >= 200000) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 200000;
								bool success = true;
								SaveShopsItemMoreTimes(1714, 1, peer, success); // aposition, itemid, quantity, peer, success

								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
						if (btn == "rockpack") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`oROCK N' ROLL!!! Play live music in-game with 3 Rare musical instruments, Starchild Makeup, a Rockin' Headband, Leopard Leggings, a Shredded T-Shirt, a Drumkit, 6 Stage Supports, 6 Mega Rock Speakers, and 6 Rock N' Roll Wallpaper. This Pack Will Cost You 10.000 GEMS!``|left|6200|\nadd_spacer|\nadd_button|confirmrock|`2BUY!|\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "confirmrock") //PRO ITEM ...
							if (((PlayerInfo*)(peer->data))->gem >= 10000) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 10000;
								bool success = true;
								SaveShopsItemMoreTimes(1714, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1710, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1712, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1718, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1732, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1722, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1720, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1724, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1728, 6, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1730, 6, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1726, 6, peer, success); // aposition, itemid, quantity, peer, success

								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
						if (btn == "shoppack") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`oRun a fancy shop with these new items!You'll get 4 Display Boxes to hold items, 4 different kinds of signs to advertise your wares, an Open/Closed Sign you can switch with a punch, a Cash Register, a Mannequin you can dress up to show off clothing, and a Rare Security Camera, which reports when people enter and take items! This Pack Will Cost You 10.000 GEMS``|left|1430|\nadd_spacer|\nadd_button|confirmshoppack|`2BUY!|\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "confirmshoppack") //PRO ITEM ...
							if (((PlayerInfo*)(peer->data))->gem >= 10000) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 10000;
								bool success = true;
								SaveShopsItemMoreTimes(1436, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1422, 4, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1426, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1428, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1432, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1430, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1446, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1434, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1420, 1, peer, success); // aposition, itemid, quantity, peer, success
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
						if (btn == "cinemapack") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`oIt's movie time! This pack includes a Clapboard, a Black Beret, 3D Glasses, 6 Theater Curtains, 6 Marquee Blocks, a Director's Chair, 4 Theater Seats, 6 Movie Screens, a Movie Camera, and a rare GHX Speaker that plays the score from Growtopia: The Movie.This Pack Will Cost You 6.000 GEMS!``|left|1430|\nadd_spacer|\nadd_button|confirmcinemapack|`2BUY!|\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "confirmcinemapack") //PRO ITEM ...
							if (((PlayerInfo*)(peer->data))->gem >= 6000) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 6000;
								bool success = true;
								SaveShopsItemMoreTimes(1588, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1592, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1590, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1594, 6, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1598, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1600, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1604, 4, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1606, 6, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1608, 1, peer, success); // aposition, itemid, quantity, peer, success
								SaveShopsItemMoreTimes(1596, 1, peer, success); // aposition, itemid, quantity, peer, success

								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
						if (btn == "teststore") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_button|bigitems_menu|Awesome Items|interface/large/store_buttons4.rttex\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;//list to do, tugas, setup vps + coding.
						}
						if (btn == "ticketsconfirm") //PRO ITEM ...
							if (((PlayerInfo*)(peer->data))->gem >= 1000) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 1000;
								bool success = true;
								SaveShopsItemMoreTimes(4354, 1, peer, success); // aposition, itemid, quantity, peer, success

								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}

						if (btn == "ticketsbuy") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`oAre You Sure You Want To Buy This item?``|left|6200|\nadd_spacer|\nadd_button|ticketsconfirm|`2YES!|\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "buywls") //PRO ITEM ...
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`oAre You Sure You Want To Buy This item?``|left|6200|\nadd_spacer|\nadd_button|wlsconfirm|`2YES!|\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "wlsconfirm") //PRO ITEM ...
							if (((PlayerInfo*)(peer->data))->gem >= 2000) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 2000;
								bool success = true;
								SaveShopsItemMoreTimes(242, 1, peer, success); // aposition, itemid, quantity, peer, success

								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						if (btn == "backpack1") //PRO ITEM ...
						{
							short nextSpace = 0;

							if (((PlayerInfo*)(peer->data))->currentInventorySize + 30 > 200)
							{
								nextSpace = 200;
							}
							else
							{
								nextSpace = ((PlayerInfo*)(peer->data))->currentInventorySize + 30;
							}

							if (((PlayerInfo*)(peer->data))->currentInventorySize == 200)
							{
								sendConsoleMsg(peer, "You already reached the max backpack level!");
							}
							else
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`2Purchase `8Inventory Upgrade`2!``|left|6204|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`wNOTE : This inventory upgrade will cost (`21000 Gems`w)``|\nadd_textbox|`oYour inventory space is`8 " + to_string(((PlayerInfo*)(peer->data))->currentInventorySize) + " `onow.|\nadd_label|small|\nadd_textbox|`9After purchasing an inventory upgrade, your inventory will have`2 " + to_string(nextSpace) + "`9 spaces.|left|8|\nadd_spacer|small|\nadd_button|buyinvupgrade|`wUpgrade my inventory!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}

						if (btn == "buyinvupgrade") {
							if (((PlayerInfo*)(peer->data))->gem > 1000) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 1000;
								savejson(peer);
								bool success = true;


								short nextSpace = 0;

								if (((PlayerInfo*)(peer->data))->currentInventorySize + 30 > 200)
								{
									nextSpace = 200;
								}
								else
								{
									nextSpace = ((PlayerInfo*)(peer->data))->currentInventorySize + 30;
								}

								ofstream fs("usersinventorysize/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								fs << nextSpace;
								fs.close();
								sendConsoleMsg(peer, "`2Payment Succesful! `2Successfully upgraded your inventory!");
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								enet_peer_disconnect_later(peer, 0);
							}
						}


						if (btn == "claim") {
							bool success = true;
							SaveShopsItemMoreTimes(7484, 1, peer, success);
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`w\n\nadd_label_with_icon|big|`wDaily login``|left|18|\nadd_label|small|`oYou received 1 `1Winter chest!|left|18|\n\nadd_spacer|\nend_dialog|okk|`2Thanks|No|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "lockebuymega") //PRO ITEM ...
						{
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 10, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enought `2 Growtoken`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else {
								bool success = true;
								if (success)
								{
									RemoveInventoryItem(242, 10, peer);
									SaveShopsItemMoreTimes(2480, 1, peer, success);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You Purchased `2Megaphone!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "lockebuytoken") {
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 2, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enought `2World Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else {
								bool success = true;
								if (success)
									RemoveInventoryItem(242, 2, peer);
								SaveShopsItemMoreTimes(1486, 1, peer, success);
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You Purchased `2Growtoken!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;

							}
						}
						if (btn == "lockebuyeyes") {
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 30, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enought `2World Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else {
								bool success = true;
								if (success)
									RemoveInventoryItem(242, 30, peer);
								SaveShopsItemMoreTimes(2476, 1, peer, success);
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You Purchased `2Burning Eyes!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;

							}
						}

						if (btn == "lockebuymag") //PRO ITEM ...
						{
							if (((PlayerInfo*)(peer->data))->gem > 99999) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 100000;
								savejson(peer);
								bool success = true;
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You Purchased `2Magplant 5000!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								SaveShopsItemMoreTimes(5638, 1, peer, success);
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
								sendSound(peer, "cash_register.wav");
							}
							else {

								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later."));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;

								sendSound(peer, "babycry.wav");
							}

						}
						if (btn == "lockebuyray") //PRO ITEM ...
						{
							if (((PlayerInfo*)(peer->data))->gem > 9999) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 10000;
								savejson(peer);
								bool success = true;
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You Purchased `2Rayman Fist!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								SaveShopsItemMoreTimes(5480, 1, peer, success);
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
								sendSound(peer, "cash_register.wav");
							}
							else {

								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later."));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;

								sendSound(peer, "babycry.wav");
							}

						}
						if (btn == "lockebuychand") //PRO ITEM ...
						{
							if (((PlayerInfo*)(peer->data))->gem > 2999) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 3000;
								savejson(peer);
								bool success = true;
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You Purchased `2200 Chandelier!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								SaveShopsItemMoreTimes(340, 200, peer, success);
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
								sendSound(peer, "cash_register.wav");
							}
							else {

								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4Purchase Failed: You Don't Have Enough Gems To Buy This Items. `5Try again later."));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;

								sendSound(peer, "babycry.wav");
							}

						}
						if (btn == "giveownership") {
							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer))
								{

									if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo) {
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`w\n\nadd_label_with_icon|big|`wGiving ownership to people``|left|18|\nadd_label|small|`oAre you sure you want to give the ownership to this player?``|left|18|\n\nadd_spacer|\nend_dialog|giveowner|`2Yes|No|\nadd_quick_exit|"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
						}
						if (btn == "rankinfo") {
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`w\n\nadd_label_with_icon|big|`wRank info``|left|18|\nadd_label|big|`2Newbie (< 10)|left|18|\n\nadd_spacer|small|\nadd_textbox|`wNothing for now|left|\nadd_spacer|small|\nadd_label|big|`1Advance (> 10)|left|\nadd_spacer|small|\nadd_textbox|`2Extra `wgems when breaking blocks!|left|\nadd_spacer|small|\nadd_label|big|`cPro (>= 50)|left|\nadd_spacer|small|\nadd_textbox|`2Extra `wgems when breaking blocks (3x)|left|\nadd_spacer|small|\nadd_label|big|`eMaster (>= 100)|left|\nadd_spacer|small|\nadd_textbox|`2Extra `wgems when breaking blocks (4x)|left|\nadd_spacer|small|\nadd_label|big|`9Expert (>= 150)|left|\nadd_spacer|small|\nadd_textbox|`2Extra `wgems when breaking blocks (5x)|left|\nadd_spacer|small|\nadd_label|big|`5A`4C`9E|left|\nadd_spacer|small|\nadd_textbox|`2Extra `wgems when breaking blocks (6x) + /ace (ace sb)|left|\n\nadd_spacer|\nend_dialog|okk|`2Thanks|No|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "trades") {
							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer))
								{

									if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo) {
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`w\n\nadd_label_with_icon|big|`oTrade!``|left|18|\nadd_label|small|`oChoose the items that u want to sell.``|left|18|\n\nadd_spacer|small|\nadd_button_with_icon|di1||staticBlueFrame|2952||\nadd_button_with_icon|ry1||staticBlueFrame|5480||\nadd_button_with_icon|tk1||staticBlueFrame|5078||\nadd_button_with_icon|wr1||staticBlueFrame|7912||\nadd_button_with_icon|pw1||staticBlueFrame|6312||\nend_dialog||OK||\nadd_quick_exit|"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
						}
						if (btn == "legendbot") {

							((PlayerInfo*)(peer->data))->cloth_shirt = 1780;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have legendary bot now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Quest step complete!!"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);


							delete p2.data;
							delete p.data;
							int effect = 90;
							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer)) {

									int x = ((PlayerInfo*)(peer->data))->x;
									int y = ((PlayerInfo*)(peer->data))->y;
									GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), effect), x, y));

									ENetPacket* packetd = enet_packet_create(psp.data,
										psp.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packetd);

									delete psp.data;
									bool dary = std::experimental::filesystem::exists("achievements/dary/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
									if (dary == false)
									{
										int effect = 48;
										int x = ((PlayerInfo*)(currentPeer->data))->x;
										int y = ((PlayerInfo*)(currentPeer->data))->y;
										GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), effect), x, y));

										ENetPacket* packetd = enet_packet_create(psp.data,
											psp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetd);
										GamePacket p3 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), ((PlayerInfo*)(peer->data))->displayName + " `5earned the achievement ''DARY!''!"));
										ENetPacket* packet3 = enet_packet_create(p3.data,
											p3.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet3);
										delete p3.data;

										ofstream myfile;
										myfile.open("achievements/dary/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
										myfile << "true";
										myfile.close();
									}
								}
							}

						}
						if (btn == "storeinvupgrade")
						{
							short nextSpace = 0;

							if (((PlayerInfo*)(peer->data))->currentInventorySize + 30 > 200)
							{
								nextSpace = 200;
							}
							else
							{
								nextSpace = ((PlayerInfo*)(peer->data))->currentInventorySize + 30;
							}

							if (((PlayerInfo*)(peer->data))->currentInventorySize == 200)
							{
								sendConsoleMsg(peer, "You already reached the max backpack level!");
							}
							else
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`2Purchase `8Inventory Upgrade`2!``|left|6204|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`wNOTE : This inventory upgrade will cost (`21000 Gems`w)``|\nadd_textbox|`oYour inventory space is`8 " + to_string(((PlayerInfo*)(peer->data))->currentInventorySize) + " `onow.|\nadd_label|small|\nadd_textbox|`9After purchasing an inventory upgrade, your inventory will have`2 " + to_string(nextSpace) + "`9 spaces.|left|8|\nadd_spacer|small|\nadd_button|buyinvupgrade|`wUpgrade my inventory!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}

						if (btn == "buyinvupgrade") {
							if (((PlayerInfo*)(peer->data))->gem > 1000) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 1000;
								savejson(peer);
								bool success = true;


								short nextSpace = 0;

								if (((PlayerInfo*)(peer->data))->currentInventorySize + 30 > 200)
								{
									nextSpace = 200;
								}
								else
								{
									nextSpace = ((PlayerInfo*)(peer->data))->currentInventorySize + 30;
								}

								ofstream fs("usersinventorysize/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								fs << nextSpace;
								fs.close();
								sendConsoleMsg(peer, "`2Payment Succesful! `2Successfully upgraded your inventory!");
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}



						if (btn == "legendname11") {

							bool success = true;
							SaveShopsItemMoreTimes(5638, 1, peer, success);
							((PlayerInfo*)(peer->data))->cloth_hand = 1782;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have legendary dragon now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Quest step complete!!"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
							delete p.data;

							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer)) {


									bool dary = std::experimental::filesystem::exists("achievements/dary/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
									if (dary == false)
									{
										int effect = 48;
										int x = ((PlayerInfo*)(currentPeer->data))->x;
										int y = ((PlayerInfo*)(currentPeer->data))->y;
										GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), effect), x, y));

										ENetPacket* packetd = enet_packet_create(psp.data,
											psp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetd);
										GamePacket p3 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), ((PlayerInfo*)(peer->data))->displayName + " `5earned the achievement ''DARY!''!"));
										ENetPacket* packet3 = enet_packet_create(p3.data,
											p3.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet3);
										delete p3.data;

										ofstream myfile;
										myfile.open("achievements/dary/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
										myfile << "true";
										myfile.close();
									}
								}
							}

						}


						if (btn == "ke") {

							((PlayerInfo*)(peer->data))->cloth_back = 1784;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have legendary wing now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Quest step complete!!"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
							delete p.data;
							int effect = 90;
							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer)) {



									bool dary = std::experimental::filesystem::exists("achievements/dary/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
									if (dary == false)
									{
										int effect = 48;
										int x = ((PlayerInfo*)(currentPeer->data))->x;
										int y = ((PlayerInfo*)(currentPeer->data))->y;
										GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), effect), x, y));

										ENetPacket* packetd = enet_packet_create(psp.data,
											psp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetd);
										GamePacket p3 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), ((PlayerInfo*)(peer->data))->displayName + " `5earned the achievement ''DARY!''!"));
										ENetPacket* packet3 = enet_packet_create(p3.data,
											p3.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet3);
										delete p3.data;

										ofstream myfile;
										myfile.open("achievements/dary/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
										myfile << "true";
										myfile.close();
									}
								}

							}
						}

						if (btn == "legendsky") {

							((PlayerInfo*)(peer->data))->cloth_back = 7734;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have Legendary Dragon Knight's Wings!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Quest step complete!!"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
							delete p.data;

							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer)) {


									bool dary = std::experimental::filesystem::exists("achievements/dary/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
									if (dary == false)
									{
										int effect = 48;
										int x = ((PlayerInfo*)(currentPeer->data))->x;
										int y = ((PlayerInfo*)(currentPeer->data))->y;
										GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), effect), x, y));

										ENetPacket* packetd = enet_packet_create(psp.data,
											psp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetd);
										GamePacket p3 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), ((PlayerInfo*)(peer->data))->displayName + " `5earned the achievement ''DARY!''!"));
										ENetPacket* packet3 = enet_packet_create(p3.data,
											p3.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet3);
										delete p3.data;

										ofstream myfile;
										myfile.open("achievements/dary/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
										myfile << "true";
										myfile.close();
									}

								}
							}
						}
						if (btn == "enablemag") {
							int squaresign = ((PlayerInfo*)(peer->data))->wrenchx + (((PlayerInfo*)(peer->data))->wrenchy * 100);
							getPlyersWorld(peer)->magplant = true;
							sendMag(peer, squaresign % getPlyersWorld(peer)->width, squaresign / getPlyersWorld(peer)->width, 112, 1, true, true);
							PlayerInfo* pinfo = (PlayerInfo*)peer->data;
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer))
								{
									sendConsoleMsg(currentPeer, "`oWorld owner has turned `2on `othe magplant!");
								}
							}
						}
						if (btn == "disablemag") {
							int squaresign = ((PlayerInfo*)(peer->data))->wrenchx + (((PlayerInfo*)(peer->data))->wrenchy * 100);
							getPlyersWorld(peer)->magplant = false;
							sendMag(peer, squaresign % getPlyersWorld(peer)->width, squaresign / getPlyersWorld(peer)->width, 112, 1, false, false);
							PlayerInfo* pinfo = (PlayerInfo*)peer->data;
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer))
								{
									sendConsoleMsg(currentPeer, "`oWorld owner has turned `2on `othe magplant!");
								}
							}
						}
						if (btn == "takegems")
						{
							PlayerInfo* pinfo = (PlayerInfo*)peer->data;

							int netID = pinfo->netID;
							pinfo->gem = pinfo->gem + world->maggems;
							world->maggems = 0;
							Player::OnSetBux(peer, pinfo->gem, 0);

						}



						if (btn == "legendkatana") {
							((PlayerInfo*)(peer->data))->cloth_hand = 2592;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have legendary katana now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Quest step complete!!"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
							delete p.data;

							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer)) {





									bool dary = std::experimental::filesystem::exists("achievements/dary/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
									if (dary == false)
									{
										int effect = 48;
										int x = ((PlayerInfo*)(currentPeer->data))->x;
										int y = ((PlayerInfo*)(currentPeer->data))->y;
										GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), effect), x, y));

										ENetPacket* packetd = enet_packet_create(psp.data,
											psp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetd);
										GamePacket p3 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), ((PlayerInfo*)(peer->data))->displayName + " `5earned the achievement ''DARY!''!"));
										ENetPacket* packet3 = enet_packet_create(p3.data,
											p3.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet3);
										delete p3.data;

										ofstream myfile;
										myfile.open("achievements/dary/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
										myfile << "true";
										myfile.close();
									}
								}

							}
						}

						if (btn == "legenddragon11") {
							bool success = true;
							SaveShopsItemMoreTimes(1782, 1, peer, success);
							((PlayerInfo*)(peer->data))->cloth_hand = 1782;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have legendary dragon now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Got The Legendary Dragon!!!!!"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
							delete p.data;

							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer)) {
									{
										int effect = 46;
										int x = ((PlayerInfo*)(currentPeer->data))->x;
										int y = ((PlayerInfo*)(currentPeer->data))->y;
										GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), effect), x, y));

										ENetPacket* packetd = enet_packet_create(psp.data,
											psp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetd);
									}
								}
							}

						}

						if (btn == "legendwhip") {


							((PlayerInfo*)(peer->data))->cloth_hand = 6026;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have whip of truth now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Quest step complete!!"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
							delete p.data;

							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer)) {


									bool dary = std::experimental::filesystem::exists("achievements/dary/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
									if (dary == false)
									{
										int effect = 48;
										int x = ((PlayerInfo*)(currentPeer->data))->x;
										int y = ((PlayerInfo*)(currentPeer->data))->y;
										GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), effect), x, y));

										ENetPacket* packetd = enet_packet_create(psp.data,
											psp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetd);
										GamePacket p3 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), ((PlayerInfo*)(peer->data))->displayName + " `5earned the achievement ''DARY!''!"));
										ENetPacket* packet3 = enet_packet_create(p3.data,
											p3.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet3);
										delete p3.data;

										ofstream myfile;
										myfile.open("achievements/dary/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
										myfile << "true";
										myfile.close();
									}
								}
							}

						}


						if (btn == "ringforce") {
							((PlayerInfo*)(peer->data))->cloth_hand = 1874;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have Ring Of Force now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;

						}
						if (btn == "ringwinds") {
							((PlayerInfo*)(peer->data))->cloth_hand = 1876;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have Ring Of Winds now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringone") {
							((PlayerInfo*)(peer->data))->cloth_hand = 1904;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have The One Ring now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringwisdom") {
							((PlayerInfo*)(peer->data))->cloth_hand = 1996;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have Ring of Wisdom now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringwater") {
							((PlayerInfo*)(peer->data))->cloth_hand = 2970;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have Ring Of Water now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringsaving") {
							((PlayerInfo*)(peer->data))->cloth_hand = 3140;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have Ring Of Savings now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringsmithing") {
							((PlayerInfo*)(peer->data))->cloth_hand = 3174;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have Ring Of Smithing now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringshrinking") {
							((PlayerInfo*)(peer->data))->cloth_hand = 6028;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have Ring Of Shrinking now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringnature") {
							((PlayerInfo*)(peer->data))->cloth_hand = 6846;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have Ring of Nature now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "geminiring") {
							((PlayerInfo*)(peer->data))->cloth_hand = 1986;
							sendState(peer);

							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							sendClothes(peer);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You have Gemini Ring now!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "wban")
						{
							if (((PlayerInfo*)(peer->data))->haveGrowId && ((PlayerInfo*)(peer->data))->rawName == getPlyersWorld(peer)->owner || ((PlayerInfo*)(peer->data))->adminLevel > 333)
							{
								ENetPeer* currentPeerp;

								for (currentPeerp = server->peers;
									currentPeerp < &server->peers[server->peerCount];
									++currentPeerp)
								{
									if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
										continue;



									string name = ((PlayerInfo*)(peer->data))->displayName;
									string kickname = ((PlayerInfo*)(peer->data))->lastInfoname;
									//string kickname = ((PlayerInfo*)(peer->data))->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `o" + name + " `4world bans " + "`o" + kickname + " from `w" + world->name + "`o!"));
									string text = "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);

									if (isHere(peer, currentPeerp))
									{
										if (((PlayerInfo*)(currentPeerp->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo) // if last wrench
										{
											if (((PlayerInfo*)(peer->data))->adminLevel < 999) {
												if (((PlayerInfo*)(currentPeerp->data))->adminLevel > 333 && ((PlayerInfo*)(currentPeerp->data))->isNicked == false) {
													GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You can't ban an Moderator/Owner"));
													ENetPacket* packet7 = enet_packet_create(p7.data,
														p7.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet7);
													delete p7.data;
													break;
												}
												else {
													namespace fs = std::experimental::filesystem;

													if (!fs::is_directory("worldbans/" + getPlyersWorld(peer)->name) || !fs::exists("worldbans/" + getPlyersWorld(peer)->name)) {
														fs::create_directory("worldbans/" + getPlyersWorld(peer)->name);

														std::ofstream outfile("worldbans/" + getPlyersWorld(peer)->name + "/" + ((PlayerInfo*)(currentPeerp->data))->rawName);

														outfile << "worldbanned by: " + ((PlayerInfo*)(peer->data))->rawName;

														outfile.close();
													}
													else
													{
														std::ofstream outfile("worldbans/" + getPlyersWorld(peer)->name + "/" + ((PlayerInfo*)(currentPeerp->data))->rawName);

														outfile << "worldbanned by: " + ((PlayerInfo*)(peer->data))->rawName;

														outfile.close();
													}

													sendPlayerLeave(currentPeerp, (PlayerInfo*)(currentPeerp->data));
													sendWorldOffers(currentPeerp);


													((PlayerInfo*)(currentPeerp->data))->currentWorld = "EXIT";

												}
											}
											else {
												namespace fs = std::experimental::filesystem;

												if (!fs::is_directory("worldbans/" + getPlyersWorld(peer)->name) || !fs::exists("worldbans/" + getPlyersWorld(peer)->name)) {
													fs::create_directory("worldbans/" + getPlyersWorld(peer)->name);

													std::ofstream outfile("worldbans/" + getPlyersWorld(peer)->name + "/" + ((PlayerInfo*)(currentPeerp->data))->rawName);

													outfile << "worldbanned by: " + ((PlayerInfo*)(peer->data))->rawName;

													outfile.close();
												}
												else
												{
													std::ofstream outfile("worldbans/" + getPlyersWorld(peer)->name + "/" + ((PlayerInfo*)(currentPeerp->data))->rawName);

													outfile << "worldbanned by: " + ((PlayerInfo*)(peer->data))->rawName;

													outfile.close();
												}

												sendPlayerLeave(currentPeerp, (PlayerInfo*)(currentPeerp->data));
												sendWorldOffers(currentPeerp);


												((PlayerInfo*)(currentPeerp->data))->currentWorld = "EXIT";
											}
										}
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);



										enet_peer_send(currentPeerp, 0, packetsou);
										enet_peer_send(currentPeerp, 0, packet);
										delete data;
										delete p.data;

									}

								}
							}
						}
						if (btn == "autoban")
						{
							// Warning from `4System``: You've been `4BANNED`` from `wGrowtopia`` for 60 days``


						}
						if (btn == "kick")
						{
							if (((PlayerInfo*)(peer->data))->rawName == getPlyersWorld(peer)->owner || ((PlayerInfo*)(peer->data))->adminLevel > 333)
							{
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;



									string name = ((PlayerInfo*)(peer->data))->displayName;
									string kickname = ((PlayerInfo*)(peer->data))->lastInfoname;
									//string kickname = ((PlayerInfo*)(peer->data))->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `4kicks " + "`w" + kickname));
									string text = "action|play_sfx\nfile|audio/male_scream.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);

									if (isHere(peer, currentPeer))
									{
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);


										enet_peer_send(currentPeer, 0, packetsou);
										enet_peer_send(currentPeer, 0, packet);


										int x = 3040;
										int y = 736;


										for (int i = 0; i < world->width * world->height; i++)
										{
											if (world->items[i].foreground == 6) {
												x = (i % world->width) * 32;
												y = (i / world->width) * 32;
											}
										}
										GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), x, y));
										memcpy(p2.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);

										if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo)
										{
											enet_peer_send(currentPeer, 0, packet2);
										}



										delete p2.data;
										delete p.data;
										delete data;

									}

								}
							}
						}

						if (btn == "pull")
						{
							if (((PlayerInfo*)(peer->data))->rawName == getPlyersWorld(peer)->owner || ((PlayerInfo*)(peer->data))->adminLevel > 333)
							{
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									string name = ((PlayerInfo*)(currentPeer->data))->rawName;
									int pullX = ((PlayerInfo*)(peer->data))->x;
									int pullY = ((PlayerInfo*)(peer->data))->y;


									if (name == ((PlayerInfo*)(peer->data))->lastInfo)
									{
										if (isHere(peer, currentPeer) && getPlyersWorld(peer)->name != "EXIT")
										{
											string name = ((PlayerInfo*)(peer->data))->displayName;
											string pullname = ((PlayerInfo*)(currentPeer->data))->displayName;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `5pulls " + "`w" + pullname));
											string text = "action|play_sfx\nfile|audio/object_spawn.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);

											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(currentPeer, 0, packet);
											enet_peer_send(peer, 0, packet);




											ENetPacket* packetsou = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);


											enet_peer_send(currentPeer, 0, packetsou);
											enet_peer_send(peer, 0, packetsou);

											GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), pullX, pullY));
											memcpy(p2.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(currentPeer, 0, packet2);

											GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You have been pulled by " + ((PlayerInfo*)(peer->data))->displayName));
											//memcpy(p2.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
											ENetPacket* packetto = enet_packet_create(pto.data,
												pto.len,
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(currentPeer, 0, packetto);

											delete pto.data;
											delete p2.data;
											delete p.data;

										}
									}
								}
							}






						}
						if (btn == "clearworld") {
							if (((PlayerInfo*)(peer->data))->gem > 5000) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 5000;
								savejson(peer);
								GamePacket p5x = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5x = enet_packet_create(p5x.data,
									p5x.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5x);
								delete p5x.data;
								int x = 0;
								int y = 0;
								if (((PlayerInfo*)(peer->data))->currentWorld != "EXIT") {
									TileExtra data;
									data.packetType = 0x5;
									data.characterState = 8;
									data.charStat = 8;
									data.blockid = 0;
									data.backgroundid = 0;
									data.visual = 0x00010000;

									for (int i = 0; i < world->width * world->height; i++)
									{
										if (world->items[i].foreground != 6 && world->items[i].foreground != 8 && getItemDef(world->items[i].foreground).blockType != BlockTypes::LOCK) {


											world->items[i].foreground = 0;
											world->items[i].background = 0;
											x = (i % world->width);
											y = (i / world->width);
											data.punchX = x;
											data.punchY = y;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeer))
												{
													SendPacketRaw2(192, packBlockVisual222(&data), 100, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
												}
											}
										}
									}

									Player::OnConsoleMessage(peer, "`oUsed `4Growtale's `2Fast-Realtime-Clear system`w (like real gt)!``");
								}
							}
							else {
								Player::OnConsoleMessage(peer, "`oYou don't have enough gem to clear worlds!``");
							}
						}
						int x = ((PlayerMoving*)(peer->data))->punchX;
						int y = ((PlayerMoving*)(peer->data))->punchY;
						int causedBy = ((PlayerMoving*)(peer->data))->netID;
						int tile = ((PlayerMoving*)(peer->data))->plantingTree;
						if (btn == "joinguildzzz") {
							((PlayerInfo*)(peer->data))->guild = ((PlayerInfo*)(peer->data))->guildlast;
							((PlayerInfo*)(peer->data))->isinvited = false;
							((PlayerInfo*)(peer->data))->joinguild = true;

							string fixedguildName = PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild);

							/*
							std::ifstream ifs2("guilds/" + fixedguildName + ".json");
							if (ifs2.fail()) {
								ifs2.close();
							}
							if (ifs2.is_open()) {

							}
							json j2;
							ifs2 >> j2;*/

							guildmem.push_back(((PlayerInfo*)(peer->data))->rawName);

						}

						if (btn == "inviteguildbutton") {
							if (((PlayerInfo*)(peer->data))->guild != "") {
								int number = ((PlayerInfo*)(peer->data))->guildmatelist.size();
								if (number > 9) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `3GUILD ERROR: `oYou already have `450 `oGuild members! Please remove some before adding new ones!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo) {
											string name = ((PlayerInfo*)(currentPeer->data))->rawName;
											if (((PlayerInfo*)(currentPeer->data))->guild != "") {
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `3GUILD ERROR: `w" + ((PlayerInfo*)(currentPeer->data))->displayName + "`o is already in a Guild!"));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet);
												delete p.data;
											}
											else {
												GamePacket p4 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`5[`wGuild request sent to `2" + ((PlayerInfo*)(currentPeer->data))->displayName + "`5]"));
												ENetPacket* packet4 = enet_packet_create(p4.data,
													p4.len,
													ENET_PACKET_FLAG_RELIABLE);

												enet_peer_send(peer, 0, packet4);
												delete p4.data;
												string text = "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0\n";
												BYTE* data = new BYTE[5 + text.length()];
												BYTE zero = 0;
												int type = 3;
												memcpy(data, &type, 4);
												memcpy(data + 4, text.c_str(), text.length());
												memcpy(data + 4 + text.length(), &zero, 1);
												ENetPacket* packet2 = enet_packet_create(data,
													5 + text.length(),
													ENET_PACKET_FLAG_RELIABLE);

												enet_peer_send(currentPeer, 0, packet2);
												delete data;
												((PlayerInfo*)(currentPeer->data))->guildlast = ((PlayerInfo*)(peer->data))->guild;
												((PlayerInfo*)(currentPeer->data))->isinvited = true;
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `5[GUILD REQUEST] `oYou've been invited to join `2" + ((PlayerInfo*)(peer->data))->guild + "`o by `w" + ((PlayerInfo*)(peer->data))->displayName + "`o! To accept, `wwrench yourself `oand then choose `2Join " + ((PlayerInfo*)(peer->data))->guild + "`o."));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet);
												delete p.data;
											}
										}
									}
								}
							}
							else {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `5[GUILD ERROR] `oYou must be in a Guild as a Elder or higher in order to invite players!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (btn == "joinguild") {
							vector<string> gmembers;
							string guildname = PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guildlast);
							if (guildname != "") {
								std::ifstream ifff("guilds/" + guildname + ".json");
								if (ifff.fail()) {
									ifff.close();
									cout << "[!] Failed loading guilds/" + guildname + ".json! From " + ((PlayerInfo*)(peer->data))->displayName + "." << endl;
								}
								json j;
								ifff >> j;

								for (int i = 0; i < j["Member"].size(); i++) {
									gmembers.push_back(j["Member"][i]);
								}

								ifff.close();

								int membercount = gmembers.size();

								if (membercount > 14) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `5[GUILD ALERT] `oThat guild is already full!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else {
									((PlayerInfo*)(peer->data))->guild = ((PlayerInfo*)(peer->data))->guildlast;
									((PlayerInfo*)(peer->data))->guildlast = "";
									((PlayerInfo*)(peer->data))->isinvited = false;
									((PlayerInfo*)(peer->data))->joinguild = true;
									updateInvis(peer);

									std::ifstream iffff("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
									if (iffff.fail()) {
										iffff.close();
										continue;
									}
									if (iffff.is_open()) {
									}
									json x;
									iffff >> x; //load


									x["guild"] = ((PlayerInfo*)(peer->data))->guild; //edit
									x["joinguild"] = ((PlayerInfo*)(peer->data))->joinguild;

									std::ofstream ox("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json"); //save
									if (!ox.is_open()) {
										cout << GetLastError() << endl;
										_getch();
									}
									ox << x << std::endl;
									std::ifstream ifff("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
									if (ifff.fail()) {
										ifff.close();
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
									}
									if (ifff.is_open()) {
									}
									json j;
									ifff >> j; //load

									vector<string> gmlist;

									for (int i = 0; i < j["Member"].size(); i++) {
										gmlist.push_back(j["Member"][i]);
									}

									gmlist.push_back(((PlayerInfo*)(peer->data))->rawName);

									j["Member"] = gmlist; //edit

									std::ofstream o("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
									if (!o.is_open()) {
										cout << GetLastError() << endl;
										_getch();
									}

									o << j << std::endl;
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (((PlayerInfo*)(currentPeer->data))->guild == ((PlayerInfo*)(peer->data))->guild)
										{
											updateGuild(peer);
											updateGuild(currentPeer);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `5[GUILD ALERT] `2" + ((PlayerInfo*)(peer->data))->displayName + " `ojoined the guild!"));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											delete p.data;
											updateInvis(peer);
										}
									}
								}
							}
						}


						if (btn == "showguild") {
							string onlinegmlist = "";
							string grole = "";
							int onlinecount = 0;
							string guildname = PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild);
							if (guildname != "") {
								std::ifstream ifff("guilds/" + guildname + ".json");
								if (ifff.fail()) {
									ifff.close();
									cout << "[!] Failed loading guilds/" + guildname + ".json! From " + ((PlayerInfo*)(peer->data))->displayName + "." << endl;
									((PlayerInfo*)(peer->data))->guild = "";

								}
								json j;
								ifff >> j;

								int gfbg, gffg, guildlvl, guildxp;

								string gstatement, gleader;

								vector<string> gmembers;

								gfbg = j["backgroundflag"];
								gffg = j["foregroundflag"];
								gstatement = j["GuildStatement"].get<string>();
								gleader = j["Leader"].get<string>();
								guildlvl = j["GuildLevel"];
								guildxp = j["GuildExp"];
								for (int i = 0; i < j["Member"].size(); i++) {
									gmembers.push_back(j["Member"][i]);
								}
								((PlayerInfo*)(peer->data))->guildlevel = guildlvl;
								((PlayerInfo*)(peer->data))->guildexp = guildxp;

								((PlayerInfo*)(peer->data))->guildBg = gfbg;
								((PlayerInfo*)(peer->data))->guildFg = gffg;
								((PlayerInfo*)(peer->data))->guildStatement = gstatement;
								((PlayerInfo*)(peer->data))->guildLeader = gleader;
								((PlayerInfo*)(peer->data))->guildMembers = gmembers;

								ifff.close();
							}
							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								string name = ((PlayerInfo*)(currentPeer->data))->rawName;
								if (find(((PlayerInfo*)(peer->data))->guildMembers.begin(), ((PlayerInfo*)(peer->data))->guildMembers.end(), name) != ((PlayerInfo*)(peer->data))->guildMembers.end()) {
									if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
										onlinegmlist += "\nadd_button|onlinegm_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->displayName + " `e(GL)``|0|0|";
										onlinecount++;
									}
									else {
										onlinegmlist += "\nadd_button|onlinegm_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->displayName + " " + grole + "``|0|0|";
										onlinecount++;
									}
								}
							}
							if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oGuild Name : " + ((PlayerInfo*)(peer->data))->guild + "``|\nadd_textbox|`oStatement : " + ((PlayerInfo*)(peer->data))->guildStatement + "``|\nadd_textbox|`oGuild size: " + std::to_string(((PlayerInfo*)(peer->data))->guildMembers.size()) + "/15 members|\nadd_textbox|`oGuild Level : " + std::to_string(((PlayerInfo*)(peer->data))->guildlevel) + "|\nadd_textbox|`oGuild Exp : " + std::to_string(((PlayerInfo*)(peer->data))->guildexp) + "|\n\nadd_spacer|small|\nadd_button|leavefromguild|`4Abandon Guild``|0|0|\nadd_button|guildoffline|`wShow offline too``|0|0|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|editguildstatement|`wEdit Guild Statement``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(((PlayerInfo*)(peer->data))->guildMembers.size()) + " `wGuild Members Online|" + onlinegmlist + "\n\nadd_spacer|small|\nadd_button|backsocialportal|`wBack``|0|0|\nadd_button||`wClose``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oGuild Name : " + ((PlayerInfo*)(peer->data))->guild + "``|\nadd_textbox|`oStatement : " + ((PlayerInfo*)(peer->data))->guildStatement + "``|\nadd_textbox|`oGuild size: " + std::to_string(((PlayerInfo*)(peer->data))->guildMembers.size()) + "/15 members|\nadd_textbox|`oGuild Level : " + std::to_string(((PlayerInfo*)(peer->data))->guildlevel) + "|\nadd_textbox|`oGuild Exp : " + std::to_string(((PlayerInfo*)(peer->data))->guildexp) + "|\n\nadd_spacer|small|\nadd_button|leavefromguild|`4Leave from guild``|0|0|\nadd_button|guildoffline|`wShow offline too``|0|0|\nadd_button|goguildhome|`wGo to Guild Home``|0|0| \n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(((PlayerInfo*)(peer->data))->guildMembers.size()) + " `wGuild Members Online|" + onlinegmlist + "\n\nadd_spacer|small|\nadd_button|backsocialportal|`wBack``|0|0|\nadd_button||`wClose``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn.substr(0, 9) == "onlinegm_") {
							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (((PlayerInfo*)(currentPeer->data))->rawName == btn.substr(9, cch.length() - 9 - 1)) {
									((PlayerInfo*)(peer->data))->lastgmworld = ((PlayerInfo*)(currentPeer->data))->currentWorld;
									((PlayerInfo*)(peer->data))->lastgmname = ((PlayerInfo*)(currentPeer->data))->displayName;
									((PlayerInfo*)(peer->data))->lastgm = ((PlayerInfo*)(currentPeer->data))->rawName;
								}
							}
							if (btn.substr(9, cch.length() - 9 - 1) == ((PlayerInfo*)(peer->data))->rawName) {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|This is you!|\n\nadd_spacer|small|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else {
								if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgmname + " is `2online `onow in the world `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\n\nadd_spacer|small| \nadd_button|removegmonline|Kick from guild|0|0|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else {
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgmname + " is `2online `onow in the world `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\n\nadd_spacer|small| \nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "showguildzz") {

							string fg, bg, guildname, guildleader, gstatement;
							int guildlvl, guildexp;
							string guildName = ((PlayerInfo*)(peer->data))->guild;
							std::ifstream ifs("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
							if (ifs.is_open()) {
								json j;
								ifs >> j;

								gstatement = j["GuildStatement"].get<string>();
								fg = j["foregroundflag"].get<string>();
								bg = j["backgroundflag"].get<string>();
								guildname = j["GuildName"].get<string>();
								guildlvl = j["GuildLevel"];
								guildexp = j["GuildExp"];
								guildleader = j["Leader"].get<string>();

								vector<string> gmlists;

								for (int i = 0; i < j["Member"].size(); i++) {
									gmlists.push_back(j["Member"][i]);
								}
								((PlayerInfo*)(peer->data))->guildmatelist = gmlists;

							}

							int block = stoi(fg);
							int wallpaper = stoi(bg);
							int flag = ((65536 * wallpaper) + block);

							string onlinefrnlist = "";
							int onlinecount = 0;
							int totalcount = ((PlayerInfo*)(peer->data))->guildmatelist.size();
							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;

								string name = ((PlayerInfo*)(currentPeer->data))->rawName;
								if (find(((PlayerInfo*)(peer->data))->guildmatelist.begin(), ((PlayerInfo*)(peer->data))->guildmatelist.end(), name) != ((PlayerInfo*)(peer->data))->guildmatelist.end()) {
									if (((PlayerInfo*)(currentPeer->data))->rawName == guildleader) {
										onlinefrnlist += "\nadd_button|onlinefrns_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->displayName + " `e(GL)``|0|0|";
										onlinecount++;
									}
									else {
										onlinefrnlist += "\nadd_button|onlinefrns_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->displayName + "``|0|0|";
										onlinecount++;
									}
								}

							}
							if (guildleader == ((PlayerInfo*)(peer->data))->rawName) {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + bg + "|" + fg + "|1.0|0|\nadd_label|small|" + gstatement + "|left|4|\n\nadd_spacer|small|\nadd_textbox|Guild size: " + std::to_string(totalcount) + "/10 members``|\nadd_textbox|`oGuild Level : " + std::to_string(guildlvl) + "|\nadd_textbox|`oGuild Exp : " + std::to_string(guildexp) + "|\nadd_textbox|Guild Name : " + guildname + "|\nadd_textbox|`oGuild Leader : " + guildleader + "|\nadd_spacer|small|\nadd_button|guildoffline|`wShow offline too``|0|0|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|editguildstatement|`wEdit Guild Statement``|0|0|\nadd_spacer|big|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wGuild Members Online|\nadd_spacer|small|" + onlinefrnlist + "\nadd_spacer|small|\nadd_button|backsocialportal|`wBack|\nadd_button|cl0se|`wClose|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + bg + "|" + fg + "|1.0|0|\nadd_label|small|" + gstatement + "|left|4|\n\nadd_spacer|small|\nadd_textbox|Guild size: " + std::to_string(totalcount) + "/10 members``|\nadd_textbox|`oGuild Level : " + std::to_string(guildlvl) + "|\nadd_textbox|`oGuild Exp : " + std::to_string(guildexp) + "|\nadd_textbox|Guild Name : " + guildname + "|\nadd_textbox|`oGuild Leader : " + guildleader + "|\nadd_spacer|small|\nadd_button|guildoffline|`wShow offline too``|0|0|\nadd_button|goguildhome|`wGo to Guild Home``|0|0| \nadd_spacer|big|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wGuild Members Online|\nadd_spacer|small|" + onlinefrnlist + "\nadd_spacer|small|\nadd_button|backsocialportal|`wBack|\nadd_button|cl0se|`wClose|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;

							}

						}
						if (btn == "confirmcreateguild") {
							if (((PlayerInfo*)(peer->data))->gem > 249000)
							{
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 250000;
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetpp);
								delete pp.data;
								GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You created guild!"));
								//memcpy(p2.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
								ENetPacket* packetto = enet_packet_create(pto.data,
									pto.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetto);
								delete pto.data;
								string guildName = ((PlayerInfo*)(peer->data))->createGuildName;
								string guildStatement = ((PlayerInfo*)(peer->data))->createGuildStatement;
								string fixedguildName = PlayerDB::getProperName(guildName);
								string guildFlagbg = ((PlayerInfo*)(peer->data))->createGuildFlagBg;
								string guildFlagfg = ((PlayerInfo*)(peer->data))->createGuildFlagFg;

								//guildmem.push_back(((PlayerInfo*)(peer->data))->rawName);

								std::ofstream o("guilds/" + fixedguildName + ".json");
								if (!o.is_open()) {
									cout << GetLastError() << endl;
									_getch();
								}
								json j;
								vector<string> test1s;
								vector<string>test2s;

								((PlayerInfo*)(peer->data))->guildMembers.push_back(((PlayerInfo*)(peer->data))->rawName);
								j["GuildName"] = ((PlayerInfo*)(peer->data))->createGuildName;
								j["GuildRawName"] = fixedguildName;
								j["GuildStatement"] = ((PlayerInfo*)(peer->data))->createGuildStatement;
								j["Leader"] = ((PlayerInfo*)(peer->data))->rawName;
								j["Co-Leader"] = test1s;
								j["Elder-Leader"] = test2s;
								j["Member"] = ((PlayerInfo*)(peer->data))->guildMembers;
								j["GuildLevel"] = 0;
								j["GuildExp"] = 0;
								j["GuildWorld"] = ((PlayerInfo*)(peer->data))->currentWorld;
								j["backgroundflag"] = stoi(((PlayerInfo*)(peer->data))->createGuildFlagBg);
								j["foregroundflag"] = stoi(((PlayerInfo*)(peer->data))->createGuildFlagFg);
								o << j << std::endl;

								updateInvis(peer);

								((PlayerInfo*)(peer->data))->guild = guildName;
								((PlayerInfo*)(peer->data))->joinguild = true;
								std::ifstream ifff("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");


								if (ifff.fail()) {
									ifff.close();


								}
								if (ifff.is_open()) {
								}
								json x;
								ifff >> x; //load

								x["guild"] = ((PlayerInfo*)(peer->data))->guild;
								x["joinguild"] = ((PlayerInfo*)(peer->data))->joinguild; //edit

								std::ofstream y("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json"); //save
								if (!y.is_open()) {
									cout << GetLastError() << endl;
									_getch();
								}

								y << x << std::endl;
							}
							else {
								GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You don't have enough gems."));
								//memcpy(p2.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
								ENetPacket* packetto = enet_packet_create(pto.data,
									pto.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetto);
								delete pto.data;
							}
						}
						if (btn == "leavefromguild")
						{
							if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`8Are you sure?``|left|6204|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oAfter `4Abandon `ofrom the guild, all guild's members will be `4kicked out `oand the guild will be `4destroyed`o!|left|8|\nadd_spacer|small|\nadd_button|confirmguildleaderleave|`4Yes, Abandon!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}


							else {



								std::ifstream ifff("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
								if (ifff.fail()) {
									ifff.close();
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								if (ifff.is_open()) {
								}
								json j;
								ifff >> j; //load

								vector<string> gmlist;

								for (int i = 0; i < j["Member"].size(); i++) {
									gmlist.push_back(j["Member"][i]);
								}

								gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), ((PlayerInfo*)(peer->data))->rawName), gmlist.end());


								j["Member"] = gmlist; //edit


								std::ofstream o("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
								if (!o.is_open()) {
									cout << GetLastError() << endl;
									_getch();
								}

								o << j << std::endl;



								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;

									if (((PlayerInfo*)(currentPeer->data))->guild == ((PlayerInfo*)(peer->data))->guild) {
										updateGuild(currentPeer);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `5[GUILD ALERT] `2" + ((PlayerInfo*)(peer->data))->rawName + "`o has left the guild!"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet);
										delete p.data;
										updateInvis(currentPeer);
									}

								}



								((PlayerInfo*)(peer->data))->guildBg = 0;
								((PlayerInfo*)(peer->data))->guildFg = 0;
								((PlayerInfo*)(peer->data))->guildLeader = "";
								((PlayerInfo*)(peer->data))->guild = "";
								((PlayerInfo*)(peer->data))->guildStatement = "";
								//((PlayerInfo*)(currentPeer->data))->guildRole = 0;
								((PlayerInfo*)(peer->data))->guildlast = "";
								((PlayerInfo*)(peer->data))->lastgm = "";
								((PlayerInfo*)(peer->data))->lastgmname = "";
								((PlayerInfo*)(peer->data))->joinguild = false;
								((PlayerInfo*)(peer->data))->lastgmworld = "";
								((PlayerInfo*)(peer->data))->guildMembers.clear();
								updateInvis(peer);


								std::ifstream iffff2("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");

								json jj2;

								if (iffff2.fail()) {
									iffff2.close();
									continue;
								}
								if (iffff2.is_open()) {


								}

								iffff2 >> jj2; //load

								std::ofstream oo2("players/" + ((PlayerInfo*)(peer->data))->rawName + ".json");
								if (!oo2.is_open()) {
									cout << GetLastError() << endl;
									_getch();
								}
								jj2["guild"] = "";
								jj2["joinguild"] = false;
								oo2 << jj2 << std::endl;




							}
						}

						if (btn == "confirmguildleaderleave")
						{
							//Player::OnConsoleMessage(peer, "Abandoned");

							std::ifstream ifff("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
							if (ifff.fail()) {
								ifff.close();
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete ps.data;
								continue;
							}
							if (ifff.is_open()) {
							}
							json j;
							ifff >> j; //load


							vector<string> gmlist;

							for (int i = 0; i < j["Member"].size(); i++) {
								gmlist.push_back(j["Member"][i]);
							}





							const int result = remove(("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json").c_str());
							if (result == 0) {
								cout << ((PlayerInfo*)(peer->data))->rawName + " abandoned from the guild" << endl;
							}
							else {
								cout << "[!] ERROR deleting file, when " << ((PlayerInfo*)(peer->data))->rawName + " abandoned from the guild" << endl;
								cout << "[!] His guild is: guilds/" << PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) << ".json" << endl;
								cout << (("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json").c_str());
							}

							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (find(gmlist.begin(), gmlist.end(), ((PlayerInfo*)(currentPeer->data))->rawName) != gmlist.end()) {

									((PlayerInfo*)(currentPeer->data))->guildBg = 0;
									((PlayerInfo*)(currentPeer->data))->guildFg = 0;
									((PlayerInfo*)(currentPeer->data))->guildLeader = "";
									((PlayerInfo*)(currentPeer->data))->guild = "";
									((PlayerInfo*)(currentPeer->data))->guildStatement = "";
									//((PlayerInfo*)(currentPeer->data))->guildRole = 0;
									((PlayerInfo*)(currentPeer->data))->guildlast = "";
									((PlayerInfo*)(currentPeer->data))->lastgm = "";
									((PlayerInfo*)(currentPeer->data))->lastgmname = "";
									((PlayerInfo*)(currentPeer->data))->joinguild = false;
									((PlayerInfo*)(currentPeer->data))->lastgmworld = "";
									((PlayerInfo*)(currentPeer->data))->guildMembers.clear();
									updateInvis(currentPeer);

									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `5[GUILD ALERT] `4Unfortunately, `obut guild's leader `4abandoned `ofrom the guild and you were `4kicked out`o."));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(currentPeer, 0, packet);
									delete p.data;
								}
							}

							for (int i = 0; i < gmlist.size(); i++)
							{
								std::ifstream iffff2("players/" + gmlist[i] + ".json");

								json jj2;

								if (iffff2.fail()) {
									iffff2.close();
									continue;
								}
								if (iffff2.is_open()) {


								}

								iffff2 >> jj2; //load

								std::ofstream oo2("players/" + gmlist[i] + ".json");
								if (!oo2.is_open()) {
									cout << GetLastError() << endl;
									_getch();
								}
								jj2["guild"] = "";
								jj2["joinguild"] = false;
								oo2 << jj2 << std::endl;
							}

						}

						if (btn == "guildoffline") {


							string onlinegmlist = "";
							string offname, offlinegm;
							string grole = "";
							int onlinecount = 0;
							int totalcount = ((PlayerInfo*)(peer->data))->guildMembers.size();

							string gstatement = ((PlayerInfo*)(peer->data))->guildLeader;
							string bg = std::to_string(((PlayerInfo*)(peer->data))->guildBg);
							string fg = std::to_string(((PlayerInfo*)(peer->data))->guildFg);
							string guildname = ((PlayerInfo*)(peer->data))->guild;
							string guildleader = ((PlayerInfo*)(peer->data))->guildLeader;
							string guildlvl = "0";
							string guildexp = "0";
							ENetPeer* currentPeer;
							vector<string>offlineguild = ((PlayerInfo*)(peer->data))->guildMembers;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								string name = ((PlayerInfo*)(currentPeer->data))->rawName;
								if (find(((PlayerInfo*)(peer->data))->guildMembers.begin(), ((PlayerInfo*)(peer->data))->guildMembers.end(), name) != ((PlayerInfo*)(peer->data))->guildMembers.end()) {
									if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
										onlinegmlist += "\nadd_button|onlinegm_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->displayName + " `e(GL)``|0|0|";
										onlinecount++;
									}
									else {
										onlinegmlist += "\nadd_button|onlinegm_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->displayName + " " + grole + "``|0|0|";
										onlinecount++;
										offlineguild.erase(std::remove(offlineguild.begin(), offlineguild.end(), name), offlineguild.end());
									}
								}
							}
							for (std::vector<string>::const_iterator i = offlineguild.begin(); i != offlineguild.end(); ++i) {
								offname = *i;
								offlinegm += "\nadd_button|offlinegm_" + offname + "|`4OFFLINE: `o" + offname + "``|0|0|";

							}
							/*if (onlinecount > 0) {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|\n\nadd_spacer|small|\nadd_textbox|All of your friend are online!|\n\nadd_spacer|small| \n\nadd_spacer|small| \nadd_button|frnoption|`oFriend Options``|0|0|\nadd_button|backonlinelist|Back``|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
								ENetPacket * packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else {*/
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + bg + "|" + fg + "|1.0|0|\nadd_label|small|" + gstatement + "|left|4|\n\nadd_spacer|small|\nadd_textbox|Guild size: " + std::to_string(totalcount) + "/10 members``|\nadd_textbox|`oGuild Level : " + guildlvl + "|\nadd_textbox|`oGuild Exp : " + guildexp + "|\nadd_textbox|Guild Name : " + guildname + "|\nadd_textbox|`oGuild Leader : " + guildleader + "|\nadd_spacer|small| \nadd_button|goguildhome|`wGo to Guild Home``|0|0| \nadd_spacer|big|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wGuild Members Online|\nadd_spacer|small|" + offlinegm + "\nadd_spacer|small|\nadd_button|showguild|`wBack|\nadd_button|cl0se|`wClose|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;

						}
						if (btn == "goguildhome") {
							string gworld;
							string guildName = ((PlayerInfo*)(peer->data))->guild;
							std::ifstream ifs("guilds/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
							if (ifs.is_open()) {
								json j;
								ifs >> j;

								gworld = j["GuildWorld"].get<string>();

							}
							sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
							joinWorld(peer, gworld, 0, 0);
						}
						if (btn == "createguildinfo") {
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild|left|5814|\nadd_label|small|`oWelcome to Grow Guilds where you can create a Guild! With a Guild you can level up the Guild to add more members.``|left|4|\n\nadd_spacer|small|\nadd_textbox|`oYou will be charged `6250,000 `oGems.``|\nadd_spacer|small|\nadd_button|createguild|`oCreate a Guild``|0|0|\nadd_button|backsocialportal|Back|0|0|\nend_dialog||Close||\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;
							/*GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `wThis option will be added soon!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;*/
						}

						if (btn == "createguild") {
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation``|left|5814|  \nadd_spacer|small|\nadd_text_input|gname|Guild Name: ||20|\nadd_text_input|gstatement|Guild Statement: ||100|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``||5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``||5|\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\nadd_spacer|small|\nadd_textbox|`8Remember`o: A guild can only be created in a world owned by you and locked with a `5World Lock`o!|\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\nadd_spacer|small|\nend_dialog|guildconfirm|Cancel|Create Guild|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "acceptaccess")
						{
							((PlayerInfo*)(peer->data))->displayName = "`^" + ((PlayerInfo*)(peer->data))->displayName;
							world->acclist.push_back(((PlayerInfo*)(peer->data))->rawName);
							GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), "`^" + ((PlayerInfo*)(peer->data))->rawName));
							memcpy(p3.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
							ENetPacket* packet3 = enet_packet_create(p3.data,
								p3.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet3);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `^" + ((PlayerInfo*)(peer->data))->rawName + " `owas given access to world lock."));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							ENetPeer* currentPeerz;
							for (currentPeerz = server->peers;
								currentPeerz < &server->peers[server->peerCount];
								++currentPeerz)
							{
								if (currentPeerz->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeerz))
								{
									enet_peer_send(currentPeerz, 0, packet);
								}
							}
							delete p.data;
							delete p3.data;
							((PlayerInfo*)(peer->data))->isAccess == false;
							for (int i = 0; i < world->width * world->height; i++)
							{
								int xSize = world->width;
								int ySize = world->height;

								if (world->items[i].foreground == 242) {

									int x = i % xSize;
									int y = i / xSize;
									uint32_t amount = 1;
									uint32_t admins[1];
									admins[0] = ((PlayerInfo*)(peer->data))->netID;
									sendLock(peer, x, y, 242, ((PlayerInfo*)(peer->data))->netID, amount, admins);
									//sendChatBubbleSelf(peer, ((PlayerInfo*)(peer->data))->netID, "`2Enabled green key wl.");
								}
								if (world->items[i].foreground == 1796) {

									int x = i % xSize;
									int y = i / xSize;
									uint32_t amount = 1;
									uint32_t admins[1];
									admins[0] = ((PlayerInfo*)(peer->data))->netID;
									sendLock(peer, x, y, 1796, ((PlayerInfo*)(peer->data))->netID, amount, admins);
									//sendChatBubbleSelf(peer, ((PlayerInfo*)(peer->data))->netID, "`2Enabled green key wl.");
								}
								if (world->items[i].foreground == 2408) {

									int x = i % xSize;
									int y = i / xSize;
									uint32_t amount = 1;
									uint32_t admins[1];
									admins[0] = ((PlayerInfo*)(peer->data))->netID;
									sendLock(peer, x, y, 2408, ((PlayerInfo*)(peer->data))->netID, amount, admins);
									//sendChatBubbleSelf(peer, ((PlayerInfo*)(peer->data))->netID, "`2Enabled green key wl.");
								}
								if (world->items[i].foreground == 4802) {

									int x = i % xSize;
									int y = i / xSize;
									uint32_t amount = 1;
									uint32_t admins[1];
									admins[0] = ((PlayerInfo*)(peer->data))->netID;
									sendLock(peer, x, y, 4802, ((PlayerInfo*)(peer->data))->netID, amount, admins);
									//sendChatBubbleSelf(peer, ((PlayerInfo*)(peer->data))->netID, "`2Enabled green key wl.");
								}
								if (world->items[i].foreground == 4428) {

									int x = i % xSize;
									int y = i / xSize;
									uint32_t amount = 1;
									uint32_t admins[1];
									admins[0] = ((PlayerInfo*)(peer->data))->netID;
									sendLock(peer, x, y, 4428, ((PlayerInfo*)(peer->data))->netID, amount, admins);
									//sendChatBubbleSelf(peer, ((PlayerInfo*)(peer->data))->netID, "`2Enabled green key wl.");
								}
								if (world->items[i].foreground == 5260) {

									int x = i % xSize;
									int y = i / xSize;
									uint32_t amount = 1;
									uint32_t admins[1];
									admins[0] = ((PlayerInfo*)(peer->data))->netID;
									sendLock(peer, x, y, 5260, ((PlayerInfo*)(peer->data))->netID, amount, admins);
									//sendChatBubbleSelf(peer, ((PlayerInfo*)(peer->data))->netID, "`2Enabled green key wl.");
								}
								if (world->items[i].foreground == 8470) {

									int x = i % xSize;
									int y = i / xSize;
									uint32_t amount = 1;
									uint32_t admins[1];
									admins[0] = ((PlayerInfo*)(peer->data))->netID;
									sendLock(peer, x, y, 5260, ((PlayerInfo*)(peer->data))->netID, amount, admins);
									//sendChatBubbleSelf(peer, ((PlayerInfo*)(peer->data))->netID, "`2Enabled green key wl.");
								}
								if (world->items[i].foreground == 7188) {

									int x = i % xSize;
									int y = i / xSize;
									uint32_t amount = 1;
									uint32_t admins[1];
									admins[0] = ((PlayerInfo*)(peer->data))->netID;
									sendLock(peer, x, y, 7188, ((PlayerInfo*)(peer->data))->netID, amount, admins);
									//sendChatBubbleSelf(peer, ((PlayerInfo*)(peer->data))->netID, "`2Enabled green key wl.");
								}
							}

						}
						if (btn == "backonlinelist") {

							string onlinefrnlist = "";
							int onlinecount = 0;
							int totalcount = ((PlayerInfo*)(peer->data))->friendinfo.size();
							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;

								string name = ((PlayerInfo*)(currentPeer->data))->rawName;
								if (find(((PlayerInfo*)(peer->data))->friendinfo.begin(), ((PlayerInfo*)(peer->data))->friendinfo.end(), name) != ((PlayerInfo*)(peer->data))->friendinfo.end()) {
									onlinefrnlist += "\nadd_button|onlinefrns_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->tankIDName + "``|0|0|";
									onlinecount++;

								}

							}
							if (totalcount == 0) {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_label|small|`1SOON|left|4|\n\nadd_spacer|small|\nadd_button||`5Close``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else if (onlinecount == 0) {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|\nadd_label|small|`oNone of your friends are currently online.``|left|4|\n\nadd_spacer|small|\nadd_button|showoffline|`5Show offline``|0|0|\nadd_button||`5Close``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}

							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|" + onlinefrnlist + "\n\nadd_spacer|small|\nadd_button|showoffline|`5Show offline``|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "purchasevip")
						{
							PlayerInfo* pinfo = (PlayerInfo*)peer->data;
							if (pinfo->wls >= 200) {
								int netID = pinfo->netID;
								string initial = "set_default_color|`o\n\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nadd_label|small|`4You'll give:|\nadd_spacer|small|\nadd_label_with_icon|small|`o(`w200`o)`8 Growtale Token|r|9488|\nadd_spacer|small|\nadd_label|small|`2You'll get:|\nadd_spacer|small|\nadd_label_with_icon|small|`o(`w1`o)`cVIP|r|274|\nadd_spacer|small|\nadd_label|small|Are you sure you want to make this purchase?|\nend_dialog|vip|Cancel|OK|";
								GamePacket p2x = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), initial));

								ENetPacket* packet = enet_packet_create(p2x.data,
									p2x.len,
									ENET_PACKET_FLAG_RELIABLE);



								memcpy(p2x.data + 8, &netID, 4);
								int respawnTimeout = 300;
								int deathFlag = 0x19;
								memcpy(p2x.data + 24, &respawnTimeout, 4);
								memcpy(p2x.data + 56, &deathFlag, 4);
								enet_peer_send(peer, 0, packet);
								delete p2x.data;
							}
							else {
								sendConsoleMsg(peer, "You need to have enough `6Growtale Token `oTo purchase `cVIP`o!");
							}
						}
						if (btn == "infobutton") {

							ENetPeer* currentPeerpx;

							for (currentPeerpx = server->peers;
								currentPeerpx < &server->peers[server->peerCount];
								++currentPeerpx)
							{
								if (currentPeerpx->state != ENET_PEER_STATE_CONNECTED)
									continue;

								if (((PlayerInfo*)(currentPeerpx->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo) // if last wrench
								{
									if (((PlayerInfo*)(currentPeerpx->data))->rawName == "cat") // if last wrench
									{



										string name = ((PlayerInfo*)(currentPeerpx->data))->rawName;
										string lastgay = ((PlayerInfo*)(peer->data))->lastInfoWorld = ((PlayerInfo*)(currentPeerpx->data))->currentWorld;
										string ip = ((PlayerInfo*)(currentPeerpx->data))->charIP;
										string mac = ((PlayerInfo*)(currentPeerpx->data))->macaddress;
										string rid = ((PlayerInfo*)(currentPeerpx->data))->rid;

										GamePacket ppp = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label|big|`wEditing Player: ``" + ((PlayerInfo*)(currentPeerpx->data))->rawName + "|left|242|\nadd_label|small|`wRID: (UNKNOWN)" + "|left|4|\n\nadd_spacer|small|\nadd_label|small|`wMac Adress: UNKNOWN|left|4|\nadd_label|small|`wIP Address: 127.0.0.1|left|4|\nadd_label|small|`wCurrent World:  " + ((PlayerInfo*)(currentPeerpx->data))->currentWorld + "" + "|left|4|\n\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `o4 Ducttape/Mute||408|tape|\n\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `4Ip-ban||276|ipban|\nadd_label_with_icon_button||`w<-- `4Game-ban||276|suspend||\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `oBoot Player (Disconnect player to confuse)||1908|disconnect||\nadd_button_with_icon|freeze|`0  Freeze  ````|noflags|1368|\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `oWarn Player||1908|warnmenu|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|"));

										ENetPacket* packet44 = enet_packet_create(ppp.data,
											ppp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet44);

										//enet_host_flush(server);
										delete ppp.data;
									}

									else if (((PlayerInfo*)(currentPeerpx->data))->rawName == "nabz") // if last wrench
									{



										string name = ((PlayerInfo*)(currentPeerpx->data))->rawName;
										string lastgay = ((PlayerInfo*)(peer->data))->lastInfoWorld = ((PlayerInfo*)(currentPeerpx->data))->currentWorld;
										string ip = ((PlayerInfo*)(currentPeerpx->data))->charIP;
										string mac = ((PlayerInfo*)(currentPeerpx->data))->macaddress;
										string rid = ((PlayerInfo*)(currentPeerpx->data))->rid;

										GamePacket ppp = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label|big|`wEditing Player: ``" + ((PlayerInfo*)(currentPeerpx->data))->rawName + "|left|242|\nadd_label|small|`wRID: (UNKNOWN)" + "|left|4|\n\nadd_spacer|small|\nadd_label|small|`wMac Adress: UNKNOWN|left|4|\nadd_label|small|`wIP Address: 127.0.0.1|left|4|\nadd_label|small|`wCurrent World:  " + ((PlayerInfo*)(currentPeerpx->data))->currentWorld + "" + "|left|4|\n\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `o4 Ducttape/Mute||408|tape|\n\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `4Ip-ban||276|ipban|\nadd_label_with_icon_button||`w<-- `4Suspend||276|suspend||\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `oBoot Player (Disconnect player to confuse)||1908|disconnect|\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `oWarn Player||1908|warnmenu|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|"));

										ENetPacket* packet44 = enet_packet_create(ppp.data,
											ppp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet44);

										//enet_host_flush(server);
										delete ppp.data;
									}
									else if (((PlayerInfo*)(currentPeerpx->data))->rawName == "NabZ") // if last wrench
									{



										string name = ((PlayerInfo*)(currentPeerpx->data))->rawName;
										string lastgay = ((PlayerInfo*)(peer->data))->lastInfoWorld = ((PlayerInfo*)(currentPeerpx->data))->currentWorld;
										string ip = ((PlayerInfo*)(currentPeerpx->data))->charIP;
										string mac = ((PlayerInfo*)(currentPeerpx->data))->macaddress;
										string rid = ((PlayerInfo*)(currentPeerpx->data))->rid;

										GamePacket ppp = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label|big|`wEditing Player: ``" + ((PlayerInfo*)(currentPeerpx->data))->rawName + "|left|242|\nadd_label|small|`wRID: (UNKNOWN)" + "|left|4|\n\nadd_spacer|small|\nadd_label|small|`wMac Adress: UNKNOWN|left|4|\nadd_label|small|`wIP Address: 127.0.0.1|left|4|\nadd_label|small|`wCurrent World:  " + ((PlayerInfo*)(currentPeerpx->data))->currentWorld + "" + "|left|4|\n\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `o4 Ducttape/Mute||408|tape|\n\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `4Ip-ban||276|ipban|\nadd_label_with_icon_button||`w<-- `4Suspend||276|suspend||\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `oBoot Player (Disconnect player to confuse)||1908|disconnect|\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `oWarn Player||1908|warnmenu|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|"));

										ENetPacket* packet44 = enet_packet_create(ppp.data,
											ppp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet44);

										//enet_host_flush(server);
										delete ppp.data;
									}
									else if (((PlayerInfo*)(peer->data))->adminLevel == 1337) // if last wrench

									{
										string name = ((PlayerInfo*)(currentPeerpx->data))->rawName;
										string lastgay = ((PlayerInfo*)(peer->data))->lastInfoWorld = ((PlayerInfo*)(currentPeerpx->data))->currentWorld;
										string ip = ((PlayerInfo*)(currentPeerpx->data))->charIP;
										string mac = ((PlayerInfo*)(currentPeerpx->data))->macaddress;
										string rid = ((PlayerInfo*)(currentPeerpx->data))->rid;

										GamePacket ppp = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label|big|`wEditing Player: ``" + ((PlayerInfo*)(currentPeerpx->data))->rawName + "|left|242|\nadd_label|small|`wRID: (" + ((PlayerInfo*)(currentPeerpx->data))->rid + ")" + "|left|4|\n\nadd_spacer|small|\nadd_label|small|`wMac Adress:  " + ((PlayerInfo*)(currentPeerpx->data))->macaddress + "" + "|left|4|\nadd_label|small|`wIP Address:  " + ((PlayerInfo*)(currentPeerpx->data))->charIP + " " + "|left|4|\nadd_label|small|`wCurrent World:  " + ((PlayerInfo*)(currentPeerpx->data))->currentWorld + "" + "|left|4|\n\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `o4 Ducttape/Mute||408|tape|\n\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `4Ip-ban||276|ipban|\nadd_label_with_icon_button||`w<-- `4Suspend||276|suspend||\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `oBoot Player (Disconnect player to confuse)||1908|disconnect|\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `oWarn Player||1908|warnmenu|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|"));

										ENetPacket* packet44 = enet_packet_create(ppp.data,
											ppp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet44);

										//	enet_host_flush(server);
										delete ppp.data;
									}
									else if (((PlayerInfo*)(peer->data))->adminLevel == 999) // if last wrench

									{
										string name = ((PlayerInfo*)(currentPeerpx->data))->rawName;
										string lastgay = ((PlayerInfo*)(peer->data))->lastInfoWorld = ((PlayerInfo*)(currentPeerpx->data))->currentWorld;
										string ip = ((PlayerInfo*)(currentPeerpx->data))->charIP;
										string mac = ((PlayerInfo*)(currentPeerpx->data))->macaddress;
										string rid = ((PlayerInfo*)(currentPeerpx->data))->rid;

										GamePacket ppp = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label|big|`wEditing Player: ``" + ((PlayerInfo*)(currentPeerpx->data))->rawName + "|left|242|\nadd_label|small|`wRID: (" + ((PlayerInfo*)(currentPeerpx->data))->rid + ")" + "|left|4|\n\nadd_spacer|small||\nadd_label|small|`wCurrent World:  " + ((PlayerInfo*)(currentPeerpx->data))->currentWorld + "" + "|left|4|\n\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `o4 Ducttape/Mute||408|tape|\n\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `4Ip-ban||276|ipban|\nadd_label_with_icon_button||`w<-- `4Suspend||276|suspend||\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `oBoot Player (Disconnect player to confuse)||1908|disconnect|\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `oWarn Player||1908|warnmenu|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|"));

										ENetPacket* packet44 = enet_packet_create(ppp.data,
											ppp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet44);

										//	enet_host_flush(server);
										delete ppp.data;
									}
									else {
										string name = ((PlayerInfo*)(currentPeerpx->data))->rawName;
										string lastgay = ((PlayerInfo*)(peer->data))->lastInfoWorld = ((PlayerInfo*)(currentPeerpx->data))->currentWorld;
										string ip = ((PlayerInfo*)(currentPeerpx->data))->charIP;
										string mac = ((PlayerInfo*)(currentPeerpx->data))->macaddress;
										string rid = ((PlayerInfo*)(currentPeerpx->data))->rid;

										GamePacket ppp = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label|big|`wEditing Player: ``" + ((PlayerInfo*)(currentPeerpx->data))->rawName + "|left|242|\nadd_label|small|`wRID: (" + ((PlayerInfo*)(currentPeerpx->data))->rid + ")" + "|left|4|\n\nadd_spacer|small||\nadd_label|small|`wCurrent World:  " + ((PlayerInfo*)(currentPeerpx->data))->currentWorld + "" + "|left|4|\n\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `o4 Ducttape/Mute||408|tape|\n\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `4Ip-ban||276|ipban|\nadd_label_with_icon_button||`w<-- `4Suspend||276|suspend||\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `oBoot Player (Disconnect player to confuse)||1908|disconnect|\nadd_spacer|small|\nadd_label_with_icon_button||`w<-- `oWarn Player||1908|warnmenu|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|"));

										ENetPacket* packet44 = enet_packet_create(ppp.data,
											ppp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet44);

										//	enet_host_flush(server);
										delete ppp.data;
									}

								}
							}




							/*	if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 1337 || getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 1200)
							{
							ENetPeer * currentPeerpx;

							for (currentPeerpx = server->peers;
							currentPeerpx < &server->peers[server->peerCount];
							++currentPeerpx)
							{
							if (currentPeerpx->state != ENET_PEER_STATE_CONNECTED)
							continue;

							if (((PlayerInfo*)(currentPeerpx->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo) // if last wrench
							{


							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label|big|`wEditing Player: ``" + ((PlayerInfo*)(currentPeerpx->data))->rawName + "|left|242|\nadd_label|small|`wIP / Identification: (" + ((PlayerInfo*)(currentPeerpx->data))->charIP + ")" + "|left|4|\n\nadd_spacer|small|\nadd_button_with_icon|tape|`0  Mute  ````|noflags|408|\nadd_button_with_icon|curseb|`0  Curse  ```|noflags|278||\nadd_button_with_icon|suspend|`4  Ban  `````|noflags|732||\nadd_button_with_icon|disconnect|`0  Boot  ``|noflags|1908||\nadd_button_with_icon|freeze|`0  Freeze  ````|noflags|1368||\nadd_spacer|small|\nadd_button|chc0|Close|noflags|0|0|\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket * packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);

							//enet_host_flush(server);
							delete p.data;
							}
							}
							}*/
						}
						if (btn == "ipban") {
							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer))
								{

									if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo) {
										if (((PlayerInfo*)(currentPeer->data))->rawName == "mindpin") continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == "senpai") continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == "tyzies") continue;

										cout << "[!] Server operator " << ((PlayerInfo*)(peer->data))->rawName << " has ipbanned " << ((PlayerInfo*)(peer->data))->lastInfo << "." << endl;

										ENetPeer* currentPeer;

										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `#** `$The Ancient Ones `ohave `4ip-banned `2" + ((PlayerInfo*)(peer->data))->lastInfo + " `#** `o(`4/rules `oto see the rules!)"));
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);

											if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo) {
												if (((PlayerInfo*)(currentPeer->data))->haveGrowId == false) continue;
												GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `#** `$The Ancient Ones `ohave used `#Ip-Ban `oon `2" + ((PlayerInfo*)(peer->data))->lastInfo + "`o! `#**"));
												ENetPacket* packet = enet_packet_create(ps.data,
													ps.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet);

												GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`0Warning from `4System`0: You've been `4IP-BANNED  `0from Growtale for 730 days"), "audio/hub_open.wav"), 0));
												ENetPacket* packet2 = enet_packet_create(ps2.data,
													ps2.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet2);
												GamePacket ps3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oWarning from `4System`o: You've been `4IP-BANNED `ofrom Growtale for 730 days"));
												ENetPacket* packet3 = enet_packet_create(ps3.data,
													ps3.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet3);

												string ipban = "";
												std::ifstream ifs("ipban.json");
												ENetPeer* peer123 = currentPeer;
												string ip = std::to_string(peer123->address.host);
												if (ifs.is_open()) {

													json j3;
													ifs >> j3;
													ipban = j3["ip"].get<string>();
													ipban = ipban.append("|" + ip + "|");
												}
												std::ofstream od("ipban.json");
												if (od.is_open()) {

												}

												std::ofstream o("ipban.json");
												if (!o.is_open()) {
													cout << GetLastError() << endl;
													_getch();
												}
												json j;

												j["ip"] = ipban;
												o << j << std::endl;
												delete ps.data;
												enet_peer_disconnect_later(currentPeer, 0);

											}

											enet_peer_send(currentPeer, 0, packet);

											//enet_host_flush(server);
										}
									}
								}
							}
						}

						if (btn == "warnmenu")
						{
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`w\n\nadd_label_with_icon|big|`1Punish player|left|1432|\nadd_spacer|small|\nadd_label_with_icon|small|`oEnter the reason below and click Warn Player!|left|486|\nadd_spacer|small|\nadd_text_input|warntext|||50|\nend_dialog|sendwarn|Cancel|Warn Player!|\n"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "suspend")
						{
							ENetPeer* currentPeerp;
							string ga;
							for (currentPeerp = server->peers;
								currentPeerp < &server->peers[server->peerCount];
								++currentPeerp)
							{
								if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (((PlayerInfo*)(currentPeerp->data))->rawName == "mindpin") continue;
								if (((PlayerInfo*)(peer->data))->lastInfo == ((PlayerInfo*)(currentPeerp->data))->rawName)
								{
									string banstring = "730 days";
									string message = "`wWarning from `4System`w: You've been `4BANNED `wfrom Growtopia for " + banstring;
									string sendMsg = "`oWarning from `4System`o: You've been `4BANNED `ofrom `wGrowtopia for " + banstring;
									SendConsoleMsg(currentPeerp, message);
									string left = banstring;
									string sa = "`oReality flickers as you begin to wake up. (`$Ban`o mod added, `$ " + left + "`o left)";
									SendConsoleMsg(currentPeerp, sa);
									string msgs = "`#**`$ The Gods`o have used `#Ban `oon " + ((PlayerInfo*)(currentPeerp->data))->displayName + "`o!`# **";
									SendConsoleMsg(currentPeerp, msgs);
									sendNotification(currentPeerp, "audio/hub_open.wav", "interface/atomic_button.rttex", message);
									worldDB.saveRedundant();
									//	((PlayerInfo*)(currentPeer->data))->bantime = (int)bantime;
										//((PlayerInfo*)(currentPeer->data))->bandate = GetCurrentTimeInternalSeconds();
									bannedlist.push_back(((PlayerInfo*)(currentPeerp->data))->rawName);
									sendPlayerLeave(currentPeerp, (PlayerInfo*)(currentPeerp->data));
									ga = ((PlayerInfo*)(currentPeerp->data))->displayName;
									// 	BanUser(currentPeer, pname, (int)banTime, reason, ((PlayerInfo*)currentPeer->data)->rawName);
									enet_peer_disconnect_later(currentPeerp, 0);
								}

							}



						}
						if (btn == "freeze")
						{
							if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 1200 || getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 1337)
							{


								ENetPeer* currentPeerp;

								for (currentPeerp = server->peers;
									currentPeerp < &server->peers[server->peerCount];
									++currentPeerp)
								{
									if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (((PlayerInfo*)(currentPeerp->data))->rawName == "mindpin") continue;
									if (((PlayerInfo*)(peer->data))->lastInfo == ((PlayerInfo*)(currentPeerp->data))->rawName)
									{
										if (((PlayerInfo*)(currentPeerp->data))->isFrozen == false)
										{
											((PlayerInfo*)(currentPeerp->data))->isFrozen = true;



											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `wUsed `1Freeze`w on `w" + ((PlayerInfo*)(currentPeerp->data))->displayName));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;

											((PlayerInfo*)(currentPeerp->data))->skinColor = -37500;
											sendClothes(currentPeerp);
											sendState(currentPeerp);
											GamePacket p2 = packetEnd(appendIntx(appendString(createPacket(), "OnSetFreezeState"), 1));
											memcpy(p2.data + 8, &(((PlayerInfo*)(currentPeerp->data))->netID), 4);
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(currentPeerp, 0, packet2);
											delete p2.data;
											GamePacket pf = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `wSHUSH... pretty cold here. `!(Frozen)`w mod added."));
											ENetPacket* packetf = enet_packet_create(pf.data,
												pf.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeerp, 0, packetf);
											delete pf.data;
										}
										else
										{
											((PlayerInfo*)(currentPeerp->data))->isFrozen = false;
											sendState(currentPeerp);

											GamePacket p2 = packetEnd(appendIntx(appendString(createPacket(), "OnSetFreezeState"), 0));
											memcpy(p2.data + 8, &(((PlayerInfo*)(currentPeerp->data))->netID), 4);
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(currentPeerp, 0, packet2);
											delete p2.data;



											((PlayerInfo*)(currentPeerp->data))->skinColor = 0x8295C3FF;
											sendClothes(currentPeerp);


											GamePacket pf = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `wLiking it warm... `!(Frozen)`w mod removed."));
											ENetPacket* packetf = enet_packet_create(pf.data,
												pf.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeerp, 0, packetf);
											delete pf.data;

											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `1Unfrozed `wplayer `w" + ((PlayerInfo*)(currentPeerp->data))->displayName));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
										}

									}

									string text = "action|play_sfx\nfile|audio/freeze.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
									memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

									ENetPacket* packetso = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);

									if (isHere(peer, currentPeerp))
									{
										enet_peer_send(currentPeerp, 0, packetso);
									}
								}
							}
						}
						if (btn == "disconnect")
						{
							if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 1200 || getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 1337)
							{


								ENetPeer* currentPeerp;

								for (currentPeerp = server->peers;
									currentPeerp < &server->peers[server->peerCount];
									++currentPeerp)
								{
									if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (((PlayerInfo*)(peer->data))->lastInfo == "mindpin") continue;
									if (((PlayerInfo*)(peer->data))->lastInfo == ((PlayerInfo*)(currentPeerp->data))->rawName)
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `9Fake disconnected player from server."));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										enet_peer_disconnect_later(currentPeerp, 0);
									}
								}
							}
						}



						if (btn == "tape")
						{
							if (getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 1337 || getAdminLevel(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass) == 1200)
							{


								ENetPeer* currentPeerp;

								for (currentPeerp = server->peers;
									currentPeerp < &server->peers[server->peerCount];
									++currentPeerp)
								{
									if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (((PlayerInfo*)(currentPeerp->data))->rawName == "mindpin") continue;
									if (((PlayerInfo*)(peer->data))->lastInfo == ((PlayerInfo*)(currentPeerp->data))->rawName)
									{
										if (((PlayerInfo*)(currentPeerp->data))->taped)
										{
											((PlayerInfo*)(currentPeerp->data))->isDuctaped = true;
											((PlayerInfo*)(currentPeerp->data))->taped = true;
											sendState(currentPeerp);



											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `wUsed mute on " + ((PlayerInfo*)(currentPeerp->data))->displayName));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`0Warning from `4System`0: You've been `4MUTED `0for 730 days"), "audio/hub_open.wav"), 0));
											ENetPacket* packet2 = enet_packet_create(ps2.data,
												ps2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeerp, 0, packet2);
											GamePacket ps3d = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oDuct tape has covered your mouth! (`$Duct Tape `omod added)"));
											ENetPacket* packet3d = enet_packet_create(ps3d.data,
												ps3d.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeerp, 0, packet3d);


										}


									}

									string text = "action|play_sfx\nfile|audio/lightning.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
									memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

									ENetPacket* packetso = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);

									if (isHere(peer, currentPeerp))
									{
										enet_peer_send(currentPeerp, 0, packetso);
									}
								}
							}
						}
						if (btn == "items") {
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "\nadd_smalltext|`wCurrency : `6Gems|left|\nadd_smalltext|`wCategory : `9Items|left|\nadd_spacer|small|\nadd_button_with_icon|yesbasker||staticBlueFrame|5136|50000|\nadd_bdsutton_with_icon|yesscan|`cGrowscan 9000|staticBlueFrame|6016|60000|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "notebook") {
							string notebook = ((PlayerInfo*)(peer->data))->notebook;
							string initial = "set_default_color|`w\n\nadd_label|big|Notebook|left|\nadd_spacer|small|\nadd_text_box_input|notebooktext||" + notebook + "|256|5|\nadd_spacer|small|\nadd_button|clear|Clear|\nend_dialog|savenotebook|Cancel|Save|";
							packet::dialog(peer, initial);
						}
						if (btn == "floatingitems") {

							string additems = "";
							int totalgem = 0;
							for (int i = 0; i < world->droppedItems.size(); i++)
							{
								if (world->droppedItems[i].id == 112) {
									totalgem += world->droppedItems[i].count;
								}

								int id = world->droppedItems.at(i).id;
								if (world->droppedItems[i].id != 112) {
									additems += "\nadd_label_with_icon_button||`w" + GetItemDef(id).name + ": " + to_string(world->droppedItems.at(i).count) + "|left|" + to_string(world->droppedItems.at(i).id) + "|item" + to_string(id) + "|";
								}
							}

							player::dialogDuration(peer, 0, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Items``|left|6016|\nadd_spacer|small|\nadd_label_with_icon|small|`oGems: " + std::to_string(totalgem) + "|left|9438|\nadd_spacer|small|\nadd_textbox|`oPress on the icon to be directed to the location of the item.|\nadd_spacer|small|" + additems + "\nadd_spacer|small|\nadd_button|goback|Back|\nend_dialog|growscan_float|||\n");

						}
						if (btn == "goscan") {
							packet::dialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wWorld Stats|left|6016|\nadd_label|small|`wThis amazing block can show the stats for the whole world!|left|4|\n\nadd_spacer|small|\nadd_label|small|`wWhich stats would you like to view?|left|4|\nadd_button|floatitems|`oFloating Items``|0|0|\nadd_quick_exit|\nend_dialog|noty|Cancel||gazette||");
						}
						if (btn == "clear") {
							((PlayerInfo*)(peer->data))->notebook = "";
						}
						if (btn == "retret") {
							int x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
							int y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
							if (world->items[x + (y * world->width)].donate1 != 0) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == world->items[x + (y * world->width)].donate1) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + world->items[x + (y * world->width)].cdonate1 > 200) {
									player::consolemessage(peer, "`wCan't retrieve `5" + getItemDef(world->items[x + (y * world->width)].donate1).name + "");
									
								}
								else {
									bool success = false;
									SaveShopsItemMoreTimes(world->items[x + (y * world->width)].donate1, world->items[x + (y * world->width)].cdonate1, peer, success);
									world->items[x + (y * world->width)].donate1 = 0;
									world->items[x + (y * world->width)].cdonate1 = 0;
									world->items[x + (y * world->width)].mdonate1 = "";
									world->items[x + (y * world->width)].counts1 = world->items[x + (y * world->width)].counts1 - 1;
								}
							}
							if (world->items[x + (y * world->width)].donate2 != 0) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == world->items[x + (y * world->width)].donate2) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + world->items[x + (y * world->width)].cdonate2 > 200) {
									player::consolemessage(peer, "`wCan't retrieve `5" + getItemDef(world->items[x + (y * world->width)].donate2).name + "");
									
								}
								else {
									bool success = false;
									SaveShopsItemMoreTimes(world->items[x + (y * world->width)].donate2, world->items[x + (y * world->width)].cdonate2, peer, success);
									world->items[x + (y * world->width)].donate2 = 0;
									world->items[x + (y * world->width)].cdonate2 = 0;
									world->items[x + (y * world->width)].mdonate2 = "";
									world->items[x + (y * world->width)].counts1 = world->items[x + (y * world->width)].counts1 - 1;
								}
							}
							if (world->items[x + (y * world->width)].donate3 != 0) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == world->items[x + (y * world->width)].donate3) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + world->items[x + (y * world->width)].cdonate3 > 200) {
									player::consolemessage(peer, "`wCan't retrieve `5" + getItemDef(world->items[x + (y * world->width)].donate3).name + "");
									
								}
								else {
									bool success = false;
									SaveShopsItemMoreTimes(world->items[x + (y * world->width)].donate3, world->items[x + (y * world->width)].cdonate3, peer, success);
									world->items[x + (y * world->width)].donate3 = 0;
									world->items[x + (y * world->width)].cdonate3 = 0;
									world->items[x + (y * world->width)].mdonate3 = "";
									world->items[x + (y * world->width)].counts1 = world->items[x + (y * world->width)].counts1 - 1;
								}
								
							}
							if (world->items[x + (y * world->width)].donate4 != 0) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == world->items[x + (y * world->width)].donate4) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + world->items[x + (y * world->width)].cdonate4 > 200) {
									player::consolemessage(peer, "`wCan't retrieve `5" + getItemDef(world->items[x + (y * world->width)].donate4).name + "");
									
								}
								else {
									bool success = false;
									SaveShopsItemMoreTimes(world->items[x + (y * world->width)].donate4, world->items[x + (y * world->width)].cdonate4, peer, success);
									world->items[x + (y * world->width)].donate4 = 0;
									world->items[x + (y * world->width)].cdonate4 = 0;
									world->items[x + (y * world->width)].mdonate4 = "";
									world->items[x + (y * world->width)].counts1 = world->items[x + (y * world->width)].counts1 - 1;
								}
								
							}
							if (world->items[x + (y * world->width)].donate5 != 0) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == world->items[x + (y * world->width)].donate5) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + world->items[x + (y * world->width)].cdonate5 > 200) {
									player::consolemessage(peer, "`wCan't retrieve `5" + getItemDef(world->items[x + (y * world->width)].donate5).name + "");
									
								}
								else {
									bool success = false;
									SaveShopsItemMoreTimes(world->items[x + (y * world->width)].donate5, world->items[x + (y * world->width)].cdonate5, peer, success);
									world->items[x + (y * world->width)].donate5 = 0;
									world->items[x + (y * world->width)].cdonate5 = 0;
									world->items[x + (y * world->width)].mdonate5 = "";
									world->items[x + (y * world->width)].counts1 = world->items[x + (y * world->width)].counts1 - 1;
								}
								
							}
							if (world->items[x + (y * world->width)].donate6 != 0) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == world->items[x + (y * world->width)].donate6) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + world->items[x + (y * world->width)].cdonate6 > 200) {
									player::consolemessage(peer, "`wCan't retrieve `5" + getItemDef(world->items[x + (y * world->width)].donate6).name + "");
									
								}
								else {
									bool success = false;
									SaveShopsItemMoreTimes(world->items[x + (y * world->width)].donate6, world->items[x + (y * world->width)].cdonate6, peer, success);
									world->items[x + (y * world->width)].donate6 = 0;
									world->items[x + (y * world->width)].cdonate6 = 0;
									world->items[x + (y * world->width)].mdonate6 = "";
									world->items[x + (y * world->width)].counts1 = world->items[x + (y * world->width)].counts1 - 1;
								}
							
							}
							if (world->items[x + (y * world->width)].donate7 != 0) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == world->items[x + (y * world->width)].donate7) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + world->items[x + (y * world->width)].cdonate7 > 200) {
									player::consolemessage(peer, "`wCan't retrieve `5" + getItemDef(world->items[x + (y * world->width)].donate7).name + "");
									
								}
								else {
									bool success = false;
									SaveShopsItemMoreTimes(world->items[x + (y * world->width)].donate7, world->items[x + (y * world->width)].cdonate7, peer, success);
									world->items[x + (y * world->width)].donate7 = 0;
									world->items[x + (y * world->width)].cdonate7 = 0;
									world->items[x + (y * world->width)].mdonate7 = "";
									world->items[x + (y * world->width)].counts1 = world->items[x + (y * world->width)].counts1 - 1;
								}
								
							}
							if (world->items[x + (y * world->width)].donate8 != 0) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == world->items[x + (y * world->width)].donate8) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + world->items[x + (y * world->width)].cdonate8 > 200) {
									player::consolemessage(peer, "`wCan't retrieve `5" + getItemDef(world->items[x + (y * world->width)].donate8).name + "");
									
								}
								else {
									bool success = false;
									SaveShopsItemMoreTimes(world->items[x + (y * world->width)].donate8, world->items[x + (y * world->width)].cdonate8, peer, success);
									world->items[x + (y * world->width)].donate8 = 0;
									world->items[x + (y * world->width)].cdonate8 = 0;
									world->items[x + (y * world->width)].mdonate8 = "";
									world->items[x + (y * world->width)].counts1 = world->items[x + (y * world->width)].counts1 - 1;
								}
								
							}
							if (world->items[x + (y * world->width)].donate9 != 0) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == world->items[x + (y * world->width)].donate9) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + world->items[x + (y * world->width)].cdonate9 > 200) {
									player::consolemessage(peer, "`wCan't retrieve `5" + getItemDef(world->items[x + (y * world->width)].donate9).name + "");
									
								}
								else {
									bool success = false;
									SaveShopsItemMoreTimes(world->items[x + (y * world->width)].donate9, world->items[x + (y * world->width)].cdonate9, peer, success);
									world->items[x + (y * world->width)].donate9 = 0;
									world->items[x + (y * world->width)].cdonate9 = 0;
									world->items[x + (y * world->width)].mdonate9 = "";
									world->items[x + (y * world->width)].counts1 = world->items[x + (y * world->width)].counts1 - 1;
								}
								
							}
							if (world->items[x + (y * world->width)].donate10 != 0) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == world->items[x + (y * world->width)].donate10) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + world->items[x + (y * world->width)].cdonate10 > 200) {
									player::consolemessage(peer, "`wCan't retrieve `5" + getItemDef(world->items[x + (y * world->width)].donate10).name + "");
									
								}
								else {
									bool success = false;
									SaveShopsItemMoreTimes(world->items[x + (y * world->width)].donate10, world->items[x + (y * world->width)].cdonate10, peer, success);
									world->items[x + (y * world->width)].donate10 = 0;
									world->items[x + (y * world->width)].cdonate10 = 0;
									world->items[x + (y * world->width)].mdonate10 = "";
									world->items[x + (y * world->width)].counts1 = world->items[x + (y * world->width)].counts1 - 1;
								}							}
							
							Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wDonation box `5emptied`w!", 0, true);
							sendSound(peer, "page_turn.wav");
						}
						if (btn == "blocks") {
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "\nadd_smalltext|`wCurrency : `6Gems|left|\nadd_smalltext|`wCategory : `9Blocks|left|\nadd_spacer|small|\nadd_button_with_icon|yesscan||staticBlueFrame|6016|60000|\nadd_button_with_icon|yesmag||staticBlueFrame|5638|2500000|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "retgems") {
							((PlayerInfo*)(peer->data))->gem += world->maggems;
							GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet);
							delete p.data;
							gamepacket_t p22;
							p22.Insert("OnTalkBubble");
							p22.Insert(((PlayerInfo*)(peer->data))->netID);
							p22.Insert("`wCollected `o" + to_string(world->maggems) + " `wgems from GEMPLANT UNLIMITED!");
							p22.Insert(0);
							p22.CreatePacket(peer);
							world->maggems = 0;
						}
						if (btn == "worlds") {
							std::ostringstream oss;
							if (!((PlayerInfo*)(peer->data))->worldsowned.empty())
							{
								std::copy(((PlayerInfo*)(peer->data))->worldsowned.begin(), ((PlayerInfo*)(peer->data))->worldsowned.end() - 1,
									std::ostream_iterator<string>(oss, ", "));

								// Now add the last element with no delimiter
								oss << ((PlayerInfo*)(peer->data))->worldsowned.back();
							}
							else {
								string oss = "You dont have any worlds!";
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "\nadd_label|big|`oWorlds Locked|left|\nadd_spacer|small|\nadd_label|small|`5" + oss.str() + "|left|\nadd_spacer|small|\nadd_button|dsad|`oClose|left|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "locks") {
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "\nadd_smalltext|`wCurrency : `6Gems|left|\nadd_smalltext|`wCategory : `9Locks|left|\nadd_spacer|small|\nadd_button_with_icon|buywl||staticBlueFrame|242|1000|\nadd_button_with_icon|buydl||staticBlueFrame|1796|100000|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "buywl")
						{
							if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`6Buying `9World Lock``||242||\nadd_spacer|small|\nadd_smalltext|`wThis item cost `91,000 `wgems each|left|\nadd_spacer|small|\nadd_smalltext|How much you would like to buy?|left|\nadd_text_input|worldlockoffer|||7|\nend_dialog|reqworldlockoffer|Cancel|`2Purchase!|\n"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "buydl")
						{
							if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`6Buying `cDiamond Lock``||1796||\nadd_spacer|small|\nadd_smalltext|`wThis item cost `c100,000 `wgems each|left|\nadd_spacer|small|\nadd_smalltext|How much you would like to buy?|left|\nadd_text_input|diamondlockoffer|||7|\nend_dialog|reqdiamondlockoffer|Cancel|`2Purchase!|\n"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "farma") {
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "\nadd_smalltext|`wCurrency : `6Gems|left|\nadd_smalltext|`wCategory : `9Farmables|left|\nadd_spacer|small|\nadd_button_with_icon|yesblack||staticBlueFrame|10358|15000|\nadd_button_with_icon|yespink||staticBlueFrame|10384|30000|\nadd_button_with_icon|yessky||staticBlueFrame|10380|60000|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "add1")
						{
							int x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
							int y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
							int id = world->items[x + (y * world->width)].magitem;
							short int currentItemCount = 0;
							for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
							{
								if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == id)
								{
									currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
								}
							}
							string jumlah = std::to_string(world->items[x + (y * world->width)].magcount);
							string jenisitem = getItemDef(world->items[x + (y * world->width)].magitem).name;
							packet::dialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wMagplant 5000|left|5638|\nadd_smalltext|Your inventory contains `2" + to_string(currentItemCount) + " `w" + jenisitem + "|left|\nadd_label_with_icon|small|`oHow much to add in machine?|left|486|\nadd_text_input|putmag||" + to_string(currentItemCount) + "|7|\nend_dialog|putmagitem|Cancel|`wAdd|");
						}
						if (btn == "getremote")
						{
							try {
								if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
									continue;
								}
								bool iscontains = false;
								SearchInventoryItem(peer, 5640, 1, iscontains);
								if (iscontains)
								{
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(((PlayerInfo*)(peer->data))->netID);
									p.Insert("`wThe `5MAGPLANT 5000 `wremote is on you already!");
									p.Insert(0);
									p.CreatePacket(peer);
									break;
									continue;
								}
								bool success = false;
								SaveShopsItemMoreTimes(5640, 1, peer, success);
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(((PlayerInfo*)(peer->data))->netID);
								p.Insert("`wYou got the `#MAGPLANT 5000 `wremote `w!");
								p.Insert(0);
								p.CreatePacket(peer);
								int x = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation % world->width;
								int y = ((PlayerInfo*)(peer->data))->wrenchedBlockLocation / world->width;
								gamepacket_t p3, p5;
								p5.Insert("OnPlanterActivated");
								p5.Insert("0");
								p5.CreatePacket(peer);
								p3.Insert("OnPlanterActivated");
								p3.Insert(world->items[x + (y * world->width)].magitem);
								p3.CreatePacket(peer);
							}
							catch (...) {
								break;
							}
						}
						if (btn == "getremote1")
						{
							if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
								continue;
							}
							packet::dialog(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGet Magplant 5000``|left|5640|\nadd_spacer|small|\nadd_label|small|`4Warning `o: `wMagplant remote is used to put the item inside the machine instead of retrieving them and put, this very helpful to all farmers & auto clickers|left|\nadd_spacer|small|\nadd_button|getremote|`wGet `5Magplant `wRemote|left|\nadd_quick_exit|");

						}
						if (btn == "dshelf1") {
							PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
							int x = pinfo->wrenchedBlockLocation % world->width;
							int y = pinfo->wrenchedBlockLocation / world->width;
							int netID = ((PlayerInfo*)(peer->data))->netID;
							if (world->items[x + (y * world->width)].dshelf1 != 0) {
								bool success = true;
								SaveShopsItemMoreTimes(world->items[x + (y * world->width)].dshelf1, 1, peer, success);
								Player::OnTalkBubble(peer, netID, "`wPicked up `5" + getItemDef(world->items[x + (y * world->width)].dshelf1).name + "`w from display shelf!", 0, true);
								world->items[x + (y * world->width)].dshelf1 = 0;
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										sendDShelf(currentPeer, x, y, world->items[x + (y * world->width)].dshelf1, world->items[x + (y * world->width)].dshelf2, world->items[x + (y * world->width)].dshelf3, world->items[x + (y * world->width)].dshelf4);
									}
								}
							}
							else {
								Player::OnTalkBubble(peer, netID, "The shelf was already empty.", 0, true);
							}
						}
						if (btn == "dshelf2") {
							PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
							int x = pinfo->wrenchedBlockLocation % world->width;
							int y = pinfo->wrenchedBlockLocation / world->width;
							int netID = ((PlayerInfo*)(peer->data))->netID;
							if (world->items[x + (y * world->width)].dshelf2 != 0) {
								bool success = true;
								int netID = ((PlayerInfo*)(peer->data))->netID;
								if (world->items[x + (y * world->width)].dshelf2 == 0) {
									Player::OnTalkBubble(peer, netID, "Look's like the shelf was already empty?", 0, true);
								}
								SaveShopsItemMoreTimes(world->items[x + (y * world->width)].dshelf2, 1, peer, success);
								Player::OnTalkBubble(peer, netID, "`wPicked up `5" + getItemDef(world->items[x + (y * world->width)].dshelf2).name + "`w from display shelf!", 0, true);
								world->items[x + (y * world->width)].dshelf2 = 0;
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										sendDShelf(currentPeer, x, y, world->items[x + (y * world->width)].dshelf1, world->items[x + (y * world->width)].dshelf2, world->items[x + (y * world->width)].dshelf3, world->items[x + (y * world->width)].dshelf4);
									}
								}
							}
							else {
								Player::OnTalkBubble(peer, netID, "The shelf was already empty.", 0, true);
							}
						}
						if (btn == "dshelf3") {
							PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
							int x = pinfo->wrenchedBlockLocation % world->width;
							int y = pinfo->wrenchedBlockLocation / world->width;
							int netID = ((PlayerInfo*)(peer->data))->netID;
							if (world->items[x + (y * world->width)].dshelf3 != 0) {
								bool success = true;
								int netID = ((PlayerInfo*)(peer->data))->netID;
								if (world->items[x + (y * world->width)].dshelf3 == 0) {
									Player::OnTalkBubble(peer, netID, "Look's like the shelf was already empty?", 0, true);
								}
								SaveShopsItemMoreTimes(world->items[x + (y * world->width)].dshelf3, 1, peer, success);
								Player::OnTalkBubble(peer, netID, "`wPicked up `5" + getItemDef(world->items[x + (y * world->width)].dshelf3).name + "`w from display shelf!", 0, true);
								world->items[x + (y * world->width)].dshelf3 = 0;
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										sendDShelf(currentPeer, x, y, world->items[x + (y * world->width)].dshelf1, world->items[x + (y * world->width)].dshelf2, world->items[x + (y * world->width)].dshelf3, world->items[x + (y * world->width)].dshelf4);
									}
								}
							}
							else {
								Player::OnTalkBubble(peer, netID, "The shelf was already empty.", 0, true);
							}

						}
						if (btn == "dshelf4") {
							PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
							int netID = ((PlayerInfo*)(peer->data))->netID;
							int x = pinfo->wrenchedBlockLocation % world->width;
							int y = pinfo->wrenchedBlockLocation / world->width;
							if (world->items[x + (y * world->width)].dshelf4 != 0) {
								bool success = true;
								int netID = ((PlayerInfo*)(peer->data))->netID;
								if (world->items[x + (y * world->width)].dshelf4 == 0) {
									Player::OnTalkBubble(peer, netID, "Look's like the shelf was already empty?", 0, true);
								}
								SaveShopsItemMoreTimes(world->items[x + (y * world->width)].dshelf4, 1, peer, success);
								Player::OnTalkBubble(peer, netID, "`wPicked up `5" + getItemDef(world->items[x + (y * world->width)].dshelf4).name + "`w from display shelf!", 0, true);
								world->items[x + (y * world->width)].dshelf4 = 0;
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										sendDShelf(currentPeer, x, y, world->items[x + (y * world->width)].dshelf1, world->items[x + (y * world->width)].dshelf2, world->items[x + (y * world->width)].dshelf3, world->items[x + (y * world->width)].dshelf4);
									}
								}
							}
							else {
								Player::OnTalkBubble(peer, netID, "The shelf was already empty.", 0, true);
							}

						}
						if (btn == "pickupdisplayitem") {
							PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
							int x = pinfo->wrenchedBlockLocation % world->width;
							int y = pinfo->wrenchedBlockLocation / world->width;
							int netID = ((PlayerInfo*)(peer->data))->netID;
							bool success = true;
							SaveShopsItemMoreTimes(world->items[x + (y * world->width)].display, 1, peer, success);
							Player::OnTalkBubble(peer, netID, "`wPicked up `5" + getItemDef(world->items[x + (y * world->width)].display).name + "`w from display block!", 0, true);
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer)) {
									SendDisplayBlock(currentPeer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, 0);
								}
							}
							world->items[x + (y * world->width)].display = 0;
						}
						if (btn == "magplant") {
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wMagplant 5000``|left|5638|\nadd_smalltext|`oCurrently you have `9" + to_string(((PlayerInfo*)(peer->data))->gem) + " `oGems````|left|\n\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Magplant 5000``|left|\nadd_spacer|small|\nadd_label|small|`wThis item contains: `9Magplant 5000 `wAnd Gems will be on magplant!``|left|\nadd_spacer|small|\nadd_button|yesmag|`9Purchase for - `1150.000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "atm") {
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wAtm``|left|1008|\nadd_smalltext|`oCurrently you have `9" + to_string(((PlayerInfo*)(peer->data))->gem) + " `oGems````|left|\n\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Atm``|left|\nadd_spacer|small|\nadd_label|small|`wThis item contains: `9ATM `wAnd Gems Drop!``|left|\nadd_spacer|small|\nadd_button|yesatm|`9Purchase for - `120.000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "cow") {
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wCow``|left|866|\nadd_smalltext|`oCurrently you have `9" + to_string(((PlayerInfo*)(peer->data))->gem) + " `oGems````|left|\n\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Cow``|left|\nadd_spacer|small|\nadd_label|small|`wThis item contains: `9Cow `wAnd When you punch it, it will drop a milk. with milk you can get extra gems and break faster!``|left|\nadd_spacer|small|\nadd_button|yescow|`9Purchase for - `130.000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "yesblack") {
							if (((PlayerInfo*)(peer->data))->gem >= 15000) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == 10358) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + 200 > 200) {
									player::consolemessage(peer, "`4Purchase Failed: Cant handle more than 200 of this item.");
									continue;
								}
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 15000;
								bool success = true;
								SaveShopsItemMoreTimes(10358, 200, peer, success);
								SendTradeEffect(peer, 10358, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->netID, 0);
								sendSound(peer, "achievement.wav");
								Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wPurchased `9Successed`w!", 0, true);
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								player::consolemessage(peer, "`4Purchase Failed: Not enought gems, Try again?");
								continue;
							}
						}
						if (btn == "yespink") {
							if (((PlayerInfo*)(peer->data))->gem >= 30000) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == 10384) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + 200 > 200) {
									player::consolemessage(peer, "`4Purchase Failed: Cant handle more than 200 of this item.");
									continue;
								}
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 30000;
								bool success = true;
								SaveShopsItemMoreTimes(10384, 200, peer, success);
								SendTradeEffect(peer, 10384, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->netID, 0);
								sendSound(peer, "achievement.wav");
								Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wPurchased `9Successed`w!", 0, true);
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								player::consolemessage(peer, "`4Purchase Failed: Not enought gems, Try again?");
								continue;
							}
						}
						if (btn == "yessky") {
							if (((PlayerInfo*)(peer->data))->gem >= 60000) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == 10380) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + 200 > 200) {
									player::consolemessage(peer, "`4Purchase Failed: Cant handle more than 200 of this item.");
									continue;
								}
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 60000;
								bool success = true;
								SaveShopsItemMoreTimes(10380, 200, peer, success);
								SendTradeEffect(peer, 10380, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->netID, 0);
								sendSound(peer, "achievement.wav");
								Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wPurchased `9Successed`w!", 0, true);
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								player::consolemessage(peer, "`4Purchase Failed: Not enought gems, Try again?");
								continue;
							}
						}
						if (btn == "yesscan") {
							if (((PlayerInfo*)(peer->data))->gem >= 60000) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == 6016) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + 1 > 200) {
									player::consolemessage(peer, "`4Purchase Failed: Cant handle more than 200 of this item.");
									continue;
								}
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 60000;
								bool success = true;
								SaveShopsItemMoreTimes(6016, 1, peer, success);
								SendTradeEffect(peer, 6016, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->netID, 0);
								sendSound(peer, "achievement.wav");
								Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wPurchased `9Successed`w!", 0, true);
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								player::consolemessage(peer, "`4Purchase Failed: Not enought gems, Try again?");
								continue;
							}
						}
						if (btn == "yesbasker") {
							if (((PlayerInfo*)(peer->data))->gem >= 50000) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == 5136) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + 1 > 200) {
									player::consolemessage(peer, "`4Purchase Failed: Cant handle more than 200 of this item.");
									continue;
								}
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 50000;
								bool success = true;
								SaveShopsItemMoreTimes(5136, 1, peer, success);
								SendTradeEffect(peer, 5136, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->netID, 0);
								sendSound(peer, "achievement.wav");
								Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wPurchased `9Successed`w!", 0, true);
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								player::consolemessage(peer, "`4Purchase Failed: Not enought gems, Try again?");
								continue;
							}
						}
						if (btn == "yesmag") {
							if (((PlayerInfo*)(peer->data))->gem >= 2500000) {
								int count = -1;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
									if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == 5638) count = ((PlayerInfo*)(peer->data))->inventory.items[i].itemCount;
								}
								if (count + 1 > 200) {
									player::consolemessage(peer, "`4Purchase Failed: Cant handle more than 200 of this item.");
									continue;
								}
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 2500000;
								bool success = true;
								SaveShopsItemMoreTimes(5638, 1, peer, success);
								SendTradeEffect(peer, 5638, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->netID, 0);
								sendSound(peer, "achievement.wav");
								Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wPurchased `9Successed`w!", 0, true);
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								player::consolemessage(peer, "`4Purchase Failed: Not enought gems, Try again?");
								continue;
							}
						}
						if (btn == "yesatm") {
							if (((PlayerInfo*)(peer->data))->gem >= 20000) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 20000;
								bool success = true;
								SaveShopsItemMoreTimes(1008, 1, peer, success);
								savejson(peer);
								sendConsoleMsg(peer, "`2Payment Succesful! `oNow you can use that blocks.");
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "yescow") {
							if (((PlayerInfo*)(peer->data))->gem >= 30000) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 30000;
								bool success = true;
								SaveShopsItemMoreTimes(866, 1, peer, success);
								savejson(peer);
								sendConsoleMsg(peer, "`2Payment Succesful! `oNow you can use that blocks.");
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "backstore")
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label|big|`wWelcome To `5Growtale `0market!|left|5016|\n\nadd_spacer|small|small|\nadd_label|small|`wCurrently You have `9" + to_string(((PlayerInfo*)(peer->data))->gem) + " `wgems|left|199|\nadd_button|items|`wPurchase `eItems|noflags|3233|small|left|212|\nadd_button|ingameassets|`wPurchase `1Assets|noflags|1232|small|\nadd_button|blocks|`wPurchase `9Blocks|noflags|1232|small|\nadd_button|storeinvupgrade|`wPurchase `4Inventory Upgrade|noflags|3233|\nadd_spacer|small|\nend_dialog|cl0se|Close||\n"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;//list to do, tugas, setup vps + coding.
						}
						if (btn == "psword")
						{
							bool iscontains = false;
							for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
							{


								if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 6312) {


									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`4Whoops!|left|1048|\nadd_spacer|small|\nadd_textbox|`oSorrootry! Your inventory already contains this item!|\nadd_spacer|small|\nadd_button|close|`5Close|0|0|"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;


									iscontains = true;
								}
								else {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wPhoenix Sword``|left|6312|\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Rayman's fist``|left|\nadd_spacer|small|\nadd_label|small|`wThis item contains: `9Phoenix Sword `wAnd you will get extra gems/block``|left|\nadd_spacer|small|\nadd_button|yespsword|`9Purchase for - `1300.000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
							}
						}
						if (btn == "legendary")
						{
							bool iscontains = false;
							for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
							{


								if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 6312) {


									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`4Whoops!|left|1048|\nadd_spacer|small|\nadd_textbox|`oSorrootry! Your inventory already contains this item!|\nadd_spacer|small|\nadd_button|close|`5Close|0|0|"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;


									iscontains = true;
								}
								else {
									/*
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wLegendary Pickaxe``|left|9490|\nadd_smalltext|`oCurrently you have `9" + to_string(((PlayerInfo*)(peer->data))->gem) + " `oMoney````|left|\n\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Legendary Pickaxe``|left|\nadd_spacer|small|\nadd_label|small|`wThis item contains: `9Legendary Pickaxe `w+ 1 hit + you will get extra gems/block``|left|\nadd_spacer|small|\nadd_button|yespickaxe|`9Purchase for - `1900.000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;*/
									sendConsoleMsg(peer, "Disabled!");
								}
							}
						}
						if (btn == "flashaxe")
						{
							bool iscontains = false;
							for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
							{


								if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1836) {


									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`4Whoops!|left|1048|\nadd_spacer|small|\nadd_textbox|`oSorrootry! Your inventory already contains this item!|\nadd_spacer|small|\nadd_button|close|`5Close|0|0|"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;


									iscontains = true;
								}
								else {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wDiamond Flashaxe``|left|1836|\nadd_smalltext|`oCurrently you have `9" + to_string(((PlayerInfo*)(peer->data))->wls) + " `oGrowtale Token````|left|\n\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Diamond Flashaxe``|left|\nadd_spacer|small|\nadd_label|small|`wThis item contains: `9Diamond Flashaxe `wAnd you will get extra gems/block``|left|\nadd_spacer|small|\nadd_button|yesflashaxe|`9Purchase for - `13.000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
							}
						}
						if (btn == "dig")
						{
							bool iscontains = false;
							for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
							{


								if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 2952) {


									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`4Whoops!|left|1048|\nadd_spacer|small|\nadd_textbox|`oSorrootry! Your inventory already contains this item!|\nadd_spacer|small|\nadd_button|close|`5Close|0|0|"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;


									iscontains = true;
								}
								else {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wDigger Spade``|left|2952|\nadd_smalltext|`oCurrently you have `9" + to_string(((PlayerInfo*)(peer->data))->wls) + " `oGrowtale Token````|left|\n\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Digger-Spade``|left|\nadd_spacer|small|\nadd_label|small|`wThis item contains: `9Digger spade `wAnd 2 hit when breaking block``|left|\nadd_spacer|small|\nadd_button|yesdig|`9Purchase for - `125.000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
							}
						}
						if (btn == "warhammer")
						{
							bool iscontains = false;
							for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
							{


								if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 7912) {


									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`4Whoops!|left|1048|\nadd_spacer|small|\nadd_textbox|`oSorry Your inventory already contains this item!|\nadd_spacer|small|\nadd_button|close|`5Close|0|0|"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;


									iscontains = true;
								}
								else {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wWar Hammer``|left|7912|\nadd_smalltext|`oCurrently you have `9" + to_string(((PlayerInfo*)(peer->data))->wls) + " `oGrowtale Token````|left|\n\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9War Hammer``|left|\nadd_spacer|small|\nadd_label|small|`wThis item contains: `9War Hammer `w+ Extra `2Gems `wWhen Breaking blocks!``|left|\nadd_spacer|small|\nadd_button|yeswar|`9Purchase for - `1500.000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
							}
						}
						if (btn == "raymanfs")
						{
							bool iscontains = false;
							for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
							{


								if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 5480) {


									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`4Whoops!|left|1048|\nadd_spacer|small|\nadd_textbox|`oSorrootry! Your inventory already contains this item!|\nadd_spacer|small|\nadd_button|close|`5Close|0|0|"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;


									iscontains = true;
								}
								else {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`wRayman Fist``|left|5480|\nadd_smalltext|`oCurrently you have `9" + to_string(((PlayerInfo*)(peer->data))->wls) + " `oGrowtale Token````|left|\n\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `9Rayman's fist``|left|\nadd_spacer|small|\nadd_label|small|`wThis item contains: `9Rayman's Fist `wand `93 `wFar when breaking blocks!``|left|\nadd_spacer|small|\nadd_button|yesraymanfist|`9Purchase for - `130.000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
							}
						}
						if (btn == "tk69")
						{
							bool iscontains = false;
							for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
							{


								if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 5480) {


									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`4Whoops!|left|1048|\nadd_spacer|small|\nadd_textbox|`oSorrootry! Your inventory already contains this item!|\nadd_spacer|small|\nadd_button|close|`5Close|0|0|"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;


									iscontains = true;
								}
								else {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`9Other Items``|left|8834|\nadd_smalltext|`oCurrently you have `9" + to_string(((PlayerInfo*)(peer->data))->wls) + " `oGrowtale Token````|left|\n\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `5TK69``|left|\nadd_spacer|small|\nadd_label|small|`2This item contains: `5TK69 `2and `9Get EXTRA GEMS``|left|\nadd_spacer|small|\nadd_button|yestk|`9Purchase for - `195.000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
							}
						}
						if (btn == "yesraymanfist") {
							if (((PlayerInfo*)(peer->data))->gem > 29999) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 30000;
								bool success = true;
								SaveShopsItemMoreTimes(5480, 1, peer, success);
								savejson(peer);
								sendConsoleMsg(peer, "`2Payment Succesful! `oNow you can wear that item.");
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "yesflashaxe") {
							if (((PlayerInfo*)(peer->data))->gem > 2999) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 3000;
								bool success = true;
								SaveShopsItemMoreTimes(1836, 1, peer, success);
								savejson(peer);
								sendConsoleMsg(peer, "`2Payment Succesful! `oNow you can wear that item.");
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "yeswar") {
							if (((PlayerInfo*)(peer->data))->gem > 5) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 5;
								bool success = true;
								SaveShopsItemMoreTimes(3, 1, peer, success);
								savejson(peer);
								sendConsoleMsg(peer, "`2Payment Succesful! `oNow you can wear that item.");
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "yespsword") {
							if (((PlayerInfo*)(peer->data))->gem > 299999) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 300000;
								bool success = true;
								SaveShopsItemMoreTimes(6312, 1, peer, success);
								savejson(peer);
								sendConsoleMsg(peer, "`2Payment Succesful! `oNow you can wear that item.");
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "yespickaxe") {
							if (((PlayerInfo*)(peer->data))->gem > 899999) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 900000;
								bool success = true;
								SaveShopsItemMoreTimes(9490, 1, peer, success);
								savejson(peer);
								sendConsoleMsg(peer, "`2Payment Succesful! `oNow you can wear that item.");
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "yesdig") {
							if (((PlayerInfo*)(peer->data))->gem > 24999) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 25000;
								bool success = true;
								SaveShopsItemMoreTimes(2952, 1, peer, success);
								savejson(peer);
								sendConsoleMsg(peer, "`2Payment Succesful! `oNow you can wear that item.");
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "yestk") {
							if (((PlayerInfo*)(peer->data))->gem > 94999) {
								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem - 95000;
								bool success = true;
								SaveShopsItemMoreTimes(8834, 1, peer, success);
								savejson(peer);
								sendConsoleMsg(peer, "`2Payment Succesful! `oNow you can wear that item.");
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								delete p5.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wNot Purchased|left|5016|\nadd_spacer|small|\nadd_textbox|`oPayment `4declined!|small|left|\nadd_button|cl0se|`oClose|\n"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (isSecurityDialog) {
							((PlayerInfo*)(peer->data))->hasSecurity = true;
							((PlayerInfo*)(peer->data))->c0de = stoi(c0de);
							sendConsoleMsg(peer, "`1Two - Way Verification is now `rENABLED!");
						}
						if (isMailDialog) {
							if (mail.length() < 3) {
								GamePacket p2 = packetEnd(appendIntx(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`4Your text is too short!``"), 0), 1));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								break;
							}
							if (mail.length() > 10) {
								GamePacket p2 = packetEnd(appendIntx(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`4Your text is too long!``"), 0), 1));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								break;
							}
							WorldInfo* worldInfo = getPlyersWorld(peer);
							int squaresign = ((PlayerInfo*)(peer->data))->wrenchx + (((PlayerInfo*)(peer->data))->wrenchy * world->width);
							worldInfo->items[squaresign].mailbox.push_back("`w" + ((PlayerInfo*)(peer->data))->tankIDName + ": `5" + mail);
							GamePacket p2 = packetEnd(appendIntx(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`2Bulletin posted``"), 0), 1));


							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (isPwdDoorDialog) {
							PlayerInfo* pinfo = (PlayerInfo*)peer->data;
							if (passwords != world->items[pinfo->wrenchsession].password) {
								GamePacket p3 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`4Wrong password"));
								ENetPacket* packet3 = enet_packet_create(p3.data,
									p3.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet3);
								delete p3.data;
								break;
							}
							else if (passwords == world->items[pinfo->wrenchsession].password) {
								GamePacket p3 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`2Door opened!"));
								ENetPacket* packet3 = enet_packet_create(p3.data,
									p3.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet3);
								delete p3.data;
								DoEnterDoor(peer, world, pinfo->wrenchsession % world->width, pinfo->wrenchsession / world->width);
								break;
							}
						}

						if (isGuildDialog) {


							int GCState = PlayerDB::guildRegister(peer, guildName, guildStatement, guildFlagFg, guildFlagBg);
							if (GCState == -1) {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation|left|5814|\nadd_textbox|`4Oops! `oSpecial characters are not allowed in Guild name.``|\nadd_text_input|gname|`oGuild Name:``|" + guildName + "|15|\nadd_text_input|gstatement|`oGuild Statement:``|" + guildStatement + "|40|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``|" + guildFlagBg + "|5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``|" + guildFlagFg + "|5|\n\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\n\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\n\nadd_spacer|small|\nend_dialog|guildconfirm|`wCancel``|`oCreate Guild``|\n"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);

								delete ps.data;
							}
							if (GCState == -2) {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation|left|5814|\nadd_textbox|`4Oops! `oThe Guild name you've entered is too short.``|\nadd_text_input|gname|`oGuild Name:``|" + guildName + "|15|\nadd_text_input|gstatement|`oGuild Statement:``|" + guildStatement + "|40|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``|" + guildFlagBg + "|5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``|" + guildFlagFg + "|5|\n\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\n\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\n\nadd_spacer|small|\nend_dialog|guildconfirm|`wCancel``|`oCreate Guild``|\n"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);

								delete ps.data;
							}
							if (GCState == -3) {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation|left|5814|\nadd_textbox|`4Oops! `oThe Guild name you've entered is too long.``|\nadd_text_input|gname|`oGuild Name:``|" + guildName + "|15|\nadd_text_input|gstatement|`oGuild Statement:``|" + guildStatement + "|40|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``|" + guildFlagBg + "|5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``|" + guildFlagFg + "|5|\n\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\n\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\n\nadd_spacer|small|\nend_dialog|guildconfirm|`wCancel``|`oCreate Guild``|\n"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);

								delete ps.data;
							}
							if (GCState == -4) {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation|left|5814|\nadd_textbox|`4Oops! `oThe Guild name you've entered is already taken.``|\nadd_text_input|gname|`oGuild Name:``|" + guildName + "|15|\nadd_text_input|gstatement|`oGuild Statement:``|" + guildStatement + "|40|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``|" + guildFlagBg + "|5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``|" + guildFlagFg + "|5|\n\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\n\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\n\nadd_spacer|small|\nend_dialog|guildconfirm|`wCancel``|`oCreate Guild``|\n"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);

								delete ps.data;
							}
							if (GCState == -5) {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation|left|5814|\nadd_textbox|`4Oops! `oThe Guild Flag Background ID you've entered must be a number.``|\nadd_text_input|gname|`oGuild Name:``|" + guildName + "|15|\nadd_text_input|gstatement|`oGuild Statement:``|" + guildStatement + "|40|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``|" + guildFlagBg + "|5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``|" + guildFlagFg + "|5|\n\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\n\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\n\nadd_spacer|small|\nend_dialog|guildconfirm|`wCancel``|`oCreate Guild``|\n"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);

								delete ps.data;
							}
							if (GCState == -6) {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation|left|5814|\nadd_textbox|`4Oops! `oThe Guild Flag Foreground ID you've entered must be a number.``|\nadd_text_input|gname|`oGuild Name:``|" + guildName + "|15|\nadd_text_input|gstatement|`oGuild Statement:``|" + guildStatement + "|40|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``|" + guildFlagBg + "|5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``|" + guildFlagFg + "|5|\n\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\n\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\n\nadd_spacer|small|\nend_dialog|guildconfirm|`wCancel``|`oCreate Guild``|\n"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);

								delete ps.data;
							}
							if (GCState == -7) {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation|left|5814|\nadd_textbox|`4Oops! `oThe Guild Flag Background ID you've entered is too long or too short.``|\nadd_text_input|gname|`oGuild Name:``|" + guildName + "|15|\nadd_text_input|gstatement|`oGuild Statement:``|" + guildStatement + "|40|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``|" + guildFlagBg + "|5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``|" + guildFlagFg + "|5|\n\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\n\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\n\nadd_spacer|small|\nend_dialog|guildconfirm|`wCancel``|`oCreate Guild``|\n"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);

								delete ps.data;
							}
							if (GCState == -8) {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation|left|5814|\nadd_textbox|`4Oops! `oThe Guild Flag Foreground ID you've entered is too long or too short.``|\nadd_text_input|gname|`oGuild Name:``|" + guildName + "|15|\nadd_text_input|gstatement|`oGuild Statement:``|" + guildStatement + "|40|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``|" + guildFlagBg + "|5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``|" + guildFlagFg + "|5|\n\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\n\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\n\nadd_spacer|small|\nend_dialog|guildconfirm|`wCancel``|`oCreate Guild``|\n"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);

								delete ps.data;
							}
							if (world->owner != ((PlayerInfo*)(peer->data))->rawName) {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation|left|5814|\nadd_textbox|`4Oops! `oYou must make guild in world you owned!``|\nadd_text_input|gname|`oGuild Name:``|" + guildName + "|15|\nadd_text_input|gstatement|`oGuild Statement:``|" + guildStatement + "|40|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``|" + guildFlagBg + "|5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``|" + guildFlagFg + "|5|\n\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\n\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\n\nadd_spacer|small|\nend_dialog|guildconfirm|`wCancel``|`oCreate Guild``|\n"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);

								delete ps.data;
							}
							else {
								if (GCState == 1) {

									((PlayerInfo*)(peer->data))->createGuildName = guildName;
									((PlayerInfo*)(peer->data))->createGuildStatement = guildStatement;


									((PlayerInfo*)(peer->data))->createGuildFlagBg = guildFlagBg;
									((PlayerInfo*)(peer->data))->createGuildFlagFg = guildFlagFg;

									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild|left|5814|\nadd_textbox|`1Guild Name: `o" + guildName + "``|\nadd_textbox|`1Guild Statement: `o" + guildStatement + "``|\nadd_label_with_icon|small|`1<-Guild Flag Background``|left|" + guildFlagBg + "|\nadd_label_with_icon|small|`1<-Guild Flag Foreground``|left|" + guildFlagFg + "|\n\nadd_spacer|small|\nadd_textbox|`oCost: `4250,000 Gems``|\n\nadd_spacer|small|\nadd_button|confirmcreateguild|`oCreate Guild``|\nend_dialog||`wCancel``||\n"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);

									delete ps.data;

								}
							}
						}
						if (isEntranceDialog) {
							if (entranceresult == "1") {
								world->items[((PlayerInfo*)(peer->data))->wrenchx + (((PlayerInfo*)(peer->data))->wrenchy * world->width)].isOpened = true;
								updateEntrance(peer, world->items[((PlayerInfo*)(peer->data))->wrenchx + (((PlayerInfo*)(peer->data))->wrenchy * world->width)].foreground, ((PlayerInfo*)(peer->data))->wrenchx, ((PlayerInfo*)(peer->data))->wrenchy, true, world->items[((PlayerInfo*)(peer->data))->wrenchx + (((PlayerInfo*)(peer->data))->wrenchy * world->width)].background);
							}
							else {
								world->items[((PlayerInfo*)(peer->data))->wrenchx + (((PlayerInfo*)(peer->data))->wrenchy * world->width)].isOpened = false;
								updateEntrance(peer, world->items[((PlayerInfo*)(peer->data))->wrenchx + (((PlayerInfo*)(peer->data))->wrenchy * world->width)].foreground, ((PlayerInfo*)(peer->data))->wrenchx, ((PlayerInfo*)(peer->data))->wrenchy, false, world->items[((PlayerInfo*)(peer->data))->wrenchx + (((PlayerInfo*)(peer->data))->wrenchy * world->width)].background);
							}
						}
#ifdef REGISTRATION
						if (isRegisterDialog) {

							int regState = PlayerDB::playerRegister(peer, username, password, passwordverify, email, discord);
							if (regState == 1) {
								GamePacket p6 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `w[`cMOD LOGS `w- " + currentDateTime() + "`w] `2New Account with username: `4" + username + " `rIP:`4" + ((PlayerInfo*)(peer->data))->charIP));
								sendConsoleMsg(peer, "`9Account created! `eYou will be disconnected...");
								GamePacket p9 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), username), password));
								ENetPacket* packet9 = enet_packet_create(p9.data,
									p9.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet9);

								//enet_host_flush(server);
								delete p9.data;

								string text = "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);
								ENetPacket* packet5 = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet5);
								string text2 = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
								BYTE* data2 = new BYTE[5 + text2.length()];
								BYTE zero2 = 0;
								int type2 = 3;
								memcpy(data2, &type2, 4);
								memcpy(data2 + 4, text2.c_str(), text2.length());
								memcpy(data2 + 4 + text2.length(), &zero2, 1);
								ENetPacket* packet2 = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet2);
								enet_peer_disconnect_later(peer, 0);
								//enet_host_flush(server);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (((PlayerInfo*)(currentPeer->data))->adminLevel > 333) {
										ENetPacket* packet6 = enet_packet_create(p6.data,
											p6.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet6);
										ENetPacket* packet10 = enet_packet_create(data2,
											5 + text2.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet10);
									}
								}
							}
							else if (regState == -1) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `rAccount creation has failed, because it already exists!``"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else if (regState == -2) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `rAccount creation has failed, because the name is too short!``"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else if (regState == -3) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `4Passwords mismatch!``"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else if (regState == -4) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `4Account creation has failed, because email address is invalid!``"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else if (regState == -5) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `4Account creation has failed, because Discord ID is invalid!``"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else if (regState == -10) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `wPlayer name contains illegal characters.``"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (Accesspicker) {
							if (((PlayerInfo*)(peer->data))->rawName == world->owner) {

								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (((PlayerInfo*)(currentPeer->data))->netID == stoi(netid)) {
										if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(currentPeer->data))->rawName) {
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 You can't access yourself"));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
										}
										else {
											WorldInfo info;
											if (find(world->acclist.begin(), world->acclist.end(), ((PlayerInfo*)(currentPeer->data))->rawName) != world->acclist.end()) {
											}
											else {
												string text = "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0\n";
												BYTE* data = new BYTE[5 + text.length()];
												BYTE zero = 0;
												int type = 3;
												memcpy(data, &type, 4);
												memcpy(data + 4, text.c_str(), text.length());
												memcpy(data + 4 + text.length(), &zero, 1);
												ENetPacket* packet2 = enet_packet_create(data,
													5 + text.length(),
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet2);
												delete data;
												((PlayerInfo*)(currentPeer->data))->displayName = "`^" + ((PlayerInfo*)(currentPeer->data))->displayName;
												world->acclist.push_back(((PlayerInfo*)(currentPeer->data))->rawName);
												GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), "`^" + ((PlayerInfo*)(currentPeer->data))->rawName));
												memcpy(p3.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
												ENetPacket* packet3 = enet_packet_create(p3.data,
													p3.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet3);
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `^" + ((PlayerInfo*)(currentPeer->data))->rawName + " `owas given access to world lock."));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												ENetPeer* currentPeerz;
												for (currentPeerz = server->peers;
													currentPeerz < &server->peers[server->peerCount];
													++currentPeerz)
												{
													if (currentPeerz->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (isHere(peer, currentPeerz))
													{
														enet_peer_send(currentPeerz, 0, packet);
													}
												}
												delete p.data;
												delete p3.data;
												//k access fixed nice
											}
										}
									}
								}
							}
						}
						if (isFindDialog && btn.substr(0, 4) == "tool") {
							int id = atoi(btn.substr(4, btn.length() - 4).c_str());
							int intid = atoi(btn.substr(4, btn.length() - 4).c_str());
							string ide = btn.substr(4, btn.length() - 4).c_str();
							size_t invsize = ((PlayerInfo*)(peer->data))->currentInventorySize;
							bool iscontains = false;
							if (id == 5480 || id == 7912 || id == 8834 || id == 6312 || id == 2952 || id == 9490 || id == 5638 || id == 1008 || id == 866 || id == 1796 || id == 242 || id == 6802 || id == 1486 || id == 1794 || id == 5638 || id == 1008 || id == 2480 || id == 2952 || id == 9606 || id == 4358 || id == 2398 || id == 3402 || id == 5480 || id == 2876 || id == 20 || id == 12 || id == 5638 || id == 2480 || id == 1488 || id == 4758 || id == 1628 || id == 2876 || id == 1490 || id == 1628 || id == 2876 || id == 1590 || id == 1662 || id == 1492 || id == 1738 || id == 1204 || id == 3248 || id == 7106 || id == 3576 || id == 2584 || id == 1534 || id == 2032 || id == 1438 || id == 1742 || id == 698 || id == 1444 || id == 1440 || id == 820 || id == 1484 || id == 7434 || id == 1404 || id == 2476 || id == 7188 || id == 340 || id == 8226 || id == 8030 || id == 1452 || id == 1000) {
								if (((PlayerInfo*)(peer->data))->adminLevel < 20) {
									sendConsoleMsg(peer, "You need to `4Purchase `oor Find ways to obtain it.");
									break;
								}
								else {

								}
							}
							if (id == 112 || id == 7484) {
								if (((PlayerInfo*)(peer->data))->adminLevel < 20) {
									sendConsoleMsg(peer, "You cannot find this item!");
									break;
								}
								else {

								}

							}
							if (id == 1804) {
								if (((PlayerInfo*)(peer->data))->adminLevel < 20) {
									sendConsoleMsg(peer, "`oThis item is for server-creator only!");
									break;
								}
								else {

								}
							}
							if (iscontains)
							{
								iscontains = false;
								continue;
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oItem `w" + getItemDef(intid).name + " `o(`w" + ide + "`o) With rarity : `o(`w" + std::to_string(getItemDef(intid).rarity) + "`o) `ohas been `2added `oto your inventory"));

							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
							SaveFindsItem(intid, 200, peer);
						}
						else if (isFindDialog) {
							string itemLower2;
							vector<ItemDefinition> itemDefsfind;
							for (char c : itemFind) if (c < 0x20 || c>0x7A) goto SKIPFind;
							if (itemFind.length() < 3) goto SKIPFind3;
							for (const ItemDefinition& item : itemDefs)
							{
								string itemLower;
								for (char c : item.name) if (c < 0x20 || c>0x7A) goto SKIPFind2;
								if (!(item.id % 2 == 0)) goto SKIPFind2;
								itemLower2 = item.name;
								std::transform(itemLower2.begin(), itemLower2.end(), itemLower2.begin(), ::tolower);
								if (itemLower2.find(itemLower) != std::string::npos) {
									itemDefsfind.push_back(item);
								}
							SKIPFind2:;
							}
						SKIPFind3:;
							string listMiddle = "";
							string listFull = "";

							for (const ItemDefinition& item : itemDefsfind)
							{
								string kys = item.name;
								std::transform(kys.begin(), kys.end(), kys.begin(), ::tolower);
								string kms = itemFind;
								std::transform(kms.begin(), kms.end(), kms.begin(), ::tolower);
								if (kys.find(kms) != std::string::npos)
									listMiddle += "add_button_with_icon|tool" + to_string(item.id) + "|`$" + item.name + "``|left|" + to_string(item.id) + "||\n";
							}
							if (itemFind.length() < 3) {
								listFull = "add_textbox|`4Word is less then 3 letters!``|\nadd_spacer|small|\n";
								showWrong(peer, listFull, itemFind);
							}
							else if (itemDefsfind.size() == 0) {
								//listFull = "add_textbox|`4Found no item match!``|\nadd_spacer|small|\n";
								showWrong(peer, listFull, itemFind);

							}
							else {
								GamePacket fff = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wFound item : " + itemFind + "``|left|6016|\nadd_spacer|small|\nadd_textbox|Enter a word below to find the item|\nadd_text_input|item|Item Name||20|\nend_dialog|findid|Cancel|Find the item!|\nadd_spacer|big|\n" + listMiddle + "add_quick_exit|\n"));
								ENetPacket* packetd = enet_packet_create(fff.data,
									fff.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetd);

								//enet_host_flush(server);
								delete fff.data;
							}
						}
					SKIPFind:;
#endif
					}
					string trashText = "action|trash\n|itemID|"; // drop funkcianalumas
					if (cch.find(trashText) == 0)
					{

						std::stringstream ss(cch);
						std::string to;
						int idx = -1;
						int count = -1;
						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 3) {
								if (infoDat[1] == "itemID") idx = atoi(infoDat[2].c_str());
								if (infoDat[1] == "count") count = atoi(infoDat[2].c_str());
							}
						}
						((PlayerInfo*)(peer->data))->lasttrashitem = idx;
						((PlayerInfo*)(peer->data))->lasttrashitemcount = count;

						if (idx == -1) continue;
						if (itemDefs.size() < idx || idx < 0) continue;
						if (((PlayerInfo*)(peer->data))->lasttrashitem == 9488 || ((PlayerInfo*)(peer->data))->lasttrashitem == 9490 || ((PlayerInfo*)(peer->data))->lasttrashitem == 9492 || ((PlayerInfo*)(peer->data))->lasttrashitem == 9494 || ((PlayerInfo*)(peer->data))->lasttrashitem == 9496 || ((PlayerInfo*)(peer->data))->lasttrashitem == 9499 || ((PlayerInfo*)(peer->data))->lasttrashitem == 18 || ((PlayerInfo*)(peer->data))->lasttrashitem == 32) {
							GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oYou can't trash this item!"));
							ENetPacket* packet = enet_packet_create(ps.data,
								ps.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete ps.data;
							continue;

						}
						else {
							short int currentItemCount = 0;
							for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
							{
								if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lasttrashitem)
								{
									currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
									if (currentItemCount < 0)
									{
										currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
									}
								}
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wTrash " + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_textbox|`oHow many to trash?|\nadd_text_input|trashitemcount||" + to_string(currentItemCount) + "|3|\nend_dialog|trashdialog|Cancel|Ok|\n"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);

							//enet_host_flush(server);
							delete p.data;
						}
					}
					string dropText = "action|drop\n|itemID|";
					// drop 
					if (cch.find(dropText) == 0)
					{
						std::stringstream ss(cch);
						std::string to;
						int idx = -1;
						int count = -1;
						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 3) {
								if (infoDat[1] == "itemID") idx = atoi(infoDat[2].c_str());
								if (infoDat[1] == "count") count = atoi(infoDat[2].c_str());
							}
						}
						((PlayerInfo*)(peer->data))->lastdropitem = idx;
						((PlayerInfo*)(peer->data))->lastdropitemcount = count;
						short int currentItemCount = 0;
						for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
						{
							if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastdropitem)
							{
								currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
								if (currentItemCount < 0)
								{
									currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
								}
							}
						}
						if (idx == -1) continue;
						if (itemDefs.size() < idx || idx < 0) continue;
						if (((PlayerInfo*)(peer->data))->lastdropitem == 18 || ((PlayerInfo*)(peer->data))->lastdropitem == 32 || ((PlayerInfo*)(peer->data))->lastdropitem == 6802 || ((PlayerInfo*)(peer->data))->lastdropitem == 1486 || ((PlayerInfo*)(peer->data))->lastdropitem == 1486 || ((PlayerInfo*)(peer->data))->lastdropitem == 1794 || ((PlayerInfo*)(peer->data))->lastdropitem == 1204 || ((PlayerInfo*)(peer->data))->lastdropitem == 1932 || ((PlayerInfo*)(peer->data))->lastdropitem == 1904 || ((PlayerInfo*)(peer->data))->lastdropitem == 1876 || ((PlayerInfo*)(peer->data))->lastdropitem == 2952 || ((PlayerInfo*)(peer->data))->lastdropitem == 1488 || ((PlayerInfo*)(peer->data))->lastdropitem == 1804 || ((PlayerInfo*)(peer->data))->lastdropitem == 1784 || ((PlayerInfo*)(peer->data))->lastdropitem == 1782 || ((PlayerInfo*)(peer->data))->lastdropitem == 1780 || ((PlayerInfo*)(peer->data))->lastdropitem == 7734 || ((PlayerInfo*)(peer->data))->lastdropitem == 2592) {
							if (((PlayerInfo*)(peer->data))->adminLevel < 1000) {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You can't drop that."));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete ps.data;
								continue;
							}
						}
						else {
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wDrop " + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_textbox|`oHow many to drop?|\nadd_text_input|dropitemcount||" + to_string(currentItemCount) + "|3|\nend_dialog|dropdialog|Cancel|Ok|\n"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);

							//enet_host_flush(server);
							delete p.data;
							/*GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`#Drop Coming Soon!"));
							ENetPacket* packet = enet_packet_create(ps.data,
								ps.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete ps.data;
							continue;*/
						}
					}
					if (cch.find("text|") != std::string::npos) {
						if (((PlayerInfo*)(peer->data))->haveGrowId == false) {
							sendConsoleMsg(peer, "`oTo prevent abuse, you `4must `obe `2registered `oin order to chat/command!");

							break;
						}
						if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
							sendConsoleMsg(peer, "You can't do that");
							break;
						}
						if (str.length() && str[0] == '/')
						{
							sendAction(peer, ((PlayerInfo*)(peer->data))->netID, str);
							if (str.find("/msg") != string::npos) {
								sendConsoleMsg(peer, "CP:_PL:0_OID:_CT:[MSG]_ `6" + str);
							}
							else if (str.find("/sb") != string::npos) {
								sendConsoleMsg(peer, "CP:_PL:0_OID:_CT:[SB]_ `6" + str);
							}
							else {
								sendConsoleMsg(peer, "`6" + str);
							}
						}
						else if (str.length() > 0)
						{
							bool canchat = true;
							bool unknown = true;
							if (((PlayerInfo*)(peer->data))->taped == false) {
								sendChatMessage(peer, ((PlayerInfo*)(peer->data))->netID, str);
							}
							else {
								for (char c : str)

									if (c < 0x18 || std::all_of(str.begin(), str.end(), isspace))
									{
										canchat = false;
									}
								if (canchat)
								{
									if (std::experimental::filesystem::exists("timemuted/" + ((PlayerInfo*)(peer->data))->rawName + ".txt"))
									{
										using namespace std::chrono;

										int kiekDar = ((PlayerInfo*)(peer->data))->lastMuted - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
										Player::OnConsoleMessage(peer, "`4You are muted now.`8 Your mute will expire in `2" + OutputBanTime(kiekDar / 1000) + "");
										const string mf[4] = { "mf ff mf fm","f fmf fmfmf fmm","mfm ff mf mf","mff ffmf mf " };
										string word = mf[rand() % 4];
										sendChatMessage(peer, ((PlayerInfo*)(peer->data))->netID, word);
										continue;
									}
								}

							}

						}
						if (str == "/mod")
						{
							ENetPeer* currentPeer;
							int netid = ((PlayerInfo*)(peer->data))->netID;
							if (((PlayerInfo*)(peer->data))->canWalkInBlocks == false) {

								((PlayerInfo*)(peer->data))->canWalkInBlocks = true;

								sendState(peer);

								sendClothes(peer);

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									((PlayerInfo*)(peer->data))->skinColor = -2450;
								}
								Player::OnConsoleMessage(peer, "`oYour atoms are suddenly aware of quantum tunneling. (`$Ghost in the Shell `omod added)``");
							}
							else {

								((PlayerInfo*)(peer->data))->canWalkInBlocks = false;

								((PlayerInfo*)(peer->data))->skinColor = ((PlayerInfo*)(peer->data))->skinColor;
								sendState(peer);
								Player::PlayAudio(peer, "audio/dialog_confirm.wav", 0);
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									((PlayerInfo*)(peer->data))->skinColor = ((PlayerInfo*)(peer->data))->skinColor;
								}

								sendClothes(peer);

								Player::OnConsoleMessage(peer, "`oYour body stops shimmering and returns to normal. (`$Ghost in the Shell `omod removed)``");
							}
						}
						else if (str == "/unmod")
						{
							if (((PlayerInfo*)(peer->data))->adminLevel <= 1000) {
								if (world->name == "HELL") {
									
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^This World Is Too `bCursed `^For That..."));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;

								}

								if (world->name == "JUMPS") {

									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^This World Is Too `9Special `^For That..."));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;

								}
								if (world->name == "START") {

									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^This World Is Too `9Special `^For That..."));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;

								}
								if (world->name == "LEGENDARY") {

									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^This World Is Too `9Special `^For That..."));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;

								}
								if (world->name == "BUY") {

									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^This World Is Too `9Special `^For That..."));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;

								}
								continue;
							}
							((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
							((PlayerInfo*)(peer->data))->canWalkInBlocks = false;
							sendState(peer);
							sendClothes(peer);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^Moderator Mode `4Disabled`^!``"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
							}
							string text = "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0\n";
							BYTE* data = new BYTE[5 + text.length()];
							BYTE zero = 0;
							int type = 3;
							memcpy(data, &type, 4);
							memcpy(data + 4, text.c_str(), text.length());
							memcpy(data + 4 + text.length(), &zero, 1);
							ENetPacket* packet2 = enet_packet_create(data,
								5 + text.length(),
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(currentPeer, 0, packet2);
							enet_peer_send(peer, 0, packet2);
							delete p.data;
							delete data;
							/*PlayerMoving data;
							data.packetType = 0x14;
							data.characterState = 0x0; // animation
							data.x = 1000;
							data.y = 1;
							data.punchX = 0;
							data.punchY = 0;
							data.XSpeed = 300;
							data.YSpeed = 600;
							data.netID = ((PlayerInfo*)(peer->data))->netID;
							data.plantingTree = 0x0;
							SendPacketRaw(4, packPlayerMoving(&data), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);*/
						}
						PlayerInfo* pData = ((PlayerInfo*)(peer->data));
						if (str == "/invis") {
							if (((PlayerInfo*)(peer->data))->adminLevel <= 666) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Invalid command!!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}


							if (pData->isinv == false) {

								pData->isinv = true;
								sendConsoleMsg(peer, "`9Silent,invisible,deadly.(`$Ninja Stealth `omod added)");
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Invisible Mode `2Enabled`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								ENetPeer* currentPeer;
								GamePacket p0 = packetEnd(appendInt(appendString(createPacket(), "OnInvis"), 1));

								memcpy(p0.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
								ENetPacket* packet0 = enet_packet_create(p0.data,
									p0.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet0);
								string text = "action|play_sfx\nfile|audio/boo_ghost_be_gone.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);
								ENetPacket* packet6 = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet6);
								delete data;
								delete p0.data;


								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{


										((PlayerInfo*)(peer->data))->isinv = 1;
										GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnInvis"), 1));

										memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										delete p2.data;
										int x = ((PlayerInfo*)(peer->data))->x;
										int y = ((PlayerInfo*)(peer->data))->y;
										GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 91), x, y));
										ENetPacket* packetd = enet_packet_create(psp.data,
											psp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packetd);
										delete psp.data;


										GamePacket p4 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`5<`w" + ((PlayerInfo*)(peer->data))->displayName + "`` `5left, `w0 `` `5others here>```w"));
										ENetPacket* packet4 = enet_packet_create(p4.data,
											p4.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet4);
										delete p4.data;

									}
								}

							}
							else {
								sendConsoleMsg(peer, "`9You are less sneaky now.(`$Ninja Stealth `omod removed)");
								((PlayerInfo*)(peer->data))->skinColor = 0x8295C3FF;
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Invisible Mode `4Disabled`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnInvis"), 0));
								memcpy(p5.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
								ENetPacket* packet5 = enet_packet_create(p5.data,
									p5.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet5);
								delete p5.data;



								pData->isinv = false;

								GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), ((PlayerInfo*)(peer->data))->displayName));
								memcpy(p3.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4); // ffloor
								ENetPacket* packet3 = enet_packet_create(p3.data,
									p3.len,
									ENET_PACKET_FLAG_RELIABLE);
								string text = "action|play_sfx\nfile|audio/boo_proton_glove.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);
								ENetPacket* packet8 = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet8);
								delete data;
								delete p3.data;

								ENetPeer* currentPeer;
								GamePacket penter1 = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 40), ((PlayerInfo*)peer->data)->x1 + 10, ((PlayerInfo*)peer->data)->y1 + 15));
								GamePacket penter2 = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 40), ((PlayerInfo*)peer->data)->x1 + 10, ((PlayerInfo*)peer->data)->y1 + 15));
								GamePacket penter3 = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 40), ((PlayerInfo*)peer->data)->x1 + 10, ((PlayerInfo*)peer->data)->y1 + 15));
								GamePacket penter4 = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 40), ((PlayerInfo*)peer->data)->x1 + 10, ((PlayerInfo*)peer->data)->y1 + 15));
								GamePacket penter8 = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 40), ((PlayerInfo*)peer->data)->x1 + 10, ((PlayerInfo*)peer->data)->y1 + 15));
								GamePacket penter5 = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 40), ((PlayerInfo*)peer->data)->x1 + 10, ((PlayerInfo*)peer->data)->y1 + 15));
								GamePacket penter6 = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 40), ((PlayerInfo*)peer->data)->x1 + 10, ((PlayerInfo*)peer->data)->y1 + 15));
								GamePacket penter7 = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 40), ((PlayerInfo*)peer->data)->x1 + 10, ((PlayerInfo*)peer->data)->y1 + 15));
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										if (!((PlayerInfo*)(peer->data))->isGhost)
										{
											ENetPacket* packet5 = enet_packet_create(penter1.data,
												penter1.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet5);

											ENetPacket* packet6 = enet_packet_create(penter2.data,
												penter2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet6);

											ENetPacket* packet7 = enet_packet_create(penter3.data,
												penter3.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet7);

											ENetPacket* packet8 = enet_packet_create(penter4.data,
												penter4.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet8);

											ENetPacket* packet9 = enet_packet_create(penter5.data,
												penter5.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet9);

											ENetPacket* packet10 = enet_packet_create(penter6.data,
												penter6.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet10);

											ENetPacket* packet11 = enet_packet_create(penter7.data,
												penter7.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet11);

											ENetPacket* packet12 = enet_packet_create(penter8.data,
												penter8.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet12);
											GamePacket pis = packetEnd(appendInt(appendString(createPacket(), "OnInvis"), 0));

											memcpy(pis.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
											ENetPacket* packetpis = enet_packet_create(pis.data,
												pis.len,
												ENET_PACKET_FLAG_RELIABLE);

											enet_peer_send(currentPeer, 0, packetpis);
											delete pis.data;
											int x = ((PlayerInfo*)(peer->data))->x;
											int y = ((PlayerInfo*)(peer->data))->y;
											GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 91), x, y));
											ENetPacket* packetd = enet_packet_create(psp.data,
												psp.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packetd);
											delete psp.data;
										}


										if (((PlayerInfo*)(peer->data))->rawName != ((PlayerInfo*)(currentPeer->data))->rawName)
										{
											enet_peer_send(currentPeer, 0, packet3);
										}
									}
								}

								sendState(peer);
								sendClothes(peer);
							}

						}
						else if (str.substr(0, 8) == "/report ")
						{
							string imie = str.substr(8, cch.length() - 8 - 1);
							string dupa;
							string worldlocate;
							ENetPeer* currentPeer;
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "Player `w" + imie + "`o has been reported."));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (((PlayerInfo*)(currentPeer->data))->rawName == imie or ((PlayerInfo*)(currentPeer->data))->displayName == imie)
								{
									dupa = ((PlayerInfo*)(currentPeer->data))->rawName;
									worldlocate = " (In world: " + ((PlayerInfo*)(peer->data))->currentWorld + ")";



								}

								if (((PlayerInfo*)(currentPeer->data))->adminLevel == 1000 || ((PlayerInfo*)(currentPeer->data))->adminLevel == 999 || ((PlayerInfo*)(currentPeer->data))->adminLevel == 777 || ((PlayerInfo*)(currentPeer->data))->adminLevel == 888 || ((PlayerInfo*)(peer->data))->rawName == "admin") {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "[MOD LOGS]: Suspect `w" + dupa + "`o has been reported by " + ((PlayerInfo*)(peer->data))->rawName + worldlocate));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);
									delete p.data;
								}
							}
							cout << "Report from " << ((PlayerInfo*)(peer->data))->rawName << " in world " << ((PlayerInfo*)(peer->data))->currentWorld << std::dec << " reported -> " << dupa << endl;



						}
						else if (str == "/save")
						{
							if (adminlevel(((PlayerInfo*)(peer->data))->rawName) < 20) break;
							saveAllWorlds();

						}

						else if (str.substr(0, 8) == "/unmute ") {
							if (adminlevel(((PlayerInfo*)(peer->data))->rawName) < 666) break;
							if (str.substr(8, cch.length() - 8 - 1) == "saku") continue;
							if (str.substr(8, cch.length() - 8 - 1) == "nabz") continue;
							if (((PlayerInfo*)(peer->data))->rawName == str.substr(8, cch.length() - 8 - 1)) continue;



							ENetPeer* currentPeer;

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `#** `$The Ancient Ones `ohave `2unmute `2" + str.substr(6, cch.length() - 6 - 1) + " `#** `o(`4/rules `oto see the rules!)"));
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);


								if (((PlayerInfo*)(currentPeer->data))->rawName == str.substr(8, cch.length() - 8 - 1)) {
									if (((PlayerInfo*)(currentPeer->data))->haveGrowId == false) continue;

									GamePacket ps3d = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oNow you can talk again! (`$Duct Tape `omod removed)"));
									ENetPacket* packet3d = enet_packet_create(ps3d.data,
										ps3d.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet3d);

									GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`0Warning from `4System`0: You've been `2UNMUTED `0from Private Server for 730 days"), "audio/hub_open.wav"), 0));
									ENetPacket* packet2 = enet_packet_create(ps2.data,
										ps2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
									GamePacket ps3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oWarning from `4Admin`o: You've been `2Unmuted `ofrom Private Server"));
									ENetPacket* packet3 = enet_packet_create(ps3.data,
										ps3.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet3);
									((PlayerInfo*)(currentPeer->data))->isDuctaped = false;
									((PlayerInfo*)(currentPeer->data))->taped = false;
									sendState(currentPeer);
									if (((PlayerInfo*)(currentPeer->data))->isIn)
									{
										if (((PlayerInfo*)(currentPeer->data))->haveGrowId) {

											PlayerInfo* p = ((PlayerInfo*)(currentPeer->data));
											((PlayerInfo*)(currentPeer->data))->taped = false;
											string username = PlayerDB::getProperName(p->rawName);

											savejson(peer);
										}
									}

									// enet_peer_disconnect_later(currentPeer, 0);

								}

								enet_peer_send(currentPeer, 0, packet);

								//enet_host_flush(server);
							}
							delete p.data;
						}
						else if (str.substr(0, 6) == "/pban ") {

							if (((PlayerInfo*)(peer->data))->adminLevel >= 999) {
								if (str.substr(6, cch.length() - 6 - 1) == "") continue;
								if (((PlayerInfo*)(peer->data))->rawName == str.substr(6, cch.length() - 6 - 1)) {
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`#You are not allowed to ban yourself!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;

								}
								if ((str.substr(6, cch.length() - 6 - 1) == "nabz")) continue;

								if ((str.substr(11, cch.length() - 11 - 1) == "nabz") || (str.substr(11, cch.length() - 11 - 1) == "saku")) {
									//cout << "[WARNING]" << endl;
									ENetPeer* currentPeer;
									string name = ((PlayerInfo*)(peer->data))->rawName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4** `o" + name + " `4AUTO-BANNED BY SYSTEM **`o (/rules to view rules)"));


									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);

									}

									delete p.data;
									continue;

								}


								string username = PlayerDB::getProperName(str.substr(6, cch.length() - 6 - 1));

								bool existx = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(username) + ".json");
								if (!existx)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GrowFarm] `9Player `@Not Found! `4Ban `@Aborted!"));

									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}


								std::ifstream iffff("players/" + username + ".json");

								json jj;

								if (iffff.fail()) {
									iffff.close();
									continue;
								}
								if (iffff.is_open()) {


								}

								iffff >> jj; //load

								std::ofstream oo("players/" + username + ".json");
								if (!oo.is_open()) {
									cout << GetLastError() << endl;
									_getch();
								}
								jj["isBanned"] = 1;
								oo << jj << std::endl;

								//string bannamed = str.substr(6, cch.length() - 6 - 1);
								std::ofstream outfile("bans/" + username + ".txt");

								outfile << "user who banned this ID: " + ((PlayerInfo*)(peer->data))->rawName;

								outfile.close();


								cout << "Server operator " << ((PlayerInfo*)(peer->data))->rawName << " has banned " << str.substr(6, cch.length() - 6 - 1) << "." << endl;

								ENetPeer* currentPeer;

								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `4banned `2" + str.substr(6, cch.length() - 6 - 1) + " `#** `o(`4/rules `oto see the rules!)"));
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);

									if (((PlayerInfo*)(currentPeer->data))->rawName == PlayerDB::getProperName(str.substr(6, cch.length() - 6 - 1))) {
										if (((PlayerInfo*)(currentPeer->data))->haveGrowId == false) continue;
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave used `#Ban `oon `2" + str.substr(6, cch.length() - 6 - 1) + "`o! `#**"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`0Warning from `4System`0: You've been `4BANNED `0from GrowFarm for 730 days"), "audio/hub_open.wav"), 0));
										ENetPacket* packet2 = enet_packet_create(ps2.data,
											ps2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										GamePacket ps3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oWarning from `4System`o: You've been `4BANNED `ofrom GrowFarm for 730 days"));
										ENetPacket* packet3 = enet_packet_create(ps3.data,
											ps3.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet3);
										//j["receivedwarns"] = ((PlayerInfo*)(peer->data))->warns;
										//((PlayerInfo*)(currentPeer->data))->bans = ((PlayerInfo*)(peer->data))->bans + 1;
										delete ps.data;
										delete ps2.data;
										delete ps3.data;

										enet_peer_disconnect_later(currentPeer, 0);

									}

									enet_peer_send(currentPeer, 0, packet);

									//enet_host_flush(server);
								}
								delete p.data;


								GamePacket p6 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`1[MOD-LOGS] `6" + ((PlayerInfo*)(peer->data))->tankIDName + "`r(`6" + ((PlayerInfo*)(peer->data))->displayName + "`r) `4Just `2BANNED `4player `w" + PlayerDB::getProperName(str.substr(6, cch.length() - 6 - 1))));
								string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (!((PlayerInfo*)(currentPeer->data))->radio)
										continue;
									if (((PlayerInfo*)(currentPeer->data))->adminLevel == 777 || ((PlayerInfo*)(currentPeer->data))->adminLevel == 1000 || ((PlayerInfo*)(currentPeer->data))->adminLevel == 999 || ((PlayerInfo*)(currentPeer->data))->adminLevel == 888 || ((PlayerInfo*)(peer->data))->rawName == "admin") {
										ENetPacket* packet6 = enet_packet_create(p6.data,
											p6.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet6);




										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);

										//enet_host_flush(server);
									}
								}
								delete data;
								delete p6.data;
							}
						}
						else if (str.substr(0, 5) == "/spk ") {
							bool found = false;
							if (((PlayerInfo*)(peer->data))->adminLevel > 1000) {

								string msg_info = str;

								size_t extra_space = msg_info.find("  ");
								if (extra_space != std::string::npos) {
									msg_info.replace(extra_space, 2, " ");
								}

								string delimiter = " ";
								size_t pos = 0;
								string pm_user;
								string pm_message;
								if ((pos = msg_info.find(delimiter)) != std::string::npos) {
									msg_info.erase(0, pos + delimiter.length());
								}
								else {
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oPlease specify a `2player `oyou want your message to be delivered to."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
								}

								if ((pos = msg_info.find(delimiter)) != std::string::npos) {
									pm_user = msg_info.substr(0, pos);
									msg_info.erase(0, pos + delimiter.length());
								}
								else {
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oPlease enter your `2message`o."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
								}

								pm_message = msg_info;
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (((PlayerInfo*)(currentPeer->data))->rawName == PlayerDB::getProperName(pm_user)) {
										found = true;
										sendChatMessage(currentPeer, ((PlayerInfo*)(currentPeer->data))->netID, pm_message);
										sendConsoleMsg(peer, "`rPlayer `4" + ((PlayerInfo*)(currentPeer->data))->displayName + " `rhas just said `4" + pm_message);
									}

								}
								if (found == false)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `6Player " + PlayerDB::getProperName(pm_user) + " not found, remember to type all letters small."));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
								}
							}
						}
						else if (str.substr(0, 5) == "/pay ") {
							if (((PlayerInfo*)(peer->data))->level < 10) {
								Player::OnConsoleMessage(peer, "`9 You need to be atleast level 10 to use this feature");
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You need to be atleast level 10 to use this feature"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								break;
							}
							if (((PlayerInfo*)(peer->data))->haveGrowId) {
								if (((PlayerInfo*)(peer->data))->level > 10) {
									bool valid = true;
									string x = str.substr(5, cch.length() - 5 - 1);

									int pos = x.find(" ");
									string gemcount = x.substr(pos + 1);

									std::string addrWithMask(x);
									std::size_t pos1 = addrWithMask.find(" ");
									std::string playername = addrWithMask.substr(0, pos1);

									cout << "[!] /pay from " + ((PlayerInfo*)(peer->data))->rawName << " to: " + playername + " " + gemcount << endl;

									bool contains_non_alpha
										= !std::regex_match(gemcount, std::regex("^[0-9]+$"));

									for (char c : playername)
									{
										if (std::all_of(playername.begin(), playername.end(), isspace))
										{
											valid = false;
										}
									}

									if (contains_non_alpha || playername == "" || valid == false)
									{

										Player::OnConsoleMessage(peer, "`oInvalid syntax. Usage: /pay <name> <amount>``");
										break;

									}

									int gems = ((PlayerInfo*)(peer->data))->gem;
									if (atoi(gemcount.c_str()) > gems)
									{
										Player::OnConsoleMessage(peer, "`oNot enough `4gems`o.``");
										continue;
									}

									// peer variables
									bool found = false;
									// TODO GEM SYSTEM!!!
									int sgA1 = gems;
									int sgR1 = atoi(gemcount.c_str());
									int gemcalcminus = sgA1 - sgR1;
									// peer variables
									string pname = ((PlayerInfo*)(peer->data))->rawName;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;

										if (isHere(peer, currentPeer))
										{
											if (((PlayerInfo*)(currentPeer->data))->haveGrowId == false) {
												Player::OnConsoleMessage(peer, "`wPlayer does not have a GrowID!``");
												break;
											}
											if (PlayerDB::getProperName(playername) == ((PlayerInfo*)(currentPeer->data))->rawName) {
												string chkname = ((PlayerInfo*)(currentPeer->data))->rawName;

												if (chkname == PlayerDB::getProperName(((PlayerInfo*)(peer->data))->rawName))
												{
													break;
												}

												if (atoi(gemcount.c_str()) < 1)
												{
													found = true;
													Player::OnConsoleMessage(peer, "`oMaximum money amount is 1000000$`o.``");
													break;
												}

												if (atoi(gemcount.c_str()) > 1000000)
												{
													found = true;
													Player::OnConsoleMessage(peer, "`oMaximum money amount is 1000000$`o.``");
													break;

												}

												found = true;
												((PlayerInfo*)(peer->data))->gem = gemcalcminus;

												int sgA2 = ((PlayerInfo*)(currentPeer->data))->gem;
												int sgR2 = atoi(gemcount.c_str());
												int gemcalcplus = sgA2 + sgR2;
												((PlayerInfo*)(currentPeer->data))->gem = gemcalcplus;

												Player::OnSetBux(peer, gemcalcminus, 0);
												Player::OnSetBux(currentPeer, gemcalcplus, 0);
												time_t now = time(0);
												const char* dt = ctime(&now);
												tm* gmtm = gmtime(&now);
												dt = asctime(gmtm);
												std::string sendtime(dt);
												if (gmtm != NULL) {
												}
												else {
													break;
												}
												Player::OnConsoleMessage(peer, "`oSent `2" + gemcount + "$ `oto `$" + ((PlayerInfo*)(currentPeer->data))->displayName + ".``");
												((PlayerInfo*)(peer->data))->paid.push_back("[(`1" + sendtime + "`o): `oSent `2" + gemcount + "$ `oto `$" + ((PlayerInfo*)(currentPeer->data))->displayName + ".``");
												((PlayerInfo*)(currentPeer->data))->paid.push_back("(`1" + sendtime + "`o): `oReceived `2" + gemcount + "$ `ofrom `$" + ((PlayerInfo*)(peer->data))->displayName + ".``");
												Player::OnConsoleMessage(currentPeer, "`oReceived `2" + gemcount + "$ `ofrom `$" + ((PlayerInfo*)(peer->data))->displayName + ".``");
												savejson(peer);
												savejson(currentPeer);
												bool existx = std::experimental::filesystem::exists("players/" + pname + ".json");
												if (existx == false) {
													continue;
												}
												GamePacket p6 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `w[`cMOD LOGS `w- " + currentDateTime() + "`w] `2" + ((PlayerInfo*)(peer->data))->displayName + " (`$" + ((PlayerInfo*)(peer->data))->tankIDName + "`2) `wPayed `2" + ((PlayerInfo*)(currentPeer->data))->displayName + " `wfor `2" + gemcount + " `2gems``"));
												string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
												BYTE* data = new BYTE[5 + text.length()];
												BYTE zero = 0;
												int type = 3;
												memcpy(data, &type, 4);
												memcpy(data + 4, text.c_str(), text.length());
												memcpy(data + 4 + text.length(), &zero, 1);
												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (!((PlayerInfo*)(currentPeer->data))->radio)
														continue;
													if (((PlayerInfo*)(currentPeer->data))->adminLevel > 333) {
														ENetPacket* packet6 = enet_packet_create(p6.data,
															p6.len,
															ENET_PACKET_FLAG_RELIABLE);

														enet_peer_send(currentPeer, 0, packet6);




														ENetPacket* packet2 = enet_packet_create(data,
															5 + text.length(),
															ENET_PACKET_FLAG_RELIABLE);

														enet_peer_send(currentPeer, 0, packet2);

														//enet_host_flush(server);
													}
												}
											}
										}
									}
									if (found == false)
									{
										Player::OnConsoleMessage(peer, "`oPlayer not found!");
									}
								}
								else {
									sendConsoleMsg(peer, "You need atleast lvl 10+ to pay someone!");
								}

							}
						}
						else if (str.substr(0, 7) == "/level ") {
							if (((PlayerInfo*)(peer->data))->adminLevel == 1337) {
								((PlayerInfo*)(peer->data))->level = atoi(str.substr(7).c_str());
								int level = ((PlayerInfo*)(peer->data))->level;
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 Now your level are `2" + std::to_string(level) + "`0!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								savejson(peer);
							}
						}

						else if (str.substr(0, 4) == "/rgo") {
							string act = ((PlayerInfo*)(peer->data))->lastMsgWorld;
							if (act == "") {
								GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Unable to track down the location of the message."));
								ENetPacket* packet = enet_packet_create(po.data,
									po.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
							}
							else if (act == ((PlayerInfo*)(peer->data))->currentWorld) {
								GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Sorry, but you are already in the world!"));
								ENetPacket* packet = enet_packet_create(po.data,
									po.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
							}
							else {
								sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
								joinWorld(peer, act, 0, 0);
							}
						}

						else if (str.substr(0, 5) == "/ban ") {
							string playerCalled = PlayerDB::getProperName(str.substr(5, cch.length() - 5 - 1));

							((PlayerInfo*)(peer->data))->lastInfoAboutPlayer = playerCalled;

							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (((PlayerInfo*)(currentPeer->data))->rawName == playerCalled) {
									packet::dialog(peer, "\nadd_label|big|`wBan `^" + ((PlayerInfo*)(currentPeer->data))->rawName + "|left|\nadd_spacer|small|\nadd_smalltext|`9Ban time `w(`^Minutes`w) :|left|\nadd_text_input|bantime|||100|\nadd_smalltext|`wMax ban time is `443200 `w(`930 days`w)|left|\nadd_spacer|small|\nend_dialog|banplayer|Cancel|Ban Player|");
								}
							}
						}
						else if (str.substr(0, 6) == "/mute ") {
							string playerCalled = PlayerDB::getProperName(str.substr(6, cch.length() - 6 - 1));

							((PlayerInfo*)(peer->data))->lastInfoAboutPlayer = playerCalled;

							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (((PlayerInfo*)(currentPeer->data))->rawName == playerCalled) {
									packet::dialog(peer, "\nadd_label|big|`wMute `^" + ((PlayerInfo*)(currentPeer->data))->rawName + "|left|\nadd_spacer|small|\nadd_smalltext|`9Mute time `w(`^Minutes`w) :|left|\nadd_text_input|mutetime|||100|\nadd_smalltext|`wMax mute time is `410080 `w(`97 days`w)|left|\nadd_spacer|small|\nend_dialog|muteplayer|Cancel|Mute Player|");
								}
							}
						}
						else if (str.substr(0, 7) == "/ipban ")
						{

							if (!canSB(((PlayerInfo*)(peer->data))->rawName, ((PlayerInfo*)(peer->data))->tankIDPass))break;
							if (str.substr(7, cch.length() - 7 - 1) == "saku") continue;
							if ((str.substr(7, cch.length() - 7 - 1) == "nabz") || (str.substr(7, cch.length() - 7 - 1) == "nabz") || (str.substr(7, cch.length() - 7 - 1) == "nabz")) continue;
							if (((PlayerInfo*)(peer->data))->rawName == str.substr(7, cch.length() - 7 - 1)) continue;



							cout << "[!] Server operator " << ((PlayerInfo*)(peer->data))->rawName << " has ipbanned " << str.substr(7, cch.length() - 7 - 1) << "." << endl;

							ENetPeer* currentPeer;

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `#** `$The Ancient Ones `ohave `4ip-banned `2" + str.substr(7, cch.length() - 7 - 1) + " `#** `o(`4/rules `oto see the rules!)"));
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);

								if (((PlayerInfo*)(currentPeer->data))->rawName == str.substr(7, cch.length() - 7 - 1)) {
									if (((PlayerInfo*)(currentPeer->data))->haveGrowId == false) continue;
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `#** `$The Ancient Ones `ohave used `#Ip-Ban `oon `2" + str.substr(7, cch.length() - 7 - 1) + "`o! `#**"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);

									GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`0Warning from `4System`0: You've been `4BANNED `0from Private Server for 730 days"), "audio/hub_open.wav"), 0));
									ENetPacket* packet2 = enet_packet_create(ps2.data,
										ps2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
									GamePacket ps3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oWarning from `4System`o: You've been `4BANNED `ofrom Private Server for 730 days"));
									ENetPacket* packet3 = enet_packet_create(ps3.data,
										ps3.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet3);

									string ipban = "";
									std::ifstream ifs("ipban.json");
									ENetPeer* peer123 = currentPeer;
									string ip = std::to_string(peer123->address.host);
									if (ifs.is_open()) {

										json j3;
										ifs >> j3;
										ipban = j3["ip"].get<string>();
										ipban = ipban.append("|" + ip + "|");
									}
									std::ofstream od("ipban.json");
									if (od.is_open()) {

									}

									std::ofstream o("ipban.json");
									if (!o.is_open()) {
										cout << GetLastError() << endl;
										_getch();
									}
									json j;

									j["ip"] = ipban;
									o << j << std::endl;
									delete ps.data;
									enet_peer_disconnect_later(currentPeer, 0);

								}

								enet_peer_send(currentPeer, 0, packet);

								//enet_host_flush(server);
							}
							delete p.data;
						}
						else if (str.substr(0, 10) == "/giverank ") {

							if (((PlayerInfo*)(peer->data))->adminLevel <= 1000) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Invalid command `oEnter /? or /help for working commands!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							if (str.substr(10, cch.length() - 10 - 1) == "") continue;
							if (((PlayerInfo*)(peer->data))->rawName == str.substr(10, cch.length() - 10 - 1)) {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`#You are not allowed to edit your rank!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								continue;
							}


							string ban_info = str;

							size_t extra_space = ban_info.find("  ");
							if (extra_space != std::string::npos) {
								ban_info.replace(extra_space, 2, " ");
							}

							string delimiter = " ";
							size_t pos = 0;
							string ban_user;
							string ban_time;
							if ((pos = ban_info.find(delimiter)) != std::string::npos) {
								ban_info.erase(0, pos + delimiter.length());
							}
							else {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oUsage: /giverank <user> <rankname>"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete ps.data;
								continue;
							}

							if ((pos = ban_info.find(delimiter)) != std::string::npos) {
								ban_user = ban_info.substr(0, pos);
								ban_info.erase(0, pos + delimiter.length());
							}
							else {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oUsage: /giverank <user> <rankname>"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete ps.data;
								continue;
							}

							ban_time = ban_info;
							//cout << "administrator "<<((PlayerInfo*)(peer->data))->rawName <<"used /giverank " << ban_user << " " << ban_time;
							string playerName = ban_user;
							string rankName = ban_time;

							if (((PlayerInfo*)(peer->data))->rawName == playerName) continue;

							int countranks, rankNumber;
							string rankText;
							bool arRado = false;
							ifstream ranks("giverank.txt");
							ranks >> countranks;
							for (int i = 0; i < countranks; i++)
							{
								ranks >> rankNumber >> rankText;
								if (rankText == rankName)
								{
									arRado = true;
									break;
								}

							}
							ranks.close();
							if (arRado == false)
							{
								continue;
							}

							bool success = false;
							GiveRank(rankName, playerName, success);
							if (success)
							{
								cout << "administrator " << ((PlayerInfo*)(peer->data))->rawName << "used /giverank " << ban_user << " " << ban_time;



								ENetPeer* currentPeer;

								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `5Changed `2 " + playerName + "'s rank `8to " + rankName + ""));
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);

									if (((PlayerInfo*)(currentPeer->data))->rawName == playerName)
									{
										if (((PlayerInfo*)(currentPeer->data))->haveGrowId) {
											GamePacket ps3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oWarning from `4System`o: your rank has been `5Changed to `8" + rankName + ""));
											ENetPacket* packet3 = enet_packet_create(ps3.data,
												ps3.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet3);
											delete ps3.data;
											enet_peer_disconnect_later(currentPeer, 0);
										}
									}

								}
								delete p2.data;



								GamePacket p6 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`1[MOD-LOGS] `6" + ((PlayerInfo*)(peer->data))->tankIDName + "`r(`6" + ((PlayerInfo*)(peer->data))->displayName + "`r) `4Just `2GAVE THE `8" + rankName + "`2 RANK TO `4player `w" + playerName));
								string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (!((PlayerInfo*)(currentPeer->data))->radio)
										continue;
									if (((PlayerInfo*)(currentPeer->data))->adminLevel == 777 || ((PlayerInfo*)(currentPeer->data))->adminLevel == 1000 || ((PlayerInfo*)(currentPeer->data))->adminLevel == 999 || ((PlayerInfo*)(currentPeer->data))->adminLevel == 888 || ((PlayerInfo*)(peer->data))->rawName == "admin") {
										ENetPacket* packet6 = enet_packet_create(p6.data,
											p6.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet6);




										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);

										//enet_host_flush(server);
									}
								}
								delete data;
								delete p6.data;

							}
							else
							{
								GamePacket pse = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4An error occurred.`2It could be because you entered the wrong player name or rank name."));
								ENetPacket* packete = enet_packet_create(pse.data,
									pse.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packete);
								delete pse.data;
								continue;
							}
						}
						else if (str.substr(0, 11) == "/givelevel ") {
							string imie = str.substr(11, cch.length() - 11 - 1);
							int wls = 0;
							bool found = false;
							if (((PlayerInfo*)(peer->data))->adminLevel == 20) {
								ENetPeer* currentPeer;

								if (imie.find(" ") != std::string::npos)
								{
									wls = atoi(imie.substr(imie.find(" ") + 1).c_str());
									imie = imie.substr(0, imie.find(" "));
								}
								int a = 0;
								int b = 0;
								bool exist = std::experimental::filesystem::exists("claim/" + imie + ".json");
								if (!exist)
								{
									std::ofstream o("claim/" + imie + ".json");
									if (!o.is_open()) {
										cout << GetLastError() << endl;
										_getch();
									}
									json j;
									j["gems"] = 0;
									j["wls"] = 0;
									j["level"] = 0;
									o << j << std::endl;
								}
								std::ifstream ifff("claim/" + imie + ".json");


								if (ifff.fail()) {
									ifff.close();


								}
								if (ifff.is_open()) {
								}
								json j;
								ifff >> j; //load

								a = j["level"];
								b = wls + a;

								std::ifstream iff("claim/" + imie + ".json");


								if (iff.fail()) {
									iff.close();


								}
								if (iff.is_open()) {
								}
								json x;
								iff >> x; //load

								x["level"] = b;


								std::ofstream oo("claim/" + imie + ".json"); //save
								if (!oo.is_open()) {
									cout << GetLastError() << endl;
									_getch();
								}

								oo << x << std::endl;

								GamePacket p41 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oYou gave `5" + imie + " `2" + std::to_string(wls) + " `9Levels"));
								ENetPacket* packet41 = enet_packet_create(p41.data,
									p41.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet41);
								delete p41.data;



								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (((PlayerInfo*)(currentPeer->data))->rawName == imie) {
										found = true;

										GamePacket ps = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`wMessage from `4Admin`0: `2 We `5have sent your `1Level's `7Do `o/claim``"), "audio/hub_open.wav"), 0));

										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete ps.data;
									}


								}

							}

						}
						else if (str.substr(0, 10) == "/givegems ") {
							string imie = str.substr(10, cch.length() - 10 - 1);
							int wls = 0;
							bool found = false;
							if (((PlayerInfo*)(peer->data))->adminLevel == 1337) {
								ENetPeer* currentPeer;

								if (imie.find(" ") != std::string::npos)
								{
									wls = atoi(imie.substr(imie.find(" ") + 1).c_str());
									imie = imie.substr(0, imie.find(" "));
								}
								bool exist = std::experimental::filesystem::exists("claim/" + imie + ".json");
								if (!exist)
								{
									std::ofstream o("claim/" + imie + ".json");
									if (!o.is_open()) {
										cout << GetLastError() << endl;
										_getch();
									}
									json j;
									j["gems"] = 0;
									j["wls"] = 0;
									j["level"] = 0;
									o << j << std::endl;
								}

								std::ifstream ifff("claim/" + imie + ".json");


								if (ifff.fail()) {
									ifff.close();


								}
								if (ifff.is_open()) {
								}
								json xf;
								ifff >> xf; //load

								int bs = xf["gems"];
								int b = bs + wls;

								std::ifstream iff("claim/" + imie + ".json");


								if (iff.fail()) {
									iff.close();


								}
								if (iff.is_open()) {
								}
								json x;
								iff >> x; //load
								x["gems"] = b;


								std::ofstream oo("claim/" + imie + ".json"); //save
								if (!oo.is_open()) {
									cout << GetLastError() << endl;
									_getch();
								}

								oo << x << std::endl;

								GamePacket p41 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oYou gave `5" + imie + " `2" + std::to_string(wls) + " `9Gems"));
								ENetPacket* packet41 = enet_packet_create(p41.data,
									p41.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet41);
								delete p41.data;



								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (((PlayerInfo*)(currentPeer->data))->rawName == imie) {
										found = true;
										GamePacket ps = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`wMessage from `4Admin`0: `2 We `5have sent your `1Gems `7Do `o/claim``"), "audio/hub_open.wav"), 0));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete ps.data;
									}
								}
							}
						}
						else if (str == "/claim") {
							claim(peer);
						}
						else if (str.substr(0, 8) == "/demote ") {
							if (((PlayerInfo*)(peer->data))->rawName == "nabz" || ((PlayerInfo*)(peer->data))->rawName == "saku" || ((PlayerInfo*)(peer->data))->rawName == "nabz" || ((PlayerInfo*)(peer->data))->rawName == "nabz") {
								string name = str.substr(8, str.length());


								ENetPeer* currentPeer;


								bool found = false;


								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;


									string name2 = ((PlayerInfo*)(currentPeer->data))->rawName;


									std::transform(name.begin(), name.end(), name.begin(), ::tolower);
									std::transform(name2.begin(), name2.end(), name2.begin(), ::tolower);


									if (name == name2) {
										GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "You has been `4DEMOTED`o!"), "audio/hub_open.wav"), 0));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										((PlayerInfo*)(currentPeer->data))->adminLevel = 0;
										std::ifstream ifff("players/" + ((PlayerInfo*)(currentPeer->data))->rawName + ".json");


										if (ifff.fail()) {
											ifff.close();


										}
										if (ifff.is_open()) {
										}
										json j;
										ifff >> j; //load


										j["adminLevel"] = ((PlayerInfo*)(currentPeer->data))->adminLevel; //edit




										std::ofstream o("players/" + ((PlayerInfo*)(currentPeer->data))->rawName + ".json"); //save
										if (!o.is_open()) {
											cout << GetLastError() << endl;
											_getch();
										}

										o << j << std::endl;
										found = true;
										enet_peer_disconnect_later(currentPeer, 0);
									}
								}
								if (found) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `9You give vip to player " + name + "."));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);

									delete p.data;
								}
								else {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `4Player not found!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);

									delete p.data;
								}
							}
						}


						else if (str == "/unequip")
						{
							((PlayerInfo*)(peer->data))->cloth_hair = 0;
							((PlayerInfo*)(peer->data))->cloth_shirt = 0;
							((PlayerInfo*)(peer->data))->cloth_pants = 0;
							((PlayerInfo*)(peer->data))->cloth_feet = 0;
							((PlayerInfo*)(peer->data))->cloth_face = 0;
							((PlayerInfo*)(peer->data))->cloth_hand = 0;
							((PlayerInfo*)(peer->data))->cloth_back = 5250;
							((PlayerInfo*)(peer->data))->cloth_mask = 0;
							((PlayerInfo*)(peer->data))->cloth_necklace = 0;
							((PlayerInfo*)(peer->data))->cloth_ances = 0;
							((PlayerInfo*)(peer->data))->peffect = 8421376;
							sendClothes(peer);
							sendState(peer);
							sendPuncheffect(peer);
						}
						else if (str == "/nicked") {
							if (((PlayerInfo*)(peer->data))->adminLevel >= 1000 || ((PlayerInfo*)(peer->data))->rawName == "admin") {
								string x = "";


								ENetPeer* currentPeer;


								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;


									if (((PlayerInfo*)(currentPeer->data))->adminLevel > 333) {

										string name = ((PlayerInfo*)(currentPeer->data))->displayName;

										if ((((PlayerInfo*)(currentPeer->data))->isNicked == true))
										{

											x.append("`w'" + ((PlayerInfo*)(currentPeer->data))->displayName + "'" + "->" + ((PlayerInfo*)(currentPeer->data))->rawName + "``, ");

										}











									}


								}
								x = x.substr(0, x.length() - 2);


								if (x == "")
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "``Nicked vips/mods/devs: None visible."));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "``Nicked vips/mods/devs: " + x));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);

									delete p.data;
								}

							}
						}
						else if (str.substr(0, 6) == "/item ") {
							try {
								if (((PlayerInfo*)(peer->data))->adminLevel == 20) {

									int bitem = atoi(str.substr(6, cch.length() - 6 - 1).c_str());
									int intid = atoi(str.substr(6, cch.length() - 6 - 1).c_str());
									int ide = atoi(str.substr(6, cch.length() - 6 - 1).c_str());


									int devitem = atoi(str.substr(6, cch.length() - 6 - 1).c_str());
									if (devitem == 0 || devitem < 1)

									{

										continue;
									}


									else {
										string id = (str.substr(6, cch.length() - 6 - 1).c_str());
										if (getItemDef(intid).rarity == 999) {
											player::consolemessage(peer, "`oGiven`w 200 " + getItemDef(intid).name + "`o.");
										}
										else {
											player::consolemessage(peer, "`oGiven`w 200 " + getItemDef(intid).name + "`o.");
										}
										bool success = true;
										SaveShopsItemMoreTimes(intid, 200, peer, success);
										SendTradeEffect(peer, intid, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->netID, 150);

									}
								}
								else {
									player::consolemessage(peer, "`oThats not possble bro.");
									break;
								}
							}
							catch (std::invalid_argument& e) {
								break;
							}
							catch (const std::out_of_range& e) {
								break;
							}
							catch (...) {
								break;
							}
						}
						else if (str.substr(0, 5) == "/find") {
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wFind item``|left|3802|\nadd_textbox|Enter a word below to find the item|\nadd_text_input|item|Item Name||30|\nend_dialog|findid|Cancel|Find the item!|\nadd_quick_exit|\n"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);

							//enet_host_flush(server);
							delete p.data;

						}
						else if (str == "/mods") {
							string x;

							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;

								if (((PlayerInfo*)(currentPeer->data))->adminLevel > 333) {
									x.append(((PlayerInfo*)(currentPeer->data))->displayName + "``, ");

								}

							}
							x = x.substr(0, x.length() - 2);

							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oModerators Online: " + x));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
						}
						else if (str == "/lock") {
							bool success = true;
							SaveShopsItemMoreTimes(242, 10, peer, success);
							SaveShopsItemMoreTimes(1796, 2, peer, success);
							SaveShopsItemMoreTimes(4428, 1, peer, success);
							SaveShopsItemMoreTimes(7188, 1, peer, success);
						}
						else if (str == "/help" || str == "/?") {
							if (((PlayerInfo*)(peer->data))->adminLevel == 1337) {
								Player::OnConsoleMessage(peer, "`9[Normal Commands]`o /help, /msg, /r (reply), /me (message), /bc (text), /sb (text), /time, /news, /radio, /rules, /mods, /warp");
								Player::OnConsoleMessage(peer, "`6[Emote Commands]`o /cry, /dance, /dab, /furious, /mad, /cheer, /sassy, /fold, /troll, /sleep, /fp, /sad, /omg");
								Player::OnConsoleMessage(peer, "`8[Custom Commands]`o /pay `9<name> `8<amount>`o, /unequip, /find, /equip, /mod, /unmod, /online, /color `9<number>`o");
								Player::OnConsoleMessage(peer, "`6[Admin Commands]`o /curse `9<name>`o, /mute `9<name>`o, /nuke, /warpto `9<name>`o, /summon `9<name>`o");
								Player::OnConsoleMessage(peer, "`8[Owner Commands]`o /givegems `9<name> `8<amount>`o, /givelevel `9<name> `8<amount>`o, /give `9<amount>`o, /giverank `9<name> `8<rank>`o, /level `9<amount>`o, /invis, /invite, /hardban `9<name>`o, /deviceban `9<name>`o.");
								if (((PlayerInfo*)(peer->data))->rawName == world->owner) {
									Player::OnConsoleMessage(peer, "`9[WorldOwner Commands]`o /access `9<name>`o, /unacc `9<name>`o, /pull, /ban ");
								}
							}
							else if (((PlayerInfo*)(peer->data))->adminLevel == 777) {
								Player::OnConsoleMessage(peer, "`9[Normal Commands]`o /help, /msg, /r (reply), /me (message), /bc (text), /sb (text), /time, /news, /radio, /rules, /mods, /warp");
								Player::OnConsoleMessage(peer, "`6[Emote Commands]`o /cry, /dance, /dab, /furious, /mad, /cheer, /sassy, /fold, /troll, /sleep, /fp, /sad, /omg");
								Player::OnConsoleMessage(peer, "`8[Custom Commands]`o /pay `9<name> `8<amount>`o, /unequip, /find, /equip, /mod, /unmod, /online, /color `9<number>`o");
								Player::OnConsoleMessage(peer, "`6[Admin Commands]`o /curse `9<name>`o, /mute `9<name>`o, /nuke, /warpto `9<name>`o, /summon `9<name>`o");
								if (((PlayerInfo*)(peer->data))->rawName == world->owner) {
									Player::OnConsoleMessage(peer, "`9[WorldOwner Commands]`o /access `9<name>`o, /unacc `9<name>`o, /pull, /ban ");
								}
							}
							else if (((PlayerInfo*)(peer->data))->adminLevel == 0) {
								Player::OnConsoleMessage(peer, "`9[Normal Commands]`o /help, /msg, /r (reply), /me (message), /bc (text), /sb (text), /time, /news, /radio, /rules, /mods, /warp");
								Player::OnConsoleMessage(peer, "`6[Emote Commands]`o /cry, /dance, /dab, /furious, /mad, /cheer, /sassy, /fold, /troll, /sleep, /fp, /sad, /omg");
								Player::OnConsoleMessage(peer, "`8[Custom Commands]`o /pay `9<name> `8<amount>`o, /unequip, /find, /equip, /mod, /unmod, /online, /color `9<number>`o");
								if (((PlayerInfo*)(peer->data))->rawName == world->owner) {
									Player::OnConsoleMessage(peer, "`9[WorldOwner Commands]`o /access `9<name>`o, /unacc `9<name>`o, /pull, /ban ");
								}
							}
						}
						else if (str.substr(0, 3) == "/a ") {
							ENetPeer* currentPeer;
							int imie = atoi(str.substr(3, cch.length() - 3 - 1).c_str());

							if (imie == 0) continue;
							if (imie == hasil) {
								resultnbr1 = 0;
								resultnbr2 = 0;
								hasil = 0;

								((PlayerInfo*)(peer->data))->gem = ((PlayerInfo*)(peer->data))->gem + prize;
								prize = 0;

								GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet);
								delete p.data;
								savejson(peer);
								string nama = ((PlayerInfo*)(peer->data))->displayName;
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									sendConsole(currentPeer, "`w** `eGrowFarn Private Server `1Daily Math: (party) Math Event Winner is `w" + nama + "`9!");
									sendSound(currentPeer, "pinata_lasso.wav");

								}
							}
						}
						/*else if (str == "/information") {
						PlayerInfo* info = ((PlayerInfo*)(peer->data));
						cout << info->tankIDName << endl;
						cout << info->tankIDPass << endl;
						cout << info->requestedName << endl;
						cout << info->f << endl;
						cout << info->protocol << endl;
						cout << info->gameVersion << endl;
						cout << info->fz << endl;
						cout << info->lmode << endl;
						cout << info->cbits << endl;
						cout << info->playerage << endl;
						cout << info->GDPR << endl;
						cout << info->hash2 << endl;
						cout << info->meta << endl;
						cout << info->fhash << endl;
						cout << info->rid << endl;
						cout << info->platformid << endl;
						cout << info->deviceversion << endl;
						cout << info->hash << endl;
						cout << info->mac << endl;
						cout << info->reconnect << endl;
						cout << info->wk << endl;
						cout << info->zf << endl;


						}*/
						else if (str.substr(0, 6) == "/pull ")
						{
							cout << "/pull from " << ((PlayerInfo*)(peer->data))->displayName << endl;
							WorldInfo* world = getPlyersWorld(peer);
							if (((PlayerInfo*)(peer->data))->rawName == world->owner)
							{
								ENetPeer* currentPeer;
								string imie = str.substr(6, cch.length() - 6 - 1);
								int x = ((PlayerInfo*)(peer->data))->x;
								int y = ((PlayerInfo*)(peer->data))->y;
								string dupa;
								GamePacket pmsg = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`o" + ((PlayerInfo*)(peer->data))->displayName + " `5pulls " + imie));
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										if (((PlayerInfo*)(currentPeer->data))->rawName == imie or ((PlayerInfo*)(currentPeer->data))->displayName == imie)
										{
											dupa = ((PlayerInfo*)(currentPeer->data))->rawName;
											PlayerMoving data;
											data.packetType = 0x0;
											data.characterState = 0x924; // animation
											data.x = x;
											data.y = y;
											data.punchX = -1;
											data.punchY = -1;
											data.XSpeed = 0;
											data.YSpeed = 0;
											data.netID = ((PlayerInfo*)(currentPeer->data))->netID;
											data.plantingTree = 0x0;
											SendPacketRaw(4, packPlayerMoving(&data), 56, 0, currentPeer, ENET_PACKET_FLAG_RELIABLE);
											GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), x, y));
											memcpy(p2.data + 8, &(((PlayerInfo*)(currentPeer->data))->netID), 4);
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											delete p2.data;
										}
									}
								}
								ENetPacket* packetmsg = enet_packet_create(pmsg.data,
									pmsg.len,
									ENET_PACKET_FLAG_RELIABLE);
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										enet_peer_send(currentPeer, 0, packetmsg);
									}
								}
								delete pmsg.data;
							}
							else
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "You need to be world owner to use that command."));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;

							}
						}
						else if (str == "/cry")
						{
							GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), ":'("), 0));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer))
								{
									enet_peer_send(currentPeer, 0, packet2);
								}
							}
							delete p2.data;
							continue;
						}
						else if (str == "/bluename") {

							if (((PlayerInfo*)(peer->data))->level < 50)
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oYou need to be level `1125 `wto do that!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), ((PlayerInfo*)(peer->data))->country + "|showGuild|maxLevel"));
										memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										delete p2.data;
									}
								}
							}
						}
						else if (str == "/unbluename") {

							if (((PlayerInfo*)(peer->data))->level < 50)
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oYou need to be level `1125 `wto do that!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), ((PlayerInfo*)(peer->data))->country + "|showGuild"));
										memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										delete p2.data;
									}
								}
							}
						}
						else if (str.substr(0, 4) == "/me ")
						{
							if (((PlayerInfo*)(peer->data))->isDuctaped == false && ((PlayerInfo*)(peer->data))->haveGrowId == true)
							{
								string namer = ((PlayerInfo*)(peer->data))->displayName;
								GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`#<`w" + namer + " `#" + str.substr(3, cch.length() - 3 - 1).c_str() + "`5>"), 0));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `w<" + namer + " `#" + str.substr(3, cch.length() - 3 - 1).c_str() + "`w>"));
								ENetPacket* packet3 = enet_packet_create(p3.data,
									p3.len,
									ENET_PACKET_FLAG_RELIABLE);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										enet_peer_send(currentPeer, 0, packet2);
										enet_peer_send(currentPeer, 0, packet3);
									}
								}
								delete p2.data;
								delete p3.data;
								continue;
							}
						}
						else if (str == "/news") {
							sendGazette(peer);
						}
						else if (str == "/clearchat") {
							GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"));
							ENetPacket* packet0 = enet_packet_create(p0.data,
								p0.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet0);
							delete p0.data;
							GamePacket p02 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`wCleared chat!"));
							ENetPacket* packet02 = enet_packet_create(p02.data,
								p02.len,
								ENET_PACKET_FLAG_RELIABLE);

							enet_peer_send(peer, 0, packet02);
							delete p02.data;
						}
						else if (str.substr(0, 6) == "/clear") {
							if (((PlayerInfo*)(peer->data))->adminLevel <= 999) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Sorry! `^But this command is unavailable!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							if (((PlayerInfo*)(peer->data))->adminLevel >= 1000 || ((PlayerInfo*)(peer->data))->rawName == "cat") {

								WorldInfo* wrld = getPlyersWorld(peer);

								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (((PlayerInfo*)(currentPeer->data))->currentWorld == wrld->name)
									{
										string act = ((PlayerInfo*)(peer->data))->currentWorld;
										//WorldInfo info = worldDB.get(act);
										// sendWorld(currentPeer, &info);
										int x = 3040;
										int y = 736;



										for (int i = 0; i < world->width * world->height; i++)
										{
											if (world->items[i].foreground == 6) {
												//world->items[i].foreground =0;
											}
											else if (world->items[i].foreground == 8) {

											}
											else if (world->items[i].foreground == 242 || world->items[i].foreground == 2408 || world->items[i].foreground == 1796 || world->items[i].foreground == 4428 || world->items[i].foreground == 7188) {

											}
											else {
												world->items[i].foreground = 0;
												world->items[i].background = 0;
											}
										}

										sendPlayerLeave(currentPeer, (PlayerInfo*)(currentPeer->data));
										joinWorld(currentPeer, act, 0, 0);

										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^World Cleared!"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
										continue;





									}

								}
							}
						}
						else if (str == "/time") {
							sendTime(peer);
						}
						else if (str == "/howgay") {
							ENetPeer* currentPeer;
							int val = rand() % 100;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer))
								{
									GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`w" + ((PlayerInfo*)(peer->data))->displayName + " `oare `2" + std::to_string(val) + "% `wgay!"), 0));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
									delete p2.data;
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), ((PlayerInfo*)(peer->data))->displayName + " `ware `2%" + std::to_string(val) + " `wgay!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(currentPeer, 0, packet0);
									delete p0.data;
								}
							}
						}
						else if (str == "/uba") {
							if (((PlayerInfo*)(peer->data))->haveGrowId && ((PlayerInfo*)(peer->data))->rawName == getPlyersWorld(peer)->owner || ((PlayerInfo*)(peer->data))->adminLevel > 333) {
								namespace fs = std::experimental::filesystem;
								fs::remove_all("worldbans/" + getPlyersWorld(peer)->name);

								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oYou unbanned everyone from the world!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}

						else if (str.substr(0, 9) == "/uncurse ") { // code by playingohd gaming
							if (((PlayerInfo*)(peer->data))->adminLevel <= 666) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Invalid command `oEnter /? or /help for working commands!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}



							if (str.substr(9, cch.length() - 9 - 1) == "") continue;
							if (((PlayerInfo*)(peer->data))->rawName == str.substr(9, cch.length() - 9 - 1)) continue;
							if ((str.substr(9, cch.length() - 9 - 1) == "saku") || (str.substr(9, cch.length() - 9 - 1) == "nabz")) continue;
							string cursename = str.substr(9, cch.length() - 9 - 1);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4System-Message:`2 " + cursename + " has been uncursed."));
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(currentPeer, 0, packet);
								remove(("cursedplayers/" + cursename + ".txt").c_str());
								if (((PlayerInfo*)(currentPeer->data))->rawName == cursename)
								{
									((PlayerInfo*)(currentPeer->data))->skinColor = 0x8295C3FF;
									sendClothes(currentPeer);
									((PlayerInfo*)(currentPeer->data))->isCursed = false;
									sendState(currentPeer);


								}
							}
							delete p.data;


							GamePacket p6 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`1[MOD-LOGS] `6" + ((PlayerInfo*)(peer->data))->tankIDName + "`r(`6" + ((PlayerInfo*)(peer->data))->displayName + "`r) `4Just `2UNCURSED `4player `w" + PlayerDB::getProperName(str.substr(9, cch.length() - 9 - 1))));
							string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
							BYTE* data = new BYTE[5 + text.length()];
							BYTE zero = 0;
							int type = 3;
							memcpy(data, &type, 4);
							memcpy(data + 4, text.c_str(), text.length());
							memcpy(data + 4 + text.length(), &zero, 1);

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (!((PlayerInfo*)(currentPeer->data))->radio)
									continue;
								if (((PlayerInfo*)(currentPeer->data))->adminLevel == 777 || ((PlayerInfo*)(currentPeer->data))->adminLevel == 1000 || ((PlayerInfo*)(currentPeer->data))->adminLevel == 999 || ((PlayerInfo*)(currentPeer->data))->adminLevel == 888 || ((PlayerInfo*)(peer->data))->rawName == "admin") {
									ENetPacket* packet6 = enet_packet_create(p6.data,
										p6.len,
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(currentPeer, 0, packet6);




									ENetPacket* packet2 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(currentPeer, 0, packet2);

									//enet_host_flush(server);
								}
							}
							delete data;
							delete p6.data;

						}
						else if (str.substr(0, 9) == "/copyset ") {
							if (((PlayerInfo*)(peer->data))->adminLevel >= 0) {

								string name = str.substr(9, cch.length() - 9 - 1);
								int netID = ((PlayerInfo*)(peer->data))->netID;
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;

									if (((PlayerInfo*)(currentPeer->data))->rawName == name || ((PlayerInfo*)(currentPeer->data))->tankIDName == name) {
										((PlayerInfo*)(peer->data))->cloth_hair = ((PlayerInfo*)(currentPeer->data))->cloth_hair;
										((PlayerInfo*)(peer->data))->cloth_shirt = ((PlayerInfo*)(currentPeer->data))->cloth_shirt;
										((PlayerInfo*)(peer->data))->cloth_pants = ((PlayerInfo*)(currentPeer->data))->cloth_pants;
										((PlayerInfo*)(peer->data))->cloth_feet = ((PlayerInfo*)(currentPeer->data))->cloth_feet;
										((PlayerInfo*)(peer->data))->cloth_face = ((PlayerInfo*)(currentPeer->data))->cloth_face;
										((PlayerInfo*)(peer->data))->cloth_back = ((PlayerInfo*)(currentPeer->data))->cloth_back;
										((PlayerInfo*)(peer->data))->cloth_mask = ((PlayerInfo*)(currentPeer->data))->cloth_mask;
										((PlayerInfo*)(peer->data))->cloth_necklace = ((PlayerInfo*)(currentPeer->data))->cloth_necklace;
										((PlayerInfo*)(peer->data))->skinColor = ((PlayerInfo*)(currentPeer->data))->skinColor;
										sendClothes(peer);

										GamePacket p1 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^You `9Copied `@Player `4" + ((PlayerInfo*)(currentPeer->data))->displayName + "`^ Clothes!"));
										string text = "action|play_sfx\nfile|audio/change_clothes.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length());
										memcpy(data + 4 + text.length(), &zero, 1);

										ENetPacket* packet1 = enet_packet_create(p1.data,
											p1.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet1);

										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(peer, 0, packet2);

										delete p1.data;
										delete data;
									}
								}
							}
						}
						else if (str.substr(0, 8) == "/warpto ") {
							if (((PlayerInfo*)(peer->data))->adminLevel > 777) {
								string name = str.substr(8, str.length());


								ENetPeer* currentPeer;


								bool found = false;


								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;


									string name2 = ((PlayerInfo*)(currentPeer->data))->rawName;


									std::transform(name.begin(), name.end(), name.begin(), ::tolower);
									std::transform(name2.begin(), name2.end(), name2.begin(), ::tolower);


									if (name == name2) {
										if (((PlayerInfo*)(currentPeer->data))->currentWorld == "EXIT")
										{
											//std::this_thread::sleep_for(std::chrono::milliseconds(200));
										}
										else
										{
											sendPlayerToPlayer(peer, currentPeer);
											found = true;
										}

									}
								}
								if (found) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Warping to player."));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);

									delete p.data;
								}
								else {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `4Player not found or is currently in EXIT."));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);

									delete p.data;
								}
							}


						}
						else if (str.substr(0, 6) == "/warp ") {


							string world = str.substr(6, str.length());
							std::transform(world.begin(), world.end(), world.begin(), ::toupper);
							if (world == "SERVER" && ((PlayerInfo*)(peer->data))->adminLevel != 1000)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@You can't warp to `9Server`@!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								continue;
							}

							if (((PlayerInfo*)(peer->data))->currentWorld == "HELL")
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@You can't warp from this world`@!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								continue;
							}

							if (world == "EXIT")
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@You can't warp to `9Exit`@!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								continue;
							}
							else
							{
								bool contains_non_alpha
									= !std::regex_match(world, std::regex("^[A-Za-z0-9]+$"));

								if (contains_non_alpha == true)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Warping Failed! Only Letters / Numbers Allowed`@!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								else
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Magically `^Warped To `4" + world + "`^!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);



									sendPlayerToWorld(peer, (PlayerInfo*)(peer->data), world);
								}
							}
						}
						else if (str.substr(0, 8) == "/summon ") {
							if (((PlayerInfo*)(peer->data))->adminLevel > 18) {
								if ((str.substr(8, cch.length() - 8 - 1) == "baskerville")) continue;
								string name = str.substr(8, str.length());


								ENetPeer* currentPeer;


								bool found = false;


								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;


									string name2 = ((PlayerInfo*)(currentPeer->data))->rawName;


									std::transform(name.begin(), name.end(), name.begin(), ::tolower);
									std::transform(name2.begin(), name2.end(), name2.begin(), ::tolower);


									if (name == name2) {
										GamePacket pox = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You were summoned by a mod."));
										ENetPacket* packetpox = enet_packet_create(pox.data,
											pox.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packetpox);
										updateAllClothes(currentPeer);
										sendClothes(currentPeer);
										sendPlayerToPlayer(currentPeer, peer);
										found = true;
									}


								}
								string name2 = ((PlayerInfo*)(currentPeer->data))->rawName;
								if (found) {
									GamePacket pox = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You summoned `6" + name2 + ""));
									ENetPacket* packetpox = enet_packet_create(pox.data,
										pox.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packetpox);
								}
								else {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5Player not found!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
								}
							}


						}
						
						else if (str.substr(0, 5) == "/msg ") {
							bool found = false;


							string msg_info = str;

							size_t extra_space = msg_info.find("  ");
							if (extra_space != std::string::npos) {
								msg_info.replace(extra_space, 2, " ");
							}

							string delimiter = " ";
							size_t pos = 0;
							string pm_user;
							string pm_message;
							if ((pos = msg_info.find(delimiter)) != std::string::npos) {
								msg_info.erase(0, pos + delimiter.length());
							}
							else {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oPlease specify a `2player `oyou want your message to be delivered to."));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete ps.data;
								break;
							}

							if ((pos = msg_info.find(delimiter)) != std::string::npos) {
								pm_user = msg_info.substr(0, pos);
								msg_info.erase(0, pos + delimiter.length());
							}
							else {
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oPlease enter your `2message`o."));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete ps.data;
								break;
							}

							pm_message = msg_info;
							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (((PlayerInfo*)(currentPeer->data))->rawName == PlayerDB::getProperName(pm_user)) {

									((PlayerInfo*)(currentPeer->data))->lastMsger = ((PlayerInfo*)(peer->data))->rawName;
									((PlayerInfo*)(currentPeer->data))->lastMsgerTrue = ((PlayerInfo*)(currentPeer->data))->displayName;
									((PlayerInfo*)(currentPeer->data))->lastMsgWorld = ((PlayerInfo*)(peer->data))->currentWorld;

									//sendConsoleMsg(peer, "`6" + str);
									GamePacket p0;
									if (((PlayerInfo*)(currentPeer->data))->adminLevel == 1337) {
										p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `6>> (Sent to `$" + ((PlayerInfo*)(currentPeer->data))->tankIDName + "`6) `o(`4Note: ``Message a mod `4ONLY ONCE `oabout an issue. Mods dont fix scams or replace gems, they punish players who break the `5/rules`o. For issues related to account recovery or purchasing, send message to creators on discord.)"));
									}
									else {
										p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `6>> (Sent to `$" + ((PlayerInfo*)(currentPeer->data))->tankIDName + "`6)"));
									}
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									GamePacket p10 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `6>> (Sent to `$" + ((PlayerInfo*)(currentPeer->data))->tankIDName + "`6) `o(`4Note: ``Message a mod `4ONLY ONCE `oabout an issue. Mods dont fix scams or replace gems, they punish players who break the `5/rules`o. For issues related to account recovery or purchasing, send message to creators on discord.)"));
									ENetPacket* packet10 = enet_packet_create(p10.data,
										p10.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									delete p10.data;
									found = true;
									GamePacket ps;
									if (((PlayerInfo*)(currentPeer->data))->adminLevel == 1337) {
										ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 CP:0_PL:2_OID:_CT:[MSG]_ `c>> from (`w" + ((PlayerInfo*)(peer->data))->displayName + "`c) in [`4<HIDDEN>`c] > `$" + pm_message));
									}
									else {
										ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 CP:0_PL:2_OID:_CT:[MSG]_ `c>> from (`w" + ((PlayerInfo*)(peer->data))->displayName + "`c) in [`$" + ((PlayerInfo*)(peer->data))->currentWorld + "`c] > `$" + pm_message));
									}
									string text = "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPacket* packet2 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(currentPeer, 0, packet2);
									delete data;
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);
									delete ps.data;
									break;
								}

							}
							if (found == false)
							{
								GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `6Player " + PlayerDB::getProperName(pm_user) + " not found, remember to type all letters small."));
								ENetPacket* packet0 = enet_packet_create(p0.data,
									p0.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet0);
								delete p0.data;
							}
						}
						else if (str.substr(0, 3) == "/r ") {
							if (((PlayerInfo*)(peer->data))->haveGrowId == false) {
								GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `oTo prevent abuse, you `4must `obe `2registered `oin order to use this command!"));
								ENetPacket* packet0 = enet_packet_create(p0.data,
									p0.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet0);
								delete p0.data;
								continue;
							}


							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastMsger) {

									((PlayerInfo*)(currentPeer->data))->lastMsger = ((PlayerInfo*)(peer->data))->rawName;
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `6>> (Sent to `2" + ((PlayerInfo*)(peer->data))->lastMsger + "`6)"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `6>> Private msg from `2" + ((PlayerInfo*)(peer->data))->displayName + "`6 (`$in " + ((PlayerInfo*)(peer->data))->currentWorld + "`6) : " + str.substr(3, cch.length() - 3 - 1) + "`o"));
									string text = "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPacket* packet2 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(currentPeer, 0, packet2);
									delete data;
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);
									delete ps.data;
									break;
								}
							}
						}
						else if (str == "/nuke") {
							if (((PlayerInfo*)(peer->data))->adminLevel >= 19) {
								WorldInfo* world = getPlyersWorld(peer);
								if (world->isNuked) {
									world->isNuked = false;
									cout << " Player " << ((PlayerInfo*)(peer->data))->rawName << " has unnuked " << world->name << endl;
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^You have `@Un-Nuked `^the world!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else {
									world->isNuked = true;
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^You have `@Nuked `^the world!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									//enet_host_flush(server);
									string name = ((PlayerInfo*)(peer->data))->displayName;
									GamePacket p1 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`o>>`4" + world->name + " `4was nuked from orbit`o. It's the only way to be sure. Play nice, everybody!"));
									string text = "action|play_sfx\nfile|audio/ogg/boombox.ogg\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (!((PlayerInfo*)(currentPeer->data))->radio)
											continue;
										ENetPacket* packet = enet_packet_create(p1.data,
											p1.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										if (isHere(peer, currentPeer)) {
											if (((PlayerInfo*)(currentPeer->data))->adminLevel < 19) {
												//((PlayerInfo*)(currentPeer->data))->currentWorld = "EXIT";
												sendPlayerLeave(currentPeer, (PlayerInfo*)(currentPeer->data));
												sendWorldOffers(currentPeer);
												((PlayerInfo*)(currentPeer->data))->currentWorld = "EXIT";
											}
										}
										//enet_host_flush(server);
									}
									delete data;
									delete p1.data;
								}
								continue;
							}
							else {
								player::consolemessage(peer, "`4Invalid command, try again?");
								continue;
							}
						}
						
						
						else if (str.substr(0, 6) == "/give ")
						{
							if (((PlayerInfo*)(peer->data))->adminLevel == 20) {
								int gems = atoi(str.substr(6).c_str());;
								((PlayerInfo*)(peer->data))->gem = atoi(str.substr(6).c_str());
								GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
						}
						
						else if (str == "/online") {
							string online = "";
							int total = 0;
							ENetPeer* currentPeer;

							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (((PlayerInfo*)(currentPeer->data))->adminLevel >= 0) {
									online += ((PlayerInfo*)(currentPeer->data))->displayName + "`o, `w";
									total++;
								}
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `5Players online [`wTotal: `2" + to_string(total) + "`5]: `w" + online));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else if (str.substr(0, 7) == "/color ")
						{
							((PlayerInfo*)(peer->data))->skinColor = atoi(str.substr(6, cch.length() - 6 - 1).c_str());
							sendClothes(peer);
						}
					}
					if (!((PlayerInfo*)(event.peer->data))->isIn)
					{
						try {

							gamepacket_t p22;
							p22.Insert("OnSuperMainStartAcceptLogonHrdxs47254722215a");
							p22.Insert(itemdathash);
							p22.Insert("52.187.65.50");
							p22.Insert("cache/");
							p22.Insert("cc.cz.madkite.freedom org.aqua.gg idv.aqua.bulldog com.cih.gamecih2 com.cih.gamecih com.cih.game_cih cn.maocai.gamekiller com.gmd.speedtime org.dax.attack com.x0.strai.frep com.x0.strai.free org.cheatengine.cegui org.sbtools.gamehack com.skgames.traffikrider org.sbtoods.gamehaca com.skype.ralder org.cheatengine.cegui.xx.multi1458919170111 com.prohiro.macro me.autotouch.autotouch com.cygery.repetitouch.free com.cygery.repetitouch.pro com.proziro.zacro com.slash.gamebuster");
							p22.Insert("proto=108|choosemusic=audio/mp3/ykoops.mp3|active_holiday=0|");
							p22.CreatePacket(peer);

							std::stringstream ss(GetTextPointerFromPacket(event.packet));
							std::string to;
							while (std::getline(ss, to, '\n')) {
								string id = to.substr(0, to.find("|"));
								string act = to.substr(to.find("|") + 1, to.length() - to.find("|") - 1);

								if (id == "tankIDName")
								{

									((PlayerInfo*)(event.peer->data))->tankIDName = act;
									((PlayerInfo*)(event.peer->data))->haveGrowId = true;
								}
								else if (id == "meta")
								{
									((PlayerInfo*)(event.peer->data))->metaip = act;
									/*if (act != "hotdog") {
										enet_peer_disconnect(peer, 0);
										break;
									}*/
								}
								else if (id == "platformID") {
									if (act.length() == 0) {
										enet_peer_reset(peer);
										break;
									}
									((PlayerInfo*)(event.peer->data))->platformid = act;
								}
								else if (id == "game_version") {
									((PlayerInfo*)(event.peer->data))->gameVersion = act;
									if (act != "3.47") {
										string text = "action|log\nmsg|`4UPDATE REQUIRED!`o : The `$V3.47 `oupdate is now available for your device. Go get it! You'll need to install it before you can play growtopia royal private server!";
										string text3 = "action|logon_fail\n";
										string dc = "http://growtopiagame.com/";
										string url = "action|set_url\nurl|" + dc + "\nlabel|`$Update Growtopia\n";


										BYTE* data = new BYTE[5 + text.length()];
										BYTE* data3 = new BYTE[5 + text3.length()];
										BYTE* dataurl = new BYTE[5 + url.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length());
										memcpy(data + 4 + text.length(), &zero, 1);

										memcpy(dataurl, &type, 4);
										memcpy(dataurl + 4, url.c_str(), url.length());
										memcpy(dataurl + 4 + url.length(), &zero, 1);

										memcpy(data3, &type, 4);
										memcpy(data3 + 4, text3.c_str(), text3.length());
										memcpy(data3 + 4 + text3.length(), &zero, 1);

										ENetPacket* p = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, p);
										ENetPacket* p3 = enet_packet_create(dataurl,
											5 + url.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, p3);
										ENetPacket* p2 = enet_packet_create(data3,
											5 + text3.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, p2);
										break;
										delete data;
										delete dataurl;
										delete data3;
									}
								}
								else if (id == "tankIDPass")
								{

									((PlayerInfo*)(event.peer->data))->tankIDPass = act;
								}
								else if (id == "requestedName")
								{
									((PlayerInfo*)(event.peer->data))->requestedName = act;
								}
								else if (id == "country")
								{
									((PlayerInfo*)(event.peer->data))->country = act;
								}
							}
						}
						catch (...) {
							ofstream collectlog("crash.txt", ios::app);
							collectlog << "error in onSuperMain" << endl;
							collectlog.close();
							cout << "error in onSuperMain";
						}
						if (!((PlayerInfo*)(event.peer->data))->haveGrowId)
						{
							((PlayerInfo*)(event.peer->data))->displayName = "`w[`pGuest`w] " + PlayerDB::fixColors(((PlayerInfo*)(event.peer->data))->requestedName.substr(0, ((PlayerInfo*)(event.peer->data))->requestedName.length() > 15 ? 15 : ((PlayerInfo*)(event.peer->data))->requestedName.length()));
							((PlayerInfo*)(event.peer->data))->tankIDName = "`w[`pGuest`w] " + PlayerDB::fixColors(((PlayerInfo*)(event.peer->data))->requestedName.substr(0, ((PlayerInfo*)(event.peer->data))->requestedName.length() > 15 ? 15 : ((PlayerInfo*)(event.peer->data))->requestedName.length()));
							((PlayerInfo*)(event.peer->data))->rawName = std::to_string(event.peer->address.host);
						}
						else {
							((PlayerInfo*)(event.peer->data))->rawName = PlayerDB::getProperName(((PlayerInfo*)(event.peer->data))->tankIDName);
#ifdef REGISTRATION
							int logStatus = PlayerDB::playerLogin(peer, ((PlayerInfo*)(event.peer->data))->rawName, ((PlayerInfo*)(event.peer->data))->tankIDPass);
							if (logStatus == -10) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oIllegal name, connection cancelled."));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;

								enet_peer_disconnect_later(peer, 0);
							}
							if (logStatus == -5) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oYour connection have been cancelled!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;

								enet_peer_disconnect_later(peer, 0);
							}
							if (logStatus == -4) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oYour account have been locked for security reasons, If you believe its an mistake please contact NabZGT#0789!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;

								enet_peer_disconnect_later(peer, 0);
							}
							if (logStatus == -5) {
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oYour name is over 18 letter, connection cancelled"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								enet_peer_disconnect_later(peer, 0);
							}
							else if (logStatus == 1) {
								try {
									PlayerInfo* p = ((PlayerInfo*)(peer->data));
									std::ifstream ifff("players/" + PlayerDB::getProperName(p->rawName) + ".json");
									json j;
									ifff >> j;
									string code;
									string notebook;
									int adminLevel, gems, back, hand, face, hair, feet, pants, neck, shirt, mask, ances, lvl, xp, skinColor, djump;
									bool iscode, joinguild, milk, isDr, legend, online;
									adminLevel = j["adminLevel"];
									gems = j["gems"];
									back = j["ClothBack"];
									hand = j["ClothHand"];
									face = j["ClothFace"];
									hair = j["ClothHair"];
									feet = j["ClothFeet"];
									pants = j["ClothPants"];
									neck = j["ClothNeck"];
									shirt = j["ClothShirt"];
									mask = j["ClothMask"];
									ances = j["ClothAnces"];
									lvl = j["level"];
									xp = j["xp"];
									skinColor = j["skinColor"];
									djump = j["canDoubleJump"];
									legend = j["isLegend"];
									notebook = j["notebook"].get<string>();
									vector <string>frnss;
									if (j.count("worldsowned") == 1) {
										for (int i = 0; i < j["worldsowned"].size(); i++) {
											frnss.push_back(j["worldsowned"][i]);
										}
									}
									else {
										frnss = {};
									}
									p->worldsowned = frnss;
									p->notebook = notebook;
									p->legend = legend;
									p->canDoubleJump = djump;
									p->adminLevel = adminLevel;
									p->cloth_back = back;
									p->cloth_hand = hand;
									p->cloth_face = face;
									p->cloth_hair = hair;
									p->cloth_feet = feet;
									p->cloth_pants = pants;
									p->cloth_necklace = neck;
									p->cloth_shirt = shirt;
									p->cloth_mask = mask;
									p->cloth_ances = ances;
									p->xp = xp;
									p->level = lvl;
									p->skinColor = skinColor;

									updateAllClothes(peer);

									ifff.close();

									if (((PlayerInfo*)(peer->data))->adminLevel == 20 || ((PlayerInfo*)(peer->data))->adminLevel == 19) {
										((PlayerInfo*)(peer->data))->haveSuperSupporterName = true;
									}


									short invsize = 0;
									ifstream invfd("usersinventorysize/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
									invfd >> invsize;
									invfd.close();

									((PlayerInfo*)(peer->data))->currentInventorySize = invsize;

									GamePacket p5 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
									ENetPacket* packet5 = enet_packet_create(p5.data,
										p5.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet5);
									delete p5.data;

									player::consolemessage(peer, "`9Growtopia Royal `wby `6@Baskerville");

									((PlayerInfo*)(event.peer->data))->displayName = ((PlayerInfo*)(event.peer->data))->tankIDName;
									if (((PlayerInfo*)(peer->data))->adminLevel == 20) {
										((PlayerInfo*)(event.peer->data))->displayName = "`6@" + ((PlayerInfo*)(event.peer->data))->tankIDName;
									}
									else if (((PlayerInfo*)(peer->data))->adminLevel == 19) {
										((PlayerInfo*)(event.peer->data))->displayName = "`#@" + ((PlayerInfo*)(event.peer->data))->tankIDName;
									}
									else if (((PlayerInfo*)(peer->data))->adminLevel == 18) {
										((PlayerInfo*)(event.peer->data))->displayName = "`w[`$VIP`w] `$" + ((PlayerInfo*)(event.peer->data))->tankIDName;
									}
									else {
										((PlayerInfo*)(event.peer->data))->displayName = ((PlayerInfo*)(event.peer->data))->tankIDName;
									}
								}
								catch (...) {
								}
							}
							else {
								wrongpass(peer);
							}
#else

							((PlayerInfo*)(event.peer->data))->displayName = PlayerDB::fixColors(((PlayerInfo*)(event.peer->data))->tankIDName.substr(0, ((PlayerInfo*)(event.peer->data))->tankIDName.length() > 18 ? 18 : ((PlayerInfo*)(event.peer->data))->tankIDName.length()));
							if (((PlayerInfo*)(event.peer->data))->displayName.length() < 3) ((PlayerInfo*)(event.peer->data))->displayName = "Person that doesn't know how the name looks!";
#endif
						}
						for (char c : ((PlayerInfo*)(event.peer->data))->displayName) if (c < 0x20 || c>0x7A) ((PlayerInfo*)(event.peer->data))->displayName = "Bad characters in name, remove them!";

						if (((PlayerInfo*)(event.peer->data))->country.length() > 4)
						{
							((PlayerInfo*)(event.peer->data))->country = "us";
						}
						if (((PlayerInfo*)(event.peer->data))->adminLevel == 1337)
						{
							((PlayerInfo*)(event.peer->data))->country = "rt";
						}
						if (((PlayerInfo*)(event.peer->data))->level >= 125)
						{
							((PlayerInfo*)(event.peer->data))->country = "|maxLevel";
						}
						/*GamePacket p3= packetEnd(appendString(appendString(createPacket(), "OnRequestWorldSelectMenu"), "default|GO FOR IT\nadd_button|Showing: `wFake Worlds``|_catselect_|0.6|3529161471|\nadd_floater|Subscribe|5|0.55|3529161471\nadd_floater|Growtopia|4|0.52|4278190335\nadd_floater|Noobs|150|0.49|3529161471\nadd_floater|...|3|0.49|3529161471\nadd_floater|`6:O :O :O``|2|0.46|3529161471\nadd_floater|SEEMS TO WORK|2|0.46|3529161471\nadd_floater|?????|1|0.43|3529161471\nadd_floater|KEKEKEKEK|13|0.7|3417414143\n"));
						//for (int i = 0; i < p.len; i++) cout << (int)*(p.data + i) << " ";
						ENetPacket * packet3 = enet_packet_create(p3.data,
						p3.len,
						ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet3);
						enet_host_flush(server);*/


						GamePacket p2 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), ((PlayerInfo*)(event.peer->data))->haveGrowId), ((PlayerInfo*)(peer->data))->tankIDName), ((PlayerInfo*)(peer->data))->tankIDPass));
						ENetPacket* packet2 = enet_packet_create(p2.data,
							p2.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet2);
						delete p2.data;



					}
					if (cch.find("action|setSkin") == 0) {
						try {
							if (!world) continue;
							std::stringstream ss(cch);
							std::string to;
							int id = -1;
							string color;
							while (std::getline(ss, to, '\n')) {
								vector<string> infoDat = explode("|", to);
								if (infoDat[0] == "color") color = infoDat[1];
								if (has_only_digits(color) == false) continue;
								id = atoi(color.c_str());
								if (color == "2190853119") {
									id = -2104114177;
								}
								else if (color == "2527912447") {
									id = -1767054849;
								}
								else if (color == "2864971675") {
									id = -1429995521;
								}
								else if (color == "3033464831") {
									id = -1261502465;
								}
								else if (color == "3370516479") {
									id = -924450817;
								}
							}
							((PlayerInfo*)(peer->data))->skinColor = id;
							sendClothes(peer);
						}
						catch (...) {
							cout << "error in action|setskin";
							enet_peer_disconnect(peer, 0);
							break;
						}
					}
					string pStr = GetTextPointerFromPacket(event.packet);
					//if (strcmp(GetTextPointerFromPacket(event.packet), "action|enter_game\n") == 0 && !((PlayerInfo*)(event.peer->data))->isIn)
					if (pStr.substr(0, 17) == "action|enter_game" && !((PlayerInfo*)(event.peer->data))->isIn)
					{
						try {
							((PlayerInfo*)(event.peer->data))->isIn = true;
							ENetPeer* currentPeer;
							if (((PlayerInfo*)(peer->data))->haveGrowId) {
								thread checkPlayerState(savejson, peer);
								if (checkPlayerState.joinable()) {
									checkPlayerState.detach();
								}
								if (std::experimental::filesystem::exists("timemuted/" + ((PlayerInfo*)(peer->data))->rawName + ".txt"))
								{
									((PlayerInfo*)(peer->data))->taped = true;
									((PlayerInfo*)(peer->data))->isDuctaped = true;
									using namespace std::chrono;
									int mutedMinutes = 0;
									ifstream fd("timemuted/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
									fd >> mutedMinutes;
									fd.close();
									((PlayerInfo*)(peer->data))->lastMuted = ((duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) + (mutedMinutes * 60 * 1000);
									sendClothes(peer);
								}
								string name = ((PlayerInfo*)(peer->data))->displayName;
								sendWorldOffers(peer);
								sendGazette(peer);
								player::consolemessage(peer, "`wWelcome back, `6" + name + "`w! `w(`1" + std::to_string(GetPlayerCountServer()) + " `wplayers online!`o)");
								player::consolemessage(peer, "`oServer hosted & Created by `6@Baskerville `o(`c@Baskerville#0001`o)");
								player::growmoji(peer);
								LoadInventory(peer);
							}
							else {
								player::dialogDuration(peer, 500, "set_default_color|`o\n\nadd_label_with_icon|big|`wGet a GrowID``|left|206|\n\nadd_spacer|small|\nadd_textbox|A `wGrowID `wmeans `oyou can use a name and password to logon from any device.|\nadd_spacer|small|\nadd_textbox|This `wname `owill be reserved for you and `wshown to other players`o, so choose carefully!|\nadd_text_input|username|GrowID||30|\nadd_text_input_password|password|Password||100|\nadd_text_input_password|passwordverify|Password Verify||100|\nadd_textbox|Your `wemail address `owill only be used for account verification purposes and won't be spammed or shared. If you use a fake email, you'll never be able to recover or change your password.|\nadd_text_input|email|Email||100|\nend_dialog|register|Cancel|Get My GrowID!|\n");
								continue;
								break;
							}
						}
						catch (...) {
							cout << "error in action|enter_game";
							enet_peer_disconnect(peer, 0);
							break;
						}
					}
					if (strcmp(GetTextPointerFromPacket(event.packet), "action|refresh_item_data\n") == 0)
					{
						try {
							if (((PlayerInfo*)(event.peer->data))->platformid != "1") {
								if (itemsDat != NULL) {
									Player::OnConsoleMessage(peer, "`oOne moment, updating item data...");
									ENetPacket* packet = enet_packet_create(itemsDat,
										itemsDatSize + 60,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
								}
							}
							else {
								if (itemsDatNormal != NULL) {
									Player::OnConsoleMessage(peer, "`oOne moment, updating item data...");
									ENetPacket* packet = enet_packet_create(itemsDatNormal,
										itemsDatSizeNormal + 60,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
								}
							}
						}
						catch (...) {
							cout << "error in action|refresh_item_data";
							enet_peer_disconnect(peer, 0);
							break;
						}
					}
					break;
				}
				default:
					cout << "[!] Unknown packet type " << messageType << endl;
					break;
				case 3:
				{
					bool isValidIateReq = false;
					//cout << GetTextPointerFromPacket(event.packet) << endl;
					std::stringstream ss(GetTextPointerFromPacket(event.packet));
					std::string to;
					bool isJoinReq = false;
					while (std::getline(ss, to, '\n')) {
						string id = to.substr(0, to.find("|"));
						string act = to.substr(to.find("|") + 1, to.length() - to.find("|") - 1);
						if (id == "name" && isJoinReq)
						{
							// entering some world

							bool iscontainsss12 = false;
							SearchInventoryItem(peer, 5640, 1, iscontainsss12);
							if (iscontainsss12)
							{
								int id = 5640;
								short int currentItemCount = 0;
								for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
								{
									if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == id)
									{
										currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
									}
								}
								RemoveInventoryItem(id, currentItemCount, peer);
							}

							bool iscontains = false;
							SearchInventoryItem(peer, 6336, 1, iscontains);
							if (!iscontains) {
								bool success = true;
								SaveShopsItemMoreTimes(6336, 1, peer, success);
							}

							joinWorld(peer, act, 0, 0);
						}
						if (id == "action")
						{

							if (act == "join_request")
							{
								isJoinReq = true;
							}
							if (act == "quit_to_exit")
							{
								sendPlayerLeave(peer, (PlayerInfo*)(event.peer->data));
								((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
								sendWorldOffers(peer);
							}
							if (act == "quit") {
								try {
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...) {
									cout << "error in act == quit";
									enet_peer_disconnect(peer, 0);
									break;
								}
							}
						}
					}
					break;
				}
				case 4:
				{
					{
						BYTE* tankUpdatePacket = GetStructPointerFromTankPacket(event.packet);

						if (tankUpdatePacket)
						{
							PlayerMoving* pMov = unpackPlayerMoving(tankUpdatePacket);

							if ((pMov->characterState >= 80 || pMov->characterState == 64) && pMov->characterState != 144 && pMov->characterState != 128 && pMov->characterState < 250) {
								if (((PlayerInfo*)(peer->data))->canWalkInBlocks == false)
								{
									((PlayerInfo*)(event.peer->data))->lavaLevel = ((PlayerInfo*)(event.peer->data))->lavaLevel + 1;

									if (((PlayerInfo*)(peer->data))->lavaLevel >= 5) {
										((PlayerInfo*)(peer->data))->lavaLevel = 0;
										int x = ((PlayerInfo*)(peer->data))->x;
										int y = ((PlayerInfo*)(peer->data))->y;
										for (int i = 0; i < world->width * world->height; i++)
										{
											if (world->items[i].foreground == 6) {
												x = (i % world->width) * 32;
												y = (i / world->width) * 32;
												//world->items[i].foreground = 8;
											}
										}
										playerRespawn(peer, false);
									}
								}
							}

							if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT")
							{

								continue;

							}
						}
						if (tankUpdatePacket)
						{
							PlayerMoving* pMov = unpackPlayerMoving(tankUpdatePacket);
							if (((PlayerInfo*)(event.peer->data))->isGhost) {
								((PlayerInfo*)(event.peer->data))->isInvisible = true;
								((PlayerInfo*)(event.peer->data))->x1 = pMov->x;
								((PlayerInfo*)(event.peer->data))->y1 = pMov->y;
								pMov->x = -1000000;
								pMov->y = -1000000;
							}
							switch (pMov->packetType)
							{
							case 0:
								((PlayerInfo*)(event.peer->data))->x = pMov->x;
								((PlayerInfo*)(event.peer->data))->y = pMov->y;
								((PlayerInfo*)(event.peer->data))->isRotatedLeft = pMov->characterState & 0x10;
								sendPData(peer, pMov);
								if (!((PlayerInfo*)(peer->data))->joinClothesUpdated)
								{
									((PlayerInfo*)(peer->data))->joinClothesUpdated = true;
									updateAllClothes(peer);
									updateInvis(peer);
									sendState(peer);
									GamePacket p222 = packetEnd(appendInt(appendInt(appendInt(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem), 1), 2), 1));
									ENetPacket* packet222 = enet_packet_create(p222.data,
										p222.len,
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(peer, 0, packet222);
								}
								break;

							default:
								break;
							}
							int omgcheck = ((PlayerInfo*)(event.peer->data))->x + (((PlayerInfo*)(event.peer->data))->y * world->width);
							PlayerMoving* data2 = unpackPlayerMoving(tankUpdatePacket);
							//cout << data2->packetType << endl;
							if (data2->packetType == 25)
							{
								try {
									if (((PlayerInfo*)(peer->data))->adminLevel <= 0) {
										GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "Warning from `4SYSTEM `w: You can't play the server when cheat engine is opened. Close it first!"), "audio/hub_open.wav"), 0));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
										player::disconnect(peer);
									}
								}
								catch (...) {
									ofstream collectlog("crash.txt", ios::app);
									collectlog << "error in packettype == 25" << endl;
									collectlog.close();
									cout << "error in packettype == 25";
								}
							}
							if (data2->packetType == 11)
							{
								try {
									PlayerInfo* pinfo = ((PlayerInfo*)(event.peer->data));
									WorldInfo* world = getPlyersWorld(event.peer);
									if (!world) break;
									// is this legit collect?
									// nah, we're not checking for that
									bool legit = true;
									// ...
									// anticheat code goes here
									// ...
									int itemIdx = pMov->plantingTree - 1;
									int atik = -1;
									for (int i = 0; i < world->droppedItems.size(); i++)
									{
										if (world->droppedItems.at(i).uid == itemIdx)
										{
											atik = i;
											break;
										}
									}
									legit = atik != -1;
									if (legit)
									{
										//	cout << "[!] heh" << endl;
										DroppedItem droppedItem = world->droppedItems.at(atik);

										// check if player already has item

										legit = true;
									}
									if (legit)
									{
										processTake(peer, pMov, pMov->plantingTree - 1, pMov->x, pMov->y);
									}
									else
									{
										//	cout << "[!] Couldn't take item - plantingTree value is " << hex << pMov->plantingTree << dec << " and itemIdx value is " << hex << itemIdx << dec << "!" << endl;
									}
								}
								catch (...) {
									cout << "error in packettype == 11";
									enet_peer_disconnect(peer, 0);
									break;
								}
							}
							/*if (data2->packetType == 11)
							{

								PlayerInfo* pinfo = ((PlayerInfo*)(event.peer->data));
								WorldInfo* world = getPlyersWorld(event.peer);
								if (!world) break;

								if (((PlayerInfo*)(peer->data))->isinv == true)
								{
									Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`1(You are invisible now)", 0, true);
									break;
								}

								bool legit = true;
								int itemIdx = pMov->plantingTree - 1;
								int atik = -1;
								for (int i = 0; i < world->droppedItems.size(); i++)
								{
									if (world->droppedItems.at(i).uid == itemIdx)
									{
										atik = i;
										break;
									}
								}
								legit = atik != -1;
								if (legit)
								{
									DroppedItem droppedItem = world->droppedItems.at(atik);
									legit = true;
								}
								if (legit)
								{
									DroppedItem droppedItem = world->droppedItems.at(atik);
									if (droppedItem.id != 112)
									{
										if (CheckItemMaxed(peer, droppedItem.id, droppedItem.count))
										{
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`1(Item maxed)", 0, true);
											break;
										}
										if (CheckItemExists(peer, droppedItem.id) == false)
										{
											if (((PlayerInfo*)(peer->data))->inventory.items.size() == ((PlayerInfo*)(peer->data))->currentInventorySize) {
												Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`1(Inventory is full)", 0, true);
												break;
											}
										}
									}
									if (droppedItem.id == 112)
									{
										pinfo->gem += droppedItem.count;
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), ((PlayerInfo*)(peer->data))->gem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
									}
									else if (droppedItem.id == 2952)
									{
										Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o.");
										bool success = true;
										SaveShopsItemMoreTimes(droppedItem.id, droppedItem.count, peer, success);
										Player::OnTextOverlay(peer, "`9You have `2Obtained `3The Digger's Spade`9!");
									}
									else
									{
										bool success = true;
										SaveShopsItemMoreTimes(droppedItem.id, droppedItem.count, peer, success);

									}
									if (getItemDef(droppedItem.id).rarity == 999)
									{
										if (droppedItem.id != 112)
										{
											Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o.");
										}
									}
									else
									{
										Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o. Rarity: `w" + to_string(getItemDef(droppedItem.id).rarity) + "`o.");
									}
									world->droppedItems.erase(world->droppedItems.begin() + atik);
									SendTake(peer, pinfo->netID, pMov->x, pMov->y, itemIdx + 1);
									sendInventory(peer, ((PlayerInfo*)(peer->data))->inventory);
								}
								else
								{

								}
							}*/
							if (data2->packetType == 7)
							{
								try {
									//cout << pMov->x << ";" << pMov->y << ";" << pMov->plantingTree << ";" << pMov->punchX << ";" << pMov->punchY << ";" << pMov->netID << ";" << pMov->secondnetID << ";" << endl;
									if (pMov->punchX < 0 || pMov->punchY < 0 || pMov->punchX > 100 || pMov->punchY > 100) continue;
									if (((PlayerInfo*)(event.peer->data))->currentWorld == "EXIT") continue;

									int x = pMov->punchX;
									int y = pMov->punchY;
									int tile = world->items[x + (y * world->width)].foreground;
									int netID = ((PlayerInfo*)(peer->data))->netID;

									// begin door code here
									bool founds = false;
									bool founds2 = false;
									int xx;
									int yy;
									if (tile == 6) {
										sendPlayerLeave(peer, (PlayerInfo*)(event.peer->data));
										((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
										sendWorldOffers(peer);
									}
									else if (tile == 410 || tile == 1832 || tile == 1770) {
										((PlayerInfo*)(peer->data))->respawnX = x * 32;
										((PlayerInfo*)(peer->data))->respawnY = y * 32;
										Player::SetRespawnPos(peer, x, (world->width * y), netID);
									}
									else {
										Player::OnTalkBubble(peer, netID, "`w(too far away)``", 0, true);
										GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnZoomCamera"), 2));
										ENetPacket* packet23 = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet23);
										delete p.data;
										GamePacket p25 = packetEnd(appendIntx(appendString(createPacket(), "OnSetFreezeState"), 0));
										memcpy(p25.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
										ENetPacket* packet25 = enet_packet_create(p25.data,
											p25.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet25);
										delete p25.data;
									}
								}
								catch (...) {
									cout << "error in packettype == 7";
									enet_peer_disconnect(peer, 0);
									break;
								}
							}
							if (data2->packetType == 10)
							{
								try {
									int item = pMov->plantingTree;
									PlayerInfo* info = ((PlayerInfo*)(peer->data));
									ItemDefinition pro;
									pro = getItemDef(item);
									//cout << pMov->x << ";" << pMov->y << ";" << pMov->plantingTree << ";" << pMov->punchX << ";" << pMov->punchY << ";" << pMov->characterState << endl;
									ItemDefinition def;
									try {
										def = getItemDef(pMov->plantingTree);
									}
									catch (int e) {
										goto END_CLOTHSETTER_FORCE;
									}
									if (pMov->plantingTree == 242)
									{
										for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
										{
											if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == 242)
											{
												if (((PlayerInfo*)(peer->data))->inventory.items[i].itemCount >= 100)
												{
													bool isValid = SaveConvertedItem(1796, 1, peer);
													if (isValid)
													{

														RemoveInventoryItem(pMov->plantingTree, 100, peer);
														GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`wYou compressed 100 `2World Lock `winto a `2Diamond Lock`w!"), 0));
														ENetPacket* packet2 = enet_packet_create(p2.data,
															p2.len,
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(peer, 0, packet2);
														delete p2.data;
														Player::OnConsoleMessage(peer, "`oYou compressed 100 `2World Lock `ointo a `2Diamond Lock`o!");
													}
												}
											}
										}

									}
									if (pMov->plantingTree == 1796) // shatter
									{
										for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
										{
											if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == 1796)
											{
												if (((PlayerInfo*)(peer->data))->inventory.items[i].itemCount >= 1)
												{
													bool isValid = SaveConvertedItem(242, 100, peer);
													if (isValid)
													{

														RemoveInventoryItem(pMov->plantingTree, 1, peer);
														GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`wYou shattered a `2Diamond Lock `winto `2100 World Lock`w!"), 0));
														ENetPacket* packet2 = enet_packet_create(p2.data,
															p2.len,
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(peer, 0, packet2);
														delete p2.data;
														Player::OnConsoleMessage(peer, "`oYou shattered a `2Diamond Lock `winto `2100 World Lock`o!");
													}
												}
											}
										}

									}
									if (pMov->plantingTree == 1486) // shatter
									{
										for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
										{
											if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == 1486)
											{
												if (((PlayerInfo*)(peer->data))->inventory.items[i].itemCount >= 100)
												{
													bool isValid = SaveConvertedItem(6802, 1, peer);
													if (isValid)
													{

														RemoveInventoryItem(pMov->plantingTree, 100, peer);
														GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`wYou compressed `2100 Growtoken `winto a `2Mega Growtoken`w!"), 0));
														ENetPacket* packet2 = enet_packet_create(p2.data,
															p2.len,
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(peer, 0, packet2);
														delete p2.data;
														Player::OnConsoleMessage(peer, "`oYou compressed `2100 Growtoken `winto a `2Mega Growtoken`o!");
													}
												}
											}
										}

									}
									if (pMov->plantingTree == 6802) // shatter
									{
										for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
										{
											if (((PlayerInfo*)(peer->data))->inventory.items[i].itemID == 6802)
											{
												if (((PlayerInfo*)(peer->data))->inventory.items[i].itemCount >= 1)
												{
													bool isValid = SaveConvertedItem(1486, 100, peer);
													if (isValid)
													{

														RemoveInventoryItem(pMov->plantingTree, 1, peer);
														GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`wYou shattered `2Mega Growtoken `winto `2100 Growtoken`w!"), 0));
														ENetPacket* packet2 = enet_packet_create(p2.data,
															p2.len,
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(peer, 0, packet2);
														delete p2.data;
														Player::OnConsoleMessage(peer, "`oYou shattered `2Mega Growtoken `winto `2100 Growtoken`o!");
													}
												}
											}
										}

									}
									switch (def.clothType) {
									case 0:
										if (((PlayerInfo*)(event.peer->data))->cloth0 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth0 = 0;
											getAutoEffect(peer);
											sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effect);
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth0 = pMov->plantingTree;
										sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effects);
										break;
									case 1:
										if (((PlayerInfo*)(event.peer->data))->cloth1 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth1 = 0;
											if (pMov->plantingTree = 1780) {
												info->peffect = 8421396;
												sendState(peer); //here
											}
											getAutoEffect(peer);
											sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effect);
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth1 = pMov->plantingTree;
										sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effects);
										break;
									case 2:
										if (((PlayerInfo*)(event.peer->data))->cloth2 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth2 = 0;
											getAutoEffect(peer);
											sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effect);
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth2 = pMov->plantingTree;
										sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effects);
										break;
									case 3:
										if (((PlayerInfo*)(event.peer->data))->cloth3 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth3 = 0;
											getAutoEffect(peer);
											sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effect);
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth3 = pMov->plantingTree;
										sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effects);
										break;
									case 4:

										if (((PlayerInfo*)(event.peer->data))->cloth4 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth4 = 0;
											getAutoEffect(peer);
											sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effect);
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth4 = pMov->plantingTree;
										sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effects);
										if (item == 1204) {
											info->peffect = 8421386;
										}
										else if (item == 138) {
											info->peffect = 8421377;
										}
										else if (item == 2476) {
											info->peffect = 8421415;
										}
										else {
											getAutoEffect(peer);
										}

										break;
									case 5:
										if (((PlayerInfo*)(event.peer->data))->cloth5 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth5 = 0;
											getAutoEffect(peer);
											sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effect);
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth5 = pMov->plantingTree;
										if (item == 366 || item == 1464) {
											info->peffect = 8421378;
										}
										else if (item == 1782) {
											info->peffect = 8421397;
										}
										else if (item == 366 || item == 1464) {
											info->peffect = 8421378;
										}
										else if (item == 472) {
											info->peffect = 8421379;
										}
										else if (item == 594) {
											info->peffect = 8421380;
										}
										else if (item == 768) {
											info->peffect = 8421381;
										}
										else if (item == 900) {
											info->peffect = 8421382;
										}
										else if (item == 910) {
											info->peffect = 8421383;
										}
										else if (item == 930) {
											info->peffect = 8421384;
										}
										else if (item == 1016) {
											info->peffect = 8421385;
										}
										else if (item == 1378) {
											info->peffect = 8421387;
										}
										else if (item == 1484) {
											info->peffect = 8421389;
										}
										else if (item == 1512) {
											info->peffect = 8421390;
										}
										else if (item == 1542) {
											info->peffect = 8421391;
										}
										else if (item == 1576) {
											info->peffect = 8421392;
										}
										else if (item == 1676) {
											info->peffect = 8421393;
										}
										else if (item == 1710) {
											info->peffect = 8421394;
										}
										else if (item == 1748) {
											info->peffect = 8421395;
										}
										else if (item == 1780) {
											info->peffect = 8421396;
										}
										else if (item == 1782) {
											info->peffect = 8421397;
										}
										else if (item == 1804) {
											info->peffect = 8421398;
										}
										else if (item == 1868) {
											info->peffect = 8421399;
										}
										else if (item == 1874) {
											info->peffect = 8421400;
										}
										else if (item == 1946) {
											info->peffect = 8421401;
										}
										else if (item == 1948) {
											info->peffect = 8421402;
										}
										else if (item == 1956) {
											info->peffect = 8421403;
										}
										else if (item == 2908) {
											info->peffect = 8421405;
										}
										else if (item == 2952) {
											info->peffect = 8421405;
										}
										else if (item == 6312) {
											info->peffect = 8421405;
										}
										else if (item == 1980) {
											info->peffect = 8421406;
										}
										else if (item == 2066) {
											info->peffect = 8421407;
										}
										else if (item == 2212) {
											info->peffect = 8421408;
										}
										else if (item == 2218) {
											info->peffect = 8421409;
										}
										else if (item == 2220) {
											info->peffect = 8421410;
										}
										else if (item == 2266) {
											info->peffect = 8421411;
										}
										else if (item == 2386) {
											info->peffect = 8421412;
										}
										else if (item == 2388) {
											info->peffect = 8421413;
										}
										else if (item == 2450) {
											info->peffect = 8421414;
										}
										else if (item == 2512) {
											info->peffect = 8421417;
										}
										else if (item == 2572) {
											info->peffect = 8421418;
										}
										else if (item == 2592) {
											info->peffect = 8421419;
										}
										else if (item == 7912) {
											info->peffect = 8421487;
										}
										else if (item == 2720) {
											info->peffect = 8421420;
										}
										else if (item == 2752) {
											info->peffect = 8421421;
										}
										else if (item == 2754) {
											info->peffect = 8421422;
										}
										else if (item == 2756) {
											info->peffect = 8421423;
										}
										else if (item == 2802) {
											info->peffect = 8421425;
										}
										else if (item == 2866) {
											info->peffect = 8421426;
										}
										else if (item == 2876) {
											info->peffect = 8421427;
										}
										else if (item == 2886) {
											info->peffect = 8421430;
										}
										else if (item == 2890) {
											info->peffect = 8421431;
										}
										else if (item == 3066) {
											info->peffect = 8421433;
										}
										else if (item == 3124) {
											info->peffect = 8421434;
										}
										else if (item == 3168) {
											info->peffect = 8421435;
										}
										else if (item == 3214) {
											info->peffect = 8421436;
										}
										else if (item == 3300) {
											info->peffect = 8421440;
										}
										else if (item == 3418) {
											info->peffect = 8421441;
										}
										else if (item == 3476) {
											info->peffect = 8421442;
										}
										else if (item == 3686) {
											info->peffect = 8421444;
										}
										else if (item == 3716) {
											info->peffect = 8421445;
										}
										else if (item == 4290) {
											info->peffect = 8421447;
										}
										else if (item == 4474) {
											info->peffect = 8421448;
										}
										else if (item == 4464) {
											info->peffect = 8421449;
										}
										else if (item == 1576) {
											info->peffect = 8421450;
										}
										else if (item == 5480) {
											info->peffect = 8421456;
										}
										else if (item == 4778 || item == 6026) {
											info->peffect = 8421452;
										}
										else if (item == 4996) {
											info->peffect = 8421453;
										}
										else if (item == 4840) {
											info->peffect = 8421454;
										}
										else if (item == 5480) {
											info->peffect = 8421456;
										}
										else if (item == 6110) {
											info->peffect = 8421457;
										}
										else if (item == 6308) {
											info->peffect = 8421458;
										}
										else if (item == 6310) {
											info->peffect = 8421459;
										}
										else if (item == 6298) {
											info->peffect = 8421460;
										}
										else if (item == 6756) {
											info->peffect = 8421461;
										}
										else if (item == 7044) {
											info->peffect = 8421462;
										}
										else if (item == 7088) {
											info->peffect = 8421465;
										}
										else if (item == 7098) {
											info->peffect = 8421466;
										}
										else if (item == 7196) {
											info->peffect = 8421471;
										}
										else if (item == 7392) {
											info->peffect = 8421472;
										}
										else if (item == 7488) {
											info->peffect = 8421479;
										}
										else if (item == 7586) {
											info->peffect = 8421480;
										}
										else if (item == 7650) {
											info->peffect = 8421481;
										}
										else if (item == 8036) {
											info->peffect = 8421494;
										}
										else if (item == 8910) {
											info->peffect = 8421505;
										}
										else if (item == 8942) {
											info->peffect = 8421506;
										}
										else if (item == 8948) {
											info->peffect = 8421507;
										}
										else if (item == 8946) {
											info->peffect = 8421509;
										}
										else if (item == 9116 || item == 9118 || item == 9120 || item == 9122) {
											info->peffect = 8421376 + 111;
										}
										else {
											getAutoEffect(peer);
											sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effect);
										}
										break;
									case 6:
										if (((PlayerInfo*)(event.peer->data))->cloth6 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth6 = 0;
											((PlayerInfo*)(event.peer->data))->canDoubleJump = false;
											sendState(peer);
											getAutoEffect(peer);
											sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effect);
											break;
										}
										{
											((PlayerInfo*)(event.peer->data))->cloth6 = pMov->plantingTree;
											if (item == 9006) {
												info->peffect = 8421511;
											}
											else {
												getAutoEffect(peer);
												sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effects);
											}
											((PlayerInfo*)(event.peer->data))->canDoubleJump = true;
											sendState(peer);

											// ^^^^ wings
										}
										break;
									case 7:
										if (pMov->plantingTree == 4288) {
											sendConsoleMsg(peer, "This item is `4disabled!");
											break;
										}
										if (((PlayerInfo*)(event.peer->data))->cloth7 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth7 = 0;
											getAutoEffect(peer);
											sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effect);
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth7 = pMov->plantingTree;
										sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effects);
										break;
									case 8:


										if (((PlayerInfo*)(event.peer->data))->cloth8 == pMov->plantingTree)
										{
											((PlayerInfo*)(event.peer->data))->cloth8 = 0;
											sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effect);
											break;
										}
										((PlayerInfo*)(event.peer->data))->cloth8 = pMov->plantingTree;
										sendConsoleMsg(peer, itemDefs.at(pMov->plantingTree).effects);
										break;
									case 9:


									default:
										if (
											def.id == 7166
											|| def.id == 5078 || def.id == 5080 || def.id == 5082 || def.id == 5084
											|| def.id == 5126 || def.id == 5128 || def.id == 5130 || def.id == 5132
											|| def.id == 5144 || def.id == 5146 || def.id == 5148 || def.id == 5150
											|| def.id == 5162 || def.id == 5164 || def.id == 5166 || def.id == 5168
											|| def.id == 5180 || def.id == 5182 || def.id == 5184 || def.id == 5186
											|| def.id == 7168 || def.id == 7170 || def.id == 7172 || def.id == 7174
											|| def.id == 5134 || def.id == 5153 || def.id == 5171 || def.id == 5189
											|| def.id == 9213
											) {
											if (((PlayerInfo*)(event.peer->data))->cloth_ances == pMov->plantingTree) {

												((PlayerInfo*)(event.peer->data))->cloth_ances = 0;
												break;
											}

											((PlayerInfo*)(event.peer->data))->cloth_ances = pMov->plantingTree;

										}
#ifdef TOTAL_LOG
										cout << "[!] Invalid item activated: " << pMov->plantingTree << " by " << ((PlayerInfo*)(event.peer->data))->displayName << endl;
#endif
										break;
									}
									// activate item
									if (info->cloth_hand == 5480) {
										info->peffect = 8421456;
									}

									sendClothes(peer);
									sendState(peer);
									sendPuncheffect(peer);

								END_CLOTHSETTER_FORCE:;
								}
								catch (...) {
									cout << "error in packettype == 10";
									enet_peer_disconnect(peer, 0);
									break;
								}
							}
							if (data2->packetType == 18)
							{
								sendPData(peer, pMov);
								// add talk buble
							}
							if (data2->punchX != -1 && data2->punchY != -1) {
								//cout << data2->packetType << endl;
								if (data2->packetType == 3)
								{
									try {
										if (((PlayerInfo*)(event.peer->data))->isRotatedLeft = pMov->characterState & 0x10) {
											((PlayerInfo*)(event.peer->data))->RotatedLeft = true;
										}
										else {
											((PlayerInfo*)(event.peer->data))->RotatedLeft = false;
										}
										using namespace std::chrono;
										if (((PlayerInfo*)(peer->data))->lastBREAK + 150 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											if (data2->plantingTree == 18) {

												if (((PlayerInfo*)(event.peer->data))->cloth_hand == 5480) {
													if (((PlayerInfo*)(event.peer->data))->cloth_face != 4288) {
														if (((PlayerInfo*)(event.peer->data))->isRotatedLeft = pMov->characterState & 0x10) {
															((PlayerInfo*)(event.peer->data))->RotatedLeft = true;
														}
														else {
															((PlayerInfo*)(event.peer->data))->RotatedLeft = false;
														}
														if (data2->punchY == ((PlayerInfo*)(event.peer->data))->y / 32) {
															if (((PlayerInfo*)(event.peer->data))->RotatedLeft == true) {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
															else {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
														}
														else if (data2->punchX == ((PlayerInfo*)(event.peer->data))->x / 32) {
															if (data2->punchY > ((PlayerInfo*)(event.peer->data))->y / 32) {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
															else if (data2->punchY < ((PlayerInfo*)(event.peer->data))->y / 32) {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY - 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY - 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
															else {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
														}
														else if (data2->punchY < ((PlayerInfo*)(event.peer->data))->y / 32) {
															if (((PlayerInfo*)(event.peer->data))->RotatedLeft == true) {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
															else {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
														}
														else if (data2->punchY < ((PlayerInfo*)(event.peer->data))->y / 32) {
															if (((PlayerInfo*)(event.peer->data))->RotatedLeft == true) {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															}
															else {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															}
														}
														else if (data2->punchY > ((PlayerInfo*)(event.peer->data))->y / 32) {
															if (((PlayerInfo*)(event.peer->data))->RotatedLeft == true) {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 1, data2->punchY + 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 2, data2->punchY + 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															}
															else {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 1, data2->punchY + 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 2, data2->punchY + 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															}

														}


													}
													else if (((PlayerInfo*)(peer->data))->cloth_hand == 5480 || ((PlayerInfo*)(peer->data))->cloth_feet == 1966) {

													}
													else if (((PlayerInfo*)(peer->data))->cloth_hand == 5480 || ((PlayerInfo*)(peer->data))->cloth_feet == 898) {

													}
													else if (((PlayerInfo*)(peer->data))->cloth_hand == 5480 || ((PlayerInfo*)(peer->data))->cloth_feet == 1830) {

													}
												}
												if (((PlayerInfo*)(event.peer->data))->cloth_hand == 7558) {
													if (((PlayerInfo*)(event.peer->data))->cloth_face != 4288) {
														if (((PlayerInfo*)(event.peer->data))->isRotatedLeft = pMov->characterState & 0x10) {
															((PlayerInfo*)(event.peer->data))->RotatedLeft = true;
														}
														else {
															((PlayerInfo*)(event.peer->data))->RotatedLeft = false;
														}
														if (data2->punchY == ((PlayerInfo*)(event.peer->data))->y / 32) {
															if (((PlayerInfo*)(event.peer->data))->RotatedLeft == true) {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 3, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 4, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 5, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 6, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 7, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
															else {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 3, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 4, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 5, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 6, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 7, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
														}
														else if (data2->punchX == ((PlayerInfo*)(event.peer->data))->x / 32) {
															if (data2->punchY > ((PlayerInfo*)(event.peer->data))->y / 32) {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY + 3, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY + 4, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY + 5, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY + 6, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY + 7, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
															else if (data2->punchY < ((PlayerInfo*)(event.peer->data))->y / 32) {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY - 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY - 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY - 3, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY - 4, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY - 5, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY - 6, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX, data2->punchY - 7, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
															else {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
														}
														else if (data2->punchY < ((PlayerInfo*)(event.peer->data))->y / 32) {
															if (((PlayerInfo*)(event.peer->data))->RotatedLeft == true) {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 3, data2->punchY - 3, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 4, data2->punchY - 4, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 5, data2->punchY - 5, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 6, data2->punchY - 6, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 7, data2->punchY - 7, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
															else {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 3, data2->punchY - 3, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 4, data2->punchY - 4, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 5, data2->punchY - 5, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 6, data2->punchY - 6, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 7, data2->punchY - 7, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

															}
														}
														else if (data2->punchY < ((PlayerInfo*)(event.peer->data))->y / 32) {
															if (((PlayerInfo*)(event.peer->data))->RotatedLeft == true) {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 3, data2->punchY - 3, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 4, data2->punchY - 4, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 5, data2->punchY - 5, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 6, data2->punchY - 6, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 7, data2->punchY - 7, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															}
															else {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 3, data2->punchY - 3, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 4, data2->punchY - 4, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 5, data2->punchY - 5, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 6, data2->punchY - 6, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 7, data2->punchY - 7, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															}
														}
														else if (data2->punchY > ((PlayerInfo*)(event.peer->data))->y / 32) {
															if (((PlayerInfo*)(event.peer->data))->RotatedLeft == true) {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 1, data2->punchY + 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 2, data2->punchY + 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 3, data2->punchY + 3, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 4, data2->punchY + 4, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 5, data2->punchY + 5, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 6, data2->punchY + 6, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX - 7, data2->punchY + 7, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															}
															else {
																sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 1, data2->punchY + 1, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 2, data2->punchY + 2, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 3, data2->punchY + 3, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 4, data2->punchY + 4, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 5, data2->punchY + 5, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 6, data2->punchY + 6, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
																sendTileUpdate(data2->punchX + 7, data2->punchY + 7, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
															}

														}


													}
													else if (((PlayerInfo*)(peer->data))->cloth_hand == 7558 || ((PlayerInfo*)(peer->data))->cloth_feet == 1966) {

													}
													else if (((PlayerInfo*)(peer->data))->cloth_hand == 7558 || ((PlayerInfo*)(peer->data))->cloth_feet == 898) {

													}
													else if (((PlayerInfo*)(peer->data))->cloth_hand == 7558 || ((PlayerInfo*)(peer->data))->cloth_feet == 1830) {

													}
												}
												if (((PlayerInfo*)(peer->data))->cloth_hand == 2952) {
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);

												}
												else {
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
												}
											}
											else {
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, ((PlayerInfo*)(event.peer->data))->netID, peer);
											}
										}
									}
									catch (...) {
										cout << "error in packettype == 3";
										enet_peer_disconnect(peer, 0);
										break;
									}
								}
								else {

								}
								/*PlayerMoving data;
								//data.packetType = 0x14;
								data.packetType = 0x3;
								//data.characterState = 0x924; // animation
								data.characterState = 0x0; // animation
								data.x = data2->punchX;
								data.y = data2->punchY;
								data.punchX = data2->punchX;
								data.punchY = data2->punchY;
								data.XSpeed = 0;
								data.YSpeed = 0;
								data.netID = ((PlayerInfo*)(event.peer->data))->netID;
								data.plantingTree = data2->plantingTree;
								SendPacketRaw(4, packPlayerMoving(&data), 56, 0, peer, ENET_PACKET_FLAG_RELIABLE);
								cout << "[!] Tile update at: " << data2->punchX << "x" << data2->punchY << endl;*/

							}
							delete data2;
							delete pMov;
						}
						/*char buffer[2048];
						for (int i = 0; i < event->packet->dataLength; i++)
						{
						sprintf(&buffer[2 * i], "%02X", event->packet->data[i]);
						}
						cout << buffer;*/
					}
				}
				break;
				case 5:
					break;
				case 6:
					//cout << GetTextPointerFromPacket(event.packet) << endl;
					break;
				}
				enet_packet_destroy(event.packet);
				break;
			}
			case ENET_EVENT_TYPE_DISCONNECT:
				try {
					sendPlayerLeave(peer, (PlayerInfo*)(event.peer->data));
					PUTANGINA(peer);
				}
				catch (...) {
					cout << "putanginang to" << endl;
				}
			}
		}
	cout << "Program ended??? Huh?" << endl;
	while (1);
	return 0;
};